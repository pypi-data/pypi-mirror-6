<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Leaf</title>
<meta http-equiv="Content-Language" content="English" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<div id="wrap">

<div id="top"></div>

<div id="content">

<div class="header">
<a href="index.html"><img src="leaf.png"></a>
<br><br><br><br><br>
</div>
<div class="breadcrumbs"><h1>LPL Howto</h1></div><div class="middle"><h2>Leaf Python Library</h2> The LPL is a Python package that is able
to bind Python functions to an LGL protocol. The LPL needs to know the
protocol (just a string in LGL code) and where to find the functions
mentioned in the protocol. The binding between protocol's filters and
Python functions is performed simply by searching for LGL nodes and
Python functions having the same name.  With this information, the LPL
can build a <i>leaf.prj.project</i> Python object, which is the main
interface to all Leaf's features. Supposing that a <i>str</i> object
called <i>protocol</i> contains valid LGL code and the functions to
bind are contained in a file named <i>example.py</i>, the following
code builds a Leaf project:

<div class="code">
  <pre>from leaf.prj import project
pr = project('example', 'protocol')</pre>
</div>

Leaf must be able to <i>import</i> the <i>example.py</i> file, so you
may need to do the following before building the Leaf project:

<div class="code">
  <pre>sys.path.insert(0,'.')</pre>
</div>


<p><h2>The <i>project</i> and <i>protocol</i> objects</h2> A Leaf project
can include a number of protocols. This is mainly due to
the <i>alternative protocols</i> feature that is still under
development. An usual Leaf project at the moment will include only one
unnamed protocols, that can be accessed this way:

<div class="code">
<pre>
pt = prj.protocols['']
</pre>
</div>
</p>

The <i>project</i> object manages higher level tasks. From the user's
point of view, it is responsible to grab user's source code and pass
it to the protocols. The <i>protocol</i> object, instead, is what the
user interacts with when the code has already been loaded. This means
that most Leaf's actions are performed through a <i>protocol</i>
object, but changes in the user's source code are to be taken care of
through the <i>project</i> object.

<p><h2>Requesting a resource</h2> The <i>protocol</i> object is used
to request a resource. If you have an LGL protocol like the following:
<div class="code">
<pre>
       / func2
func1 <
       \ func3
;
</pre>
</div>


You can ask to get the output of the filter <i>func2</i> this way:
<div class="code">
<pre>
pt.provide(func2)
</pre>
</div>

The LPE will look up the resource in its internal database to check if
it is already available. If not, it will produce it. To produce it, it
needs the output of <i>func1</i>, so it will recursively search for
it. If also the output of <i>func1</i> is not available, it will be
built on the fly, since it does not need any input. Now <i>func2</i>
can be run too. At this point, if you try the following: <div
class="code"> <pre> pt.provide(func3) </pre> </div> The LPE will
search for the output of<i>func3</i>. If not available, it will try to
build it. Since the output of <i>func1</i> is now available because it
was built on the last call to <i>provide</i>, LPE can now run
<i>func3</i> directly. From now on, all resources in the protocol are
available and returned immediately upon request.  </p> <p>

<h2>Resource management, session recovery and protocol
consistency</h2> The LPE automatically <b>stores all produced
resources</b> internally in primary memory and dumps them to the disk
as soon as they are built the first time. The <i>provide</i> method
first checks if a resource is <i>available</i> in primary memory; if
not, it searches for a dump on the disk; if there is no previous dump
the resource is built on the fly applying the process seen in the
previous section. The newly available resource is immediately dumped
to the disk.<br> Leaf tries to keep your source code <b>consistent</b>
with the stored resources. To this aim, your source code is stored
together with the resources it produces. If you change the code, Leaf
will detect the change by comparing the working code with the stored code
as soon as you request an <i>update</i>, automatically
<i>untrust</i>-ing the involved filters. The <i>untrust</i> method
clears the resources produced by a filter and all its descendants. You
can also use the <i>trust</i> method to force Leaf to accept a given
resource as the output of a filter.  <br> When a <i>project</i> object
is built, the corresponding dumps are searched for on the disk and
automatically loaded, including resources and source code that
produced them. This way, Leaf will be able to persistently keep track
of code changes across different working sessions.  </p>

<p><h2><i>protocol</i> methods</h2><br>
The following is a summary of the operation that you can perform an a protocol. It is extracted from the online help of the LPE.

<table border="1px", cellpadding="20px">
  <tr><td>clear</td><td>Clears and undumps a resource.</td></tr>
  <tr><td>dumpOff</td><td>Switches dumping OFF.</td></tr>
  <tr><td>dumpOff</td><td>Switches dumping ON.</td></tr>
  <tr><td>export</td><td>Exports the protocol to a pdf file, including docstrings.</td></tr>
  <tr><td>getinputs</td><td>Collects all input resources that are input to the given filter and returns a copy of them in a list.</td></tr>
  <tr><td>list</td><td>Lists the state of all resources.</td></tr>
  <tr><td>dumpOff</td><td>Switches dumping ON.</td></tr>
  <tr><td>provide</td><td>Provides a resource. The resource is returned if available, loaded from disk if dumped, built on the fly otherwise.</td></tr>
  <tr><td>rebuild</td><td>Clears a resource, then provides it.</td></tr>
  <tr><td>run</td><td>Provides all leaf (final) resources.</td></tr>
  <tr><td>trust</td><td>Assign a resource to a filter without invalidating dependent resources.</td></tr>
  <tr><td>run</td><td>Provides all leaf (final) resources.</td></tr>
  <tr><td>untrust</td><td>Clears a resource and all its dependent.</td></tr>
</table>
</div><div class="right"><h2>Navigation</h2><ul><li><a href="index.html">Home</a></li><li><a href="QandA.html">Q and A</a></li><li><a href="lgl.html">LGL Howto</a></li><li><a href="lpe.html">LPL Howto</a></li><li><a href="examples.html">Examples</a></li><li><a href="citing.html">Citing Leaf</a></li></ul></div>
		

<div id="clear"></div>

</div>

<div id="bottom"></div>

</div>

<div id="footer">
</div>

</body>
</html>
