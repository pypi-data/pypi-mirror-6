#!/usr/bin/python

#http://docs.python.org/2/library/argparse.html#module-argparse

import argparse
import time
import signal
import ntpath

from longtang.config import configuration
from longtang.system import properties
from longtang.system import system
from longtang.common import interactions
from longtang.actors.supervisors.main import main, messages, factory

def end_the_thingy_baby(signum, frame):
    print 'Signal handler called with signal', signum

if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Longtang v1.2.0',\
                                     prefix_chars='-',\
                                     epilog='For further information, please contact me at gszeliga@gmail.com')

    parser.add_argument('--source', dest='source_path', required=True, action='store', help='Source path where all your media files are located')
    parser.add_argument('--target', dest='target_path', required=True, action='store', help='Target path where all the media files will be classified')
    parser.add_argument('--verbosity', dest='verbosity', required=False, action='store', default=None, choices=['DEBUG', 'INFO', 'WARN', 'ERROR'], help='Verbosity level')
    parser.add_argument('--override-tags', dest='override', required=False, action='store', nargs='?', default=False, const=True, help='If present, all id3tags will be overriden using MusicBrainz information (this parameter is not compatible with --offline option)')
    parser.add_argument('--offline', dest='offline', required=False, action='store', nargs='?', default=False, const=True, help='If present, no request to MusicBrainz service will be commited so that any incomplete metatag will cause the file to be ignored (this parameter is not compatible with --override option)')
    parser.add_argument('--disable-cover-art', dest='disable_cover_art', required=False, action='store', nargs='?', default=False, const=True, help='If present, no album cover art will be retrieved for any matched album')
                       
    args = parser.parse_args()

    if args.override and args.offline:
        print '--override parameter and --offline parameter are incompatible. Only one of them should be present.'
    else:

        config_builder = configuration.LongTangConfigurationBuilder()

        source_path = unicode(args.source_path, encoding='utf-8', errors='replace')
        target_path = unicode(args.target_path, encoding='utf-8', errors='replace')

        config = config_builder.read_from(source_path)\
                               .generate_at(target_path)\
                               .override_tags(args.override)\
                               .offline_mode(args.offline)\
                               .download_cover_art(not(args.disable_cover_art))\
                               .build()

        props_builder = properties.SystemPropertiesBuilder()

        props_builder.verbosity(args.verbosity)

        actor_system = system.ActorSystem(props_builder.build())
        main_ref = actor_system.with_factory(factory.MainSupervisorFactory(config),'main-actor')

        starting_point = time.time()

        signal.signal(signal.SIGINT, end_the_thingy_baby)

        summary = interactions.InteractionPatterns.ask(actor_system, main_ref, messages.KickOffMediaProcessing()).summary() 

        elapsed_time = int(time.time() - starting_point)

        elapsed_time_minutes = elapsed_time / 60
        elapsed_time_seconds = elapsed_time % 60

        elapsed_time_hours= elapsed_time_minutes / 60
        elapsed_time_minutes = elapsed_time_minutes % 60

        def print_compressed_summary(entries):

            def find_mediainfo(audiofile_entry):
                mediainfo = summary.audio().successes().find(audiofile_entry)

                if mediainfo is None:
                    mediainfo = summary.audio().failures().find(audiofile_entry)
                    return 'F', mediainfo[1]
                else:
                    return '*', mediainfo[1]

            if len(entries) > 0:
                for tracking_id, compressed_file_info in entries:
                    print u'(+) [{0}] {1}'.format(tracking_id, compressed_file_info.mediafile.sourcepath.replace(source_path, './'))

                    for audiofile in compressed_file_info.mediafile.audiofiles.all():

                        status, mediainfo = find_mediainfo(audiofile)

                        print u' |__ [{1}][{0}] {2}'.format(audiofile,status,ntpath.basename(mediainfo.mediafile.sourcepath))
                    
                    print '\n'
            else:
                print '<None>'
                print '\n'

        print '\n'
        print 'Successfull compressed files\n'
        print_compressed_summary(summary.compressed().successes().all())
        print 'Failed compressed files\n'
        print_compressed_summary(summary.compressed().failures().all())

        def print_audio_summary(entries):
            if len(entries) > 0:
                for tracking_id, media_descriptor in entries:
                    print u'[' + tracking_id + '] ' + media_descriptor.mediafile.sourcepath.replace(source_path, './')
            else:
                print '<None>'
            
            print '\n'

        print 'Successfull audio files:\n\n'
        print_audio_summary(summary.audio().successes(False).all())     
        print 'Failed audio files:\n\n'
        print_audio_summary(summary.audio().failures(False).all())   

        print '\n\n'
        print '(+) Total compressed files: {0}'.format(summary.compressed().total())
        print ' |__ Successes: {0}'.format(summary.compressed().successes().total())
        print ' |__ Failures: {0}'.format(summary.compressed().failures().total())
        print '\n'
        print '(+) Total audio files: {0}'.format(summary.audio().total())
        print ' |__ Successes: {0}'.format(summary.audio().successes().total())
        print ' |__ Failures: {0}'.format(summary.audio().failures().total())
        print '\nElapsed time: {0}h {1}m {2}s'.format(elapsed_time_hours, elapsed_time_minutes, elapsed_time_seconds)
        print '\n'
