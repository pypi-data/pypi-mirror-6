/*
 * DO NOT EDIT THIS FILE!
 *
 * Parser generated by BisonGen on Wed May 14 11:28:31 2008.
 */

/*************************************************************************/
/* All symbols defined below should be prefixed with yy or YY to avoid   */
/* infringing on the user namespace.  This should be done even for local */
/* variables, as they might otherwise be expanded by user macros.        */
/*************************************************************************/

/* user declaration */
#include "Python.h"
#include "structmember.h"

#if PY_VERSION_HEX < 0x02020000
#error Python 2.2 or newer required for the extension module interface
#endif

#ifndef Py_USING_UNICODE
#error Python must be configured with --enable-unicode
#endif

#if PY_VERSION_HEX < 0x02050000
typedef int Py_ssize_t;
#define PY_FORMAT_SIZE_T ""
#define PY_SSIZE_T_MAX INT_MAX
#define PY_SSIZE_T_MIN INT_MIN

/* Define the `Py_VISIT` macro the same as the one in 2.5+ */
#ifdef Py_VISIT
#undef Py_VISIT
#endif
#define Py_VISIT(op)                            \
  do {                                          \
    if (op) {                                   \
      int vret = visit((PyObject *)(op), arg);  \
      if (vret) return vret;                    \
    }                                           \
  } while (0)

#if PY_VERSION_HEX < 0x02040000
#define Py_CLEAR(op)                            \
  do {                                          \
    if (op) {                                   \
      PyObject *tmp = (PyObject *)(op);         \
      (op) = NULL;                              \
      Py_DECREF(tmp);                           \
    }                                           \
  } while (0)

#if PY_VERSION_HEX < 0x02030000
#define PyMODINIT_FUNC DL_EXPORT(void)
#endif /* PY_VERSION_HEX < 0x02030000 */
#endif /* PY_VERSION_HEX < 0x02040000 */
#endif /* PY_VERSION_HEX < 0x02050000 */

/* Macro to help reclaim as much memory as possible for PyTypeObjects. */
#ifdef Py_DEBUG
#define PyType_CLEAR(op)                                          \
  do {                                                            \
    PyObject_ClearWeakRefs((PyObject *)(op));                     \
    Py_XDECREF(((PyTypeObject *)(op))->tp_dict);                  \
    Py_XDECREF(((PyTypeObject *)(op))->tp_bases);                 \
    Py_XDECREF(((PyTypeObject *)(op))->tp_mro);                   \
    Py_XDECREF(((PyTypeObject *)(op))->tp_cache);                 \
    Py_XDECREF(((PyTypeObject *)(op))->tp_subclasses);            \
    Py_XDECREF(((PyTypeObject *)(op))->tp_weaklist);              \
  } while(0)
#else
#define PyType_CLEAR(op)
#endif /* defined(Py_DEBUG) */

static PyObject *yy_import(const char *yymodule, const char *yyname)
{
  static PyObject *yybuiltins_str=NULL;
  static PyObject *yyimport_str=NULL;
  PyObject *yyglobals, *yybuiltins, *yyimport, *yyfromlist, *yyresult;

  /* Initialize string constants */
  if (yybuiltins_str == NULL) {
    yybuiltins_str = PyString_InternFromString("__builtins__");
    if (yybuiltins_str == NULL) return NULL;
    yyimport_str = PyString_InternFromString("__import__");
    if (yyimport_str == NULL) return NULL;
  }
  /* Get the builtins from current globals */
  yyglobals = PyEval_GetGlobals();
  if (yyglobals) {
    yybuiltins = PyObject_GetItem(yyglobals, yybuiltins_str);
    if (yybuiltins == NULL) return NULL;
    Py_INCREF(yyglobals);
  } else {
    /* No globals -- use standard builtins */
    PyErr_Clear();
    yybuiltins = PyImport_ImportModule("__builtin__");
    if (yybuiltins == NULL) return NULL;
    yyglobals = Py_BuildValue("{OO}", yybuiltins_str, yybuiltins);
    if (yyglobals == NULL) {
      Py_DECREF(yybuiltins);
      return NULL;
    }
  }
  /* Get the `__import__` function from the builtins */
  if (PyDict_Check(yybuiltins))
    yyimport = PyObject_GetItem(yybuiltins, yyimport_str);
  else
    yyimport = PyObject_GetAttr(yybuiltins, yyimport_str);
  if (yyimport == NULL) {
    Py_DECREF(yyglobals);
    Py_DECREF(yybuiltins);
    return NULL;
  }
  Py_DECREF(yybuiltins);
  /* Call the `__import__` function */
  yyfromlist = Py_BuildValue("(s)", yyname ? yyname : "__doc__");
  if (yyfromlist == NULL) {
    Py_DECREF(yyglobals);
    Py_DECREF(yyimport);
    return NULL;
  }
  yyresult = PyObject_CallFunction(yyimport, "sNOO", yymodule, yyglobals,
                                   yyglobals, yyfromlist);
  Py_DECREF(yyimport);
  /* Get the identifier from the module object */
  if (yyresult != NULL && yyname != NULL) {
    yyimport = yyresult;
    yyresult = PyObject_GetAttr(yyimport, PyTuple_GET_ITEM(yyfromlist, 0));
    Py_DECREF(yyimport);
  }
  Py_DECREF(yyfromlist);
  return yyresult;
}

typedef struct {
  const char *yymodule;
  const char *yyname;
  PyObject **yyptr;
} yyimport_t;

static PyObject *YY_ErrorObject;

#ifdef BisonGen_FORWARDS_COMPATIBLE
#define MODULE_NAME "amara.xpath.parser.xpathparser"
#define MODULE_BASENAME "_xpathparser"
#define MODULE_INITFUNC init_xpathparser
#else
#define MODULE_NAME "amara.xpath.parser.xpathparser"
#define MODULE_BASENAME "xpathparserc"
#define MODULE_INITFUNC initxpathparserc
#endif
#define PARSER_NAME "xpathparser"

/* modules required for action routines */
static PyObject *absolute_location_path;
static PyObject *relative_location_path;
static PyObject *abbreviated_absolute_location_path;
static PyObject *abbreviated_relative_location_path;
static PyObject *location_step;
static PyObject *abbreviated_step;
static PyObject *axis_specifier;
static PyObject *node_type;
static PyObject *name_test;
static PyObject *predicates;
static PyObject *predicate;
static PyObject *string_literal;
static PyObject *number_literal;
static PyObject *variable_reference;
static PyObject *function_call;
static PyObject *union_expr;
static PyObject *path_expr;
static PyObject *filter_expr;
static PyObject *or_expr;
static PyObject *and_expr;
static PyObject *equality_expr;
static PyObject *relational_expr;
static PyObject *additive_expr;
static PyObject *multiplicative_expr;
static PyObject *unary_expr;

static yyimport_t yymodule_imports[] = {
  { "amara.xpath.locationpaths", "absolute_location_path",
    &absolute_location_path },
  { "amara.xpath.locationpaths", "relative_location_path",
    &relative_location_path },
  { "amara.xpath.locationpaths", "abbreviated_absolute_location_path",
    &abbreviated_absolute_location_path },
  { "amara.xpath.locationpaths", "abbreviated_relative_location_path",
    &abbreviated_relative_location_path },
  { "amara.xpath.locationpaths", "location_step",
    &location_step },
  { "amara.xpath.locationpaths", "abbreviated_step",
    &abbreviated_step },
  { "amara.xpath.locationpaths.axisspecifiers", "axis_specifier",
    &axis_specifier },
  { "amara.xpath.locationpaths.nodetests", "node_type",
    &node_type },
  { "amara.xpath.locationpaths.nodetests", "name_test",
    &name_test },
  { "amara.xpath.locationpaths.predicates", "predicates",
    &predicates },
  { "amara.xpath.locationpaths.predicates", "predicate",
    &predicate },
  { "amara.xpath.expressions.basics", "string_literal",
    &string_literal },
  { "amara.xpath.expressions.basics", "number_literal",
    &number_literal },
  { "amara.xpath.expressions.basics", "variable_reference",
    &variable_reference },
  { "amara.xpath.expressions.functioncalls", "function_call",
    &function_call },
  { "amara.xpath.expressions.nodesets", "union_expr",
    &union_expr },
  { "amara.xpath.expressions.nodesets", "path_expr",
    &path_expr },
  { "amara.xpath.expressions.nodesets", "filter_expr",
    &filter_expr },
  { "amara.xpath.expressions.booleans", "or_expr",
    &or_expr },
  { "amara.xpath.expressions.booleans", "and_expr",
    &and_expr },
  { "amara.xpath.expressions.booleans", "equality_expr",
    &equality_expr },
  { "amara.xpath.expressions.booleans", "relational_expr",
    &relational_expr },
  { "amara.xpath.expressions.numbers", "additive_expr",
    &additive_expr },
  { "amara.xpath.expressions.numbers", "multiplicative_expr",
    &multiplicative_expr },
  { "amara.xpath.expressions.numbers", "unary_expr",
    &unary_expr },
  { NULL }
};

/* end user declaration */

#include <stddef.h> /* NULL, ptrdiff_t, size_t */
#include <assert.h> /* assert() */
#include <string.h> /* memcpy(), memset(), strlen(), stpcpy() (with GCC) */

#ifndef YY_PTRDIFF_T
#define YY_PTRDIFF_T ptrdiff_t
#endif
#ifndef YY_FORMAT_PTRDIFF_T
#  if defined(__STDC__)
#    define YY_FORMAT_PTRDIFF_T "t"
#  elif defined(_WIN32) || defined(_WIN64)
#    define YY_FORMAT_PTRDIFF_T "I"
#  else
#    undef YY_PTRDIFF_T
#    define YY_PTRDIFF_T unsigned long
#    define YY_FORMAT_PTRDIFF_T "l"
#  endif
#endif /* YY_FORMAT_PTRDIFF_T */


/* token definitions */
#define Literal 257
#define Number 258
#define VariableReference 259
#define NameTest 260
#define FunctionName 261
#define NodeType 262
#define AxisName 263
#define OR_OP 264
#define AND_OP 265
#define EQUALITY_OP 266
#define RELATIONAL_OP 267
#define MULTIPLICATIVE_OP 268
#define DOUBLE_DOT 269
#define DOUBLE_COLON 270
#define DOUBLE_SLASH 271

/* vector mapping lexer token numbers into internal token numbers */
static const int token_translations[] = {
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      19,    20,     2,    27,    25,    28,    23,    18,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,    24,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,    21,     2,    22,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,    26,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
      16,    17
};

#define YYTRANSLATE(x) ((unsigned)(x) <= 271 ? token_translations[x] : 57)

/* vector of items of all rules. */
static const int rhs_tokens[] = {
       0,    31,     0,    30,     0,    18,     0,    18,    31,     0,
      38,     0,    32,     0,    31,    18,    32,     0,    39,     0,
      34,    35,     0,    34,    35,    33,     0,    40,     0,    36,
       0,    33,    36,     0,     9,    16,     0,    41,     0,     6,
       0,     8,    19,    20,     0,     8,    19,     3,    20,     0,
      21,    37,    22,     0,    42,     0,    17,    31,     0,    31,
      17,    32,     0,    23,     0,    15,     0,    24,     0,     0,
      50,     0,     5,     0,    19,    42,    20,     0,     3,     0,
       4,     0,    44,     0,     7,    19,    20,     0,     7,    19,
      45,    20,     0,    46,     0,    45,    25,    46,     0,    42,
       0,    48,     0,    47,    26,    48,     0,    29,     0,    49,
       0,    49,    18,    31,     0,    49,    17,    31,     0,    43,
       0,    43,    33,     0,    51,     0,    50,    10,    51,     0,
      52,     0,    51,    11,    52,     0,    53,     0,    52,    12,
      53,     0,    54,     0,    53,    13,    54,     0,    55,     0,
      54,    27,    55,     0,    54,    28,    55,     0,    56,     0,
      55,    14,    56,     0,    47,     0,    28,    47,     0
};

/* vector of line numbers and filename of all rules */
static const char* const rule_info[] = {
  ": line 0",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 5",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 8",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 15",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 24",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 34",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 41",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 50",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 61",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 68",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 78",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 90",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 103",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 115",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 132",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 142",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 160",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 169",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 180",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 196",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 211",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 218",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 232",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 247",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 250",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 257",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 266",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 279",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 286",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 295",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 307",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 316",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 326",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 333",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 344",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 360",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 372",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 391",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 398",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 401",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 416",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 419",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 422",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 433",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 449",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 452",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 467",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 470",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 485",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 488",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 503",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 506",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 521",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 524",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 539",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 542",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 553",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 568",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 571",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 586",
  "amara/xpath/parser/xpath_grammar.bgen.frag: line 589"
};

/* vector of string-names indexed by token number */
static const char* const token_names[] = {
  "<EOF>",
  "error",
  "$undefined.",
  "Literal",
  "Number",
  "VariableReference",
  "NameTest",
  "FunctionName",
  "NodeType",
  "AxisName",
  "OR_OP",
  "AND_OP",
  "EQUALITY_OP",
  "RELATIONAL_OP",
  "MULTIPLICATIVE_OP",
  "DOUBLE_DOT",
  "DOUBLE_COLON",
  "DOUBLE_SLASH",
  "/",
  "(",
  ")",
  "[",
  "]",
  ".",
  "@",
  ",",
  "|",
  "+",
  "-",
  "LocationPath",
  "AbsoluteLocationPath",
  "RelativeLocationPath",
  "Step",
  "Predicate.list",
  "AxisSpecifier",
  "NodeTest",
  "Predicate",
  "PredicateExpr",
  "AbbreviatedAbsoluteLocationPath",
  "AbbreviatedRelativeLocationPath",
  "AbbreviatedStep",
  "AbbreviatedAxisSpecifier",
  "Expr",
  "PrimaryExpr",
  "FunctionCall",
  "Argument.list",
  "Argument",
  "UnionExpr",
  "PathExpr",
  "FilterExpr",
  "OrExpr",
  "AndExpr",
  "EqualityExpr",
  "RelationalExpr",
  "AdditiveExpr",
  "MultiplicativeExpr",
  "UnaryExpr",
  "0"
};

/* symbol number of symbol that rule derives. */
static const int derives[] = {
       0,    29,    29,    30,    30,    30,    31,    31,    31,    32,
      32,    32,    33,    33,    34,    34,    35,    35,    35,    36,
      37,    38,    39,    40,    40,    41,    41,    42,    43,    43,
      43,    43,    43,    44,    44,    45,    45,    46,    47,    47,
      48,    48,    48,    48,    49,    49,    50,    50,    51,    51,
      52,    52,    53,    53,    54,    54,    54,    55,    55,    56,
      56
};

/* number of symbols composing right hand side of rule. */
static const int rhs_size[] = {
       0,     1,     1,     1,     2,     1,     1,     3,     1,     2,
       3,     1,     1,     2,     2,     1,     1,     3,     4,     3,
       1,     2,     3,     1,     1,     1,     0,     1,     1,     3,
       1,     1,     1,     3,     4,     1,     3,     1,     1,     3,
       1,     1,     3,     3,     1,     2,     1,     3,     1,     3,
       1,     3,     1,     3,     1,     3,     3,     1,     3,     1,
       2
};

/* default rule to reduce with in state. 0 means the default is an error.
   indexed by state number */
static const int default_action[] = {
      26,    30,    31,    28,     0,     0,    24,    26,     3,    26,
      23,    25,    26,    40,     2,     1,     6,     0,     5,     8,
      11,    15,    44,    32,    59,    38,    41,    27,    46,    48,
      50,    52,    54,    57,    26,    14,    21,     4,     0,    60,
      26,    26,    16,     0,     9,    26,    45,    12,    26,    26,
      26,    26,    26,    26,    26,    26,    26,    26,    33,    37,
       0,    35,    29,    22,     7,     0,    10,     0,    20,    13,
      39,    43,    42,    47,    49,    51,    53,    55,    56,    58,
      34,    26,     0,    17,    19,    36,    18,     0,     0,     0
};

/* default state to go to after a reduction of a rule.
   indexed by variable number (lhs token) */
static const int default_goto[] = {
      13,    14,    15,    16,    46,    17,    44,    47,    67,    18,
      19,    20,    21,    59,    22,    23,    60,    61,    24,    25,
      26,    27,    28,    29,    30,    31,    32,    33
};

/* index in yytable of the portion describing state (indexed by state number)
   If the value in yytable is positive, we shift the token and go to that state.
   If the value is negative, it is minus a rule number to reduce by.
   If the value is zero, the default action from yydefact[s] is used. */
static const int action_idx[] = {
       1,-32768,-32768,-32768,    18,    15,-32768,    -2,    80,     1,
  -32768,-32768,    75,-32768,-32768,    -3,-32768,    24,-32768,-32768,
  -32768,-32768,    26,-32768,     7,-32768,     9,    29,    50,    51,
      54,    14,    55,-32768,    31,-32768,    -3,    -3,    44,     7,
      -2,    -2,-32768,    56,    26,    53,    26,-32768,    75,    -2,
      -2,    53,    53,    53,    53,    53,    53,    53,-32768,-32768,
      -8,-32768,-32768,-32768,-32768,     8,    26,    52,-32768,-32768,
  -32768,    -3,    -3,    50,    51,    54,    14,    55,    55,-32768,
  -32768,    53,    63,-32768,-32768,-32768,-32768,    73,    85,-32768
};

/* The index in yytable of the portion describing what to do after reducing a rule.
   The value from yytable is the state to go to. */
static const int goto_idx[] = {
  -32768,-32768,    -6,    12,    43,-32768,-32768,   -43,-32768,-32768,
  -32768,-32768,-32768,     0,-32768,-32768,-32768,    16,    79,    48,
  -32768,-32768,    49,    57,    58,    47,    10,    45
};

/* A vector filled with portions for different uses.
   (using action_idx and goto_idx) */
static const int yytable[] = {
      87,    36,    37,    69,     1,     2,     3,     5,     4,    38,
       5,    82,    80,     6,    40,    41,     6,    81,     7,     8,
       9,    10,    11,    69,    10,    11,    49,    50,    83,    12,
      42,    35,    43,    48,     1,     2,     3,    34,     4,    51,
       5,    55,    56,    71,    72,    68,     6,    45,     7,     8,
       9,    58,    63,    64,    10,    11,     1,     2,     3,    12,
       4,    52,     5,    53,    62,    77,    78,    54,     6,    57,
       7,     8,     9,    88,    84,    65,    10,    11,     1,     2,
       3,    12,     4,    86,     5,    89,   -26,    66,   -26,     5,
       6,    39,     7,     8,     9,     6,    70,    85,    10,    11,
      73,    76,    79,    10,    11,     0,     0,     0,     0,    74,
       0,    75
};

/* a vector indexed in parallel with yytable.
   It indicates the bounds of the portion you are trying to examine. */
static const int yycheck[] = {
       0,     7,     8,    46,     3,     4,     5,     9,     7,     9,
       9,     3,    20,    15,    17,    18,    15,    25,    17,    18,
      19,    23,    24,    66,    23,    24,    17,    18,    20,    28,
       6,    16,     8,    26,     3,     4,     5,    19,     7,    10,
       9,    27,    28,    49,    50,    45,    15,    21,    17,    18,
      19,    20,    40,    41,    23,    24,     3,     4,     5,    28,
       7,    11,     9,    12,    20,    55,    56,    13,    15,    14,
      17,    18,    19,     0,    22,    19,    23,    24,     3,     4,
       5,    28,     7,    20,     9,     0,     6,    44,     8,     9,
      15,    12,    17,    18,    19,    15,    48,    81,    23,    24,
      51,    54,    57,    23,    24,    -1,    -1,    -1,    -1,    52,
      -1,    53
};

#define YYLAST 111
#define YYFINAL 89
#define YYFLAG -32768
#define YYNTBASE 29

#define LEXER_OP_FAILURE 0
#define LEXER_OP_SUCCESS 1
#define LEXER_OP_BOL 2
#define LEXER_OP_EOL 3
#define LEXER_OP_EOF 4
#define LEXER_OP_ANY 5
#define LEXER_OP_LITERAL 6
#define LEXER_OP_NOT_LITERAL 7
#define LEXER_OP_CHARSET 8
#define LEXER_OP_NOT_CHARSET 9
#define LEXER_OP_ASSERT 10
#define LEXER_OP_BRANCH 11
#define LEXER_OP_REPEAT 12
#define LEXER_OP_REPEAT_RANGE 13

#define LEXER_CHARSET_FAILURE 0
#define LEXER_CHARSET_LITERAL 1
#define LEXER_CHARSET_RANGE 2
#define LEXER_CHARSET_SMALL 3
#define LEXER_CHARSET_BIG 4

#define LEXER_INITIAL 1
#define LEXER_OPERATOR 2
#define LEXER_START_STATE LEXER_INITIAL

static unsigned char lexer_charsets[56][32] = {
  { 0x00, 0x26, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07,
    0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x7F, 0xFE, 0xFD, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x0F, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x31, 0xFC },
  { 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xF8,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
    0xFF, 0x7F, 0x7F, 0x54, 0xFD, 0xFF, 0x0F, 0x00 },
  { 0xFE, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xDF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x9F, 0x19, 0xFF, 0xFF, 0xFF, 0xCF, 0x3F, 0x03 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02,
    0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x07, 0x07, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0x07, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7C,
    0xFF, 0x7F, 0x2F, 0x00, 0x60, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x00, 0xFF,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x03,
    0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x00 },
  { 0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E,
    0x00, 0x00, 0x1C, 0x00, 0xE0, 0xAF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 },
  { 0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xCD, 0x23, 0x00, 0x00, 0x00, 0xB0,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xBF, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x03,
    0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00 },
  { 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x0D, 0x00, 0x3F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x96, 0x25, 0xF0, 0xFE, 0xAE, 0x6C, 0x0D, 0x20,
    0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF,
    0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00 },
  { 0xED, 0xDA, 0x07, 0x00, 0x00, 0x00, 0x00, 0x50, 0x01, 0x50, 0x31, 0x82,
    0xAB, 0x62, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xC9, 0x80, 0xF5,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03 },
  { 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA,
    0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F,
    0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 0xDC, 0x1F },
  { 0x00, 0x00, 0x00, 0x00, 0x40, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07 },
  { 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x80, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFB, 0xFF, 0xFF, 0xBB,
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x07, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0xFF, 0x9F, 0x3D, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xFF, 0x3F, 0x1E, 0x00,
    0x0C, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
    0x9F, 0x39, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00 },
  { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x87, 0x39, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
    0xBF, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x8F, 0x39, 0xC0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
    0xC7, 0x3D, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xDF, 0x3D, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
    0xDF, 0x3D, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xCF, 0x3D, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x07, 0x80, 0x7F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x1B,
    0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xA0, 0xC2, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xDF, 0x0F, 0xBF, 0xFE, 0xFF, 0x3F, 0xFE, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x1F, 0x02, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70 },
};

static unsigned char lexer_blockmaps[5][256] = {
  { 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x0C, 0x0D,
    0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x14, 0x15, 0x0A, 0x16, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x17, 0x18, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x1A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A },
  { 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x1B, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
    0x19, 0x19, 0x19, 0x1C, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A },
  { 0x1E, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x1F, 0x0A, 0x0A, 0x20, 0x20, 0x21,
    0x20, 0x22, 0x23, 0x24, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A },
  { 0x0A, 0x0A, 0x0A, 0x25, 0x26, 0x27, 0x28, 0x0A, 0x0A, 0x29, 0x2A, 0x2B,
    0x2C, 0x2D, 0x2E, 0x2F, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x30, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x31, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A },
  { 0x32, 0x0A, 0x33, 0x34, 0x0A, 0x0A, 0x35, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x36, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x37, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A },
};

static const Py_UCS4 lexer_INITIAL_pattern_0[] = {
       8,     4,     3,     1,     0,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_1[] = {
       6,    58,     6,    58,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_2[] = {
       6,    47,     6,    47,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_3[] = {
      11,     4,     6,    61,     1,     6,     6,    33,     6,    61,
       1,     0,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_4[] = {
      11,     7,     8,     4,     3,     2,     0,     1,     6,     6,
      60,     6,    61,     1,     6,     6,    62,     6,    61,     1,
       0,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_5[] = {
      11,    10,     6,   110,     6,   111,     6,   100,     6,   101,
       1,    10,     6,   116,     6,   101,     6,   120,     6,   116,
       1,    16,     6,    99,     6,   111,     6,   109,     6,   109,
       6,   101,     6,   110,     6,   116,     1,    46,     6,   112,
       6,   114,     6,   111,     6,    99,     6,   101,     6,   115,
       6,   115,     6,   105,     6,   110,     6,   103,     6,    45,
       6,   105,     6,   110,     6,   115,     6,   116,     6,   114,
       6,   117,     6,    99,     6,   116,     6,   105,     6,   111,
       6,   110,     1,     0,    10,    13,    12,     8,     0,     8,
       4,     3,     0,     0,     1,     6,    40,     1,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_6[] = {
      11,     4,     6,    95,     1,    18,    11,     7,     8,     4,
       4,     0,     0,     1,     7,     8,     4,     4,     1,     0,
       1,     0,     1,     0,    12,    51,     0,    11,     7,     8,
       4,     3,    29,     0,     1,    18,    11,     7,     8,     4,
       4,     0,     0,     1,     7,     8,     4,     4,     1,     0,
       1,     0,     1,     7,     8,     4,     4,     2,     0,     1,
       7,     8,     4,     4,     3,     0,     1,     7,     8,     4,
       4,     4,     0,     1,     0,     1,    10,    15,    12,     8,
       0,     8,     4,     3,     0,     0,     1,     6,    58,     6,
      58,     1,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_7[] = {
      11,    12,     6,    39,    12,     5,     0,     7,    39,     1,
       6,    39,     1,    12,     6,    34,    12,     5,     0,     7,
      34,     1,     6,    34,     1,     0,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_8[] = {
      11,    32,    12,     8,     1,     8,     4,     4,     2,     0,
       1,    13,    20,     0,     1,     6,    46,    13,    13,     0,
       1,    12,     8,     1,     8,     4,     4,     2,     0,     1,
       1,     1,     1,    13,     6,    46,    12,     8,     1,     8,
       4,     4,     2,     0,     1,     1,     0,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_9[] = {
       6,    36,    13,    82,     0,     1,    11,     4,     6,    95,
       1,    18,    11,     7,     8,     4,     4,     0,     0,     1,
       7,     8,     4,     4,     1,     0,     1,     0,     1,     0,
      12,    51,     0,    11,     7,     8,     4,     3,    29,     0,
       1,    18,    11,     7,     8,     4,     4,     0,     0,     1,
       7,     8,     4,     4,     1,     0,     1,     0,     1,     7,
       8,     4,     4,     2,     0,     1,     7,     8,     4,     4,
       3,     0,     1,     7,     8,     4,     4,     4,     0,     1,
       0,     1,     6,    58,     1,    11,     4,     6,    95,     1,
      18,    11,     7,     8,     4,     4,     0,     0,     1,     7,
       8,     4,     4,     1,     0,     1,     0,     1,     0,    12,
      51,     0,    11,     7,     8,     4,     3,    29,     0,     1,
      18,    11,     7,     8,     4,     4,     0,     0,     1,     7,
       8,     4,     4,     1,     0,     1,     0,     1,     7,     8,
       4,     4,     2,     0,     1,     7,     8,     4,     4,     3,
       0,     1,     7,     8,     4,     4,     4,     0,     1,     0,
       1,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_10[] = {
      13,    82,     0,     1,    11,     4,     6,    95,     1,    18,
      11,     7,     8,     4,     4,     0,     0,     1,     7,     8,
       4,     4,     1,     0,     1,     0,     1,     0,    12,    51,
       0,    11,     7,     8,     4,     3,    29,     0,     1,    18,
      11,     7,     8,     4,     4,     0,     0,     1,     7,     8,
       4,     4,     1,     0,     1,     0,     1,     7,     8,     4,
       4,     2,     0,     1,     7,     8,     4,     4,     3,     0,
       1,     7,     8,     4,     4,     4,     0,     1,     0,     1,
       6,    58,     1,    11,     4,     6,    95,     1,    18,    11,
       7,     8,     4,     4,     0,     0,     1,     7,     8,     4,
       4,     1,     0,     1,     0,     1,     0,    12,    51,     0,
      11,     7,     8,     4,     3,    29,     0,     1,    18,    11,
       7,     8,     4,     4,     0,     0,     1,     7,     8,     4,
       4,     1,     0,     1,     0,     1,     7,     8,     4,     4,
       2,     0,     1,     7,     8,     4,     4,     3,     0,     1,
       7,     8,     4,     4,     4,     0,     1,     0,     1,    10,
      13,    12,     8,     0,     8,     4,     3,     0,     0,     1,
       6,    40,     1,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_11[] = {
      11,     4,     6,    42,     1,    82,    11,     4,     6,    95,
       1,    18,    11,     7,     8,     4,     4,     0,     0,     1,
       7,     8,     4,     4,     1,     0,     1,     0,     1,     0,
      12,    51,     0,    11,     7,     8,     4,     3,    29,     0,
       1,    18,    11,     7,     8,     4,     4,     0,     0,     1,
       7,     8,     4,     4,     1,     0,     1,     0,     1,     7,
       8,     4,     4,     2,     0,     1,     7,     8,     4,     4,
       3,     0,     1,     7,     8,     4,     4,     4,     0,     1,
       0,     1,     6,    58,     6,    42,     1,   161,    13,    82,
       0,     1,    11,     4,     6,    95,     1,    18,    11,     7,
       8,     4,     4,     0,     0,     1,     7,     8,     4,     4,
       1,     0,     1,     0,     1,     0,    12,    51,     0,    11,
       7,     8,     4,     3,    29,     0,     1,    18,    11,     7,
       8,     4,     4,     0,     0,     1,     7,     8,     4,     4,
       1,     0,     1,     0,     1,     7,     8,     4,     4,     2,
       0,     1,     7,     8,     4,     4,     3,     0,     1,     7,
       8,     4,     4,     4,     0,     1,     0,     1,     6,    58,
       1,    11,     4,     6,    95,     1,    18,    11,     7,     8,
       4,     4,     0,     0,     1,     7,     8,     4,     4,     1,
       0,     1,     0,     1,     0,    12,    51,     0,    11,     7,
       8,     4,     3,    29,     0,     1,    18,    11,     7,     8,
       4,     4,     0,     0,     1,     7,     8,     4,     4,     1,
       0,     1,     0,     1,     7,     8,     4,     4,     2,     0,
       1,     7,     8,     4,     4,     3,     0,     1,     7,     8,
       4,     4,     4,     0,     1,     0,     1,     1,     0,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_12[] = {
       6,    46,     6,    46,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_13[] = {
       6,    46,     1
};

static const Py_UCS4 lexer_INITIAL_pattern_14[] = {
      12,     8,     1,     8,     4,     3,     0,     0,     1,     1
};

static const Py_UCS4 *lexer_INITIAL_patterns[] = {
  lexer_INITIAL_pattern_0,
  lexer_INITIAL_pattern_1,
  lexer_INITIAL_pattern_2,
  lexer_INITIAL_pattern_3,
  lexer_INITIAL_pattern_4,
  lexer_INITIAL_pattern_5,
  lexer_INITIAL_pattern_6,
  lexer_INITIAL_pattern_7,
  lexer_INITIAL_pattern_8,
  lexer_INITIAL_pattern_9,
  lexer_INITIAL_pattern_10,
  lexer_INITIAL_pattern_11,
  lexer_INITIAL_pattern_12,
  lexer_INITIAL_pattern_13,
  lexer_INITIAL_pattern_14,
  NULL
};

static const Py_UCS4 lexer_OPERATOR_pattern_0[] = {
       6,   111,     6,   114,     1
};

static const Py_UCS4 lexer_OPERATOR_pattern_1[] = {
       6,    97,     6,   110,     6,   100,     1
};

static const Py_UCS4 lexer_OPERATOR_pattern_2[] = {
      11,     4,     6,    42,     1,     8,     6,   109,     6,   111,
       6,   100,     1,     8,     6,   100,     6,   105,     6,   118,
       1,     0,     1
};

static const Py_UCS4 lexer_OPERATOR_pattern_3[] = {
      12,     8,     1,     8,     4,     3,     0,     0,     1,     1
};

static const Py_UCS4 lexer_OPERATOR_pattern_4[] = {
       5,     1
};

static const Py_UCS4 *lexer_OPERATOR_patterns[] = {
  lexer_OPERATOR_pattern_0,
  lexer_OPERATOR_pattern_1,
  lexer_OPERATOR_pattern_2,
  lexer_OPERATOR_pattern_3,
  lexer_OPERATOR_pattern_4,
  NULL
};

static const Py_UCS4 **lexer_patterns[] = {
  NULL,
  lexer_INITIAL_patterns,
  lexer_OPERATOR_patterns
};

static const int lexer_INITIAL_actions[] = {
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19
};

static const int lexer_OPERATOR_actions[] = {
       0,     1,     2,     3,     4
};

static const int *lexer_actions[] = {
  NULL,
  lexer_INITIAL_actions,
  lexer_OPERATOR_actions
};


/* Static Definitions */
#define YYEMPTY -2
#define YYERROR -1
#define YYEOF 0
#define YYINITDEPTH 1000
#define LEXER_INITIAL_BACKTRACKS 20

/* Parsing objects */
typedef struct {
  PyObject_HEAD
  int verbose;
  PyObject *dict;
} parserobject;

typedef struct {
  PyObject *text;
  int last;
  int state;
  Py_UNICODE *end;
  Py_UNICODE *position;

  /* backtracking stack */
  int backtracks;
  Py_UNICODE **positions;
  int allocated;
} lexerobject;

static int parser_yylex(parserobject *, lexerobject *, PyObject **);
static lexerobject *lexer_new(PyObject *);
static void lexer_free(lexerobject *);
static int lexer_save_position(lexerobject *);
static Py_UNICODE *lexer_restore_position(lexerobject *);
static int lexer_charset(parserobject *, Py_UCS4 *, Py_UCS4, int);
static int lexer_match(parserobject *, lexerobject *, Py_UCS4 *);

static char *unicode_escape(Py_UNICODE *, int);
static PyObject *report_error(int yystate, int yytoken, PyObject *lval, lexerobject *lexer);
static void print_reduce(int ruleno);
static void print_state_stack(int *stack, int *end);

/** debugging routines ***********************************************/

/* Attempt to use C99 variable argument macros for improved error detection
 * (just in case).
 */
#ifdef __STDC__ /* C99 conformance macro */
#define TRACE(...) if (self->verbose > 0) PySys_WriteStderr(__VA_ARGS__)
#define REGEX_TRACE(...) if (self->verbose > 1) PySys_WriteStderr(__VA_ARGS__)
#else
#define TRACE if (self->verbose > 0) PySys_WriteStderr
#define REGEX_TRACE if (self->verbose > 1) PySys_WriteStderr
#endif

/* Parser Methods */

static char parse_doc[] = "\
parse(string) -> object\n\
Converts the given string to a parse tree and return the top-most\n\
element of the tree.";

static PyObject* parser_parse(register parserobject *self, PyObject *text)
{
  register int yystate;
  register int yyn;

  PyObject *yylval = NULL;
  PyObject *yyval = NULL;

  int state_stack[YYINITDEPTH];
  int *state_ptr;
  PyObject *value_stack[YYINITDEPTH];
  PyObject **value_ptr;

  int yylen;
  int yychar = YYEMPTY;         /* cause a token to be read */
  int yytoken = 0;

  lexerobject *lexer;

  lexer = lexer_new(text);
  if (lexer == NULL)
    return NULL;

  TRACE("Starting parse\n");

  /* Initialize stack pointers
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized. */
  state_ptr = state_stack - 1;
  value_ptr = value_stack;

  yystate = 0;

  while (1) {
    /* Push a new state, which is found in yystate. */
    /* In all cases, when you get here, the value and location stacks
       have just been pushed.  So pushing a state here evens the stacks. */
    *++state_ptr = yystate;

    TRACE("Entering state %d\n", yystate);

    /* Do appropriate processing given the current state. */
    /* Read a lookahead token if we need one and don't already have one. */

    /* First try to decide what to do without reference to lookahead token. */
    yyn = action_idx[yystate];
    if (yyn == YYFLAG) {
      yyn = default_action[yystate];
      if (yyn == 0) {
        return report_error(yystate, yytoken, yylval, lexer);
      }

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 3: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 15
   * AbsoluteLocationPath: '/'
   */
  yyval = PyObject_CallFunction(absolute_location_path, "O", Py_None);
  if (self->verbose) {
    fprintf(stderr, "--AbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 24
   * AbsoluteLocationPath: '/' RelativeLocationPath
   */
  yyval = PyObject_CallFunction(absolute_location_path, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 41
   * RelativeLocationPath: Step
   */
  yyval = PyObject_CallFunction(relative_location_path, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--RelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 7: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 50
   * RelativeLocationPath: RelativeLocationPath '/' Step
   */
  yyval = PyObject_CallFunction(relative_location_path, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 9: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 68
   * Step: AxisSpecifier NodeTest
   */
  yyval = PyObject_CallFunction(location_step, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 10: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 78
   * Step: AxisSpecifier NodeTest Predicate.list
   */
  value_ptr[3] = PyObject_CallFunction(predicates, "N", value_ptr[3]);
  yyval = PyObject_CallFunction(location_step, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 11: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 90
   * Step: AbbreviatedStep
   */
  yyval = PyObject_CallFunction(abbreviated_step, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 12: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 103
   * Predicate.list: Predicate
   */
  yyval = PyList_New(1);
  Py_INCREF(value_ptr[1]);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Predicate.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 13: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 115
   * Predicate.list: Predicate.list Predicate
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Predicate.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 132
   * AxisSpecifier: AxisName DOUBLE_COLON
   */
  yyval = PyObject_CallFunction(axis_specifier, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--AxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 16: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 160
   * NodeTest: NameTest
   */
  yyval = PyObject_CallFunction(name_test, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 17: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 169
   * NodeTest: NodeType '(' ')'
   */
  yyval = PyObject_CallFunction(node_type, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 18: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 180
   * NodeTest: NodeType '(' Literal ')'
   */
  yyval = PyObject_CallFunction(node_type, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 19: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 196
   * Predicate: '[' PredicateExpr ']'
   */
  yyval = PyObject_CallFunction(predicate, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Predicate(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 21: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 218
   * AbbreviatedAbsoluteLocationPath: DOUBLE_SLASH RelativeLocationPath
   */
  yyval = PyObject_CallFunction(abbreviated_absolute_location_path, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 22: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 232
   * AbbreviatedRelativeLocationPath: RelativeLocationPath DOUBLE_SLASH Step
   */
  yyval = PyObject_CallFunction(abbreviated_relative_location_path, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedRelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 25: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 257
   * AbbreviatedAxisSpecifier: '@'
   */
  yyval = PyObject_CallFunction(axis_specifier, "s", "attribute");
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 26: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 266
   * AbbreviatedAxisSpecifier:
   */
  yyval = PyObject_CallFunction(axis_specifier, "s", "child");
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAxisSpecifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 28: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 286
   * PrimaryExpr: VariableReference
   */
  yyval = PyObject_CallFunction(variable_reference, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 29: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 295
   * PrimaryExpr: '(' Expr ')'
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 30: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 307
   * PrimaryExpr: Literal
   */
  yyval = PyObject_CallFunction(string_literal, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 31: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 316
   * PrimaryExpr: Number
   */
  yyval = PyObject_CallFunction(number_literal, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 33: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 333
   * FunctionCall: FunctionName '(' ')'
   */
  yyval = PyObject_CallFunction(function_call, "O[]", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 34: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 344
   * FunctionCall: FunctionName '(' Argument.list ')'
   */
  yyval = PyObject_CallFunction(function_call, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 35: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 360
   * Argument.list: Argument
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Argument.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 36: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 372
   * Argument.list: Argument.list ',' Argument
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Argument.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 39: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 401
   * UnionExpr: UnionExpr '|' PathExpr
   */
  yyval = PyObject_CallFunction(union_expr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--UnionExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 42: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 422
   * PathExpr: FilterExpr '/' RelativeLocationPath
   */
  yyval = PyObject_CallFunction(path_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 43: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 433
   * PathExpr: FilterExpr DOUBLE_SLASH RelativeLocationPath
   */
  yyval = PyObject_CallFunction(path_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 45: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 452
   * FilterExpr: PrimaryExpr Predicate.list
   */
  value_ptr[2] = PyObject_CallFunction(predicates, "N", value_ptr[2]);
  yyval = PyObject_CallFunction(filter_expr, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--FilterExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 47: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 470
   * OrExpr: OrExpr OR_OP AndExpr
   */
  yyval = PyObject_CallFunction(or_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--OrExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 488
   * AndExpr: AndExpr AND_OP EqualityExpr
   */
  yyval = PyObject_CallFunction(and_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AndExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 51: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 506
   * EqualityExpr: EqualityExpr EQUALITY_OP RelationalExpr
   */
  yyval = PyObject_CallFunction(equality_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--EqualityExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 53: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 524
   * RelationalExpr: RelationalExpr RELATIONAL_OP AdditiveExpr
   */
  yyval = PyObject_CallFunction(relational_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 55: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 542
   * AdditiveExpr: AdditiveExpr '+' MultiplicativeExpr
   */
  yyval = PyObject_CallFunction(additive_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 553
   * AdditiveExpr: AdditiveExpr '-' MultiplicativeExpr
   */
  yyval = PyObject_CallFunction(additive_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 58: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 571
   * MultiplicativeExpr: MultiplicativeExpr MULTIPLICATIVE_OP UnaryExpr
   */
  yyval = PyObject_CallFunction(multiplicative_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 589
   * UnaryExpr: '-' UnionExpr
   */
  yyval = PyObject_CallFunction(unary_expr, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);


      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    } /* if (yyn == YYFLAG) */

    /* Not known => get a lookahead token if don't already have one. */

    /* yychar is either YYEMPTY, YYEOF or a valid token in external form */
    if (yychar == YYEMPTY) {
      TRACE("Reading a token: ");
      yychar = parser_yylex(self, lexer, &yylval);
    }

    /* Convert token to internal form (in yytoken) for indexing tables with */

    if (yychar <= 0) {
      if (yychar == YYERROR) {
        lexer_free(lexer);
        return NULL;
      }
      /* This means end-of-input. */
      yytoken = 0;
      TRACE("Now at end of input.\n");
    } else {
      yytoken = YYTRANSLATE(yychar);
      TRACE("Next token is %d (%s)\n", yychar, token_names[yytoken]);
      yyn += yytoken;
    }
    if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yytoken) {
      /* comes here after end of input */
      yyn = default_action[yystate];
      if (yyn == 0) {
        return report_error(yystate, yytoken, NULL, lexer);
      }

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 3: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 15
   * AbsoluteLocationPath: '/'
   */
  yyval = PyObject_CallFunction(absolute_location_path, "O", Py_None);
  if (self->verbose) {
    fprintf(stderr, "--AbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 24
   * AbsoluteLocationPath: '/' RelativeLocationPath
   */
  yyval = PyObject_CallFunction(absolute_location_path, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 41
   * RelativeLocationPath: Step
   */
  yyval = PyObject_CallFunction(relative_location_path, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--RelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 7: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 50
   * RelativeLocationPath: RelativeLocationPath '/' Step
   */
  yyval = PyObject_CallFunction(relative_location_path, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 9: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 68
   * Step: AxisSpecifier NodeTest
   */
  yyval = PyObject_CallFunction(location_step, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 10: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 78
   * Step: AxisSpecifier NodeTest Predicate.list
   */
  value_ptr[3] = PyObject_CallFunction(predicates, "N", value_ptr[3]);
  yyval = PyObject_CallFunction(location_step, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 11: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 90
   * Step: AbbreviatedStep
   */
  yyval = PyObject_CallFunction(abbreviated_step, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 12: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 103
   * Predicate.list: Predicate
   */
  yyval = PyList_New(1);
  Py_INCREF(value_ptr[1]);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Predicate.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 13: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 115
   * Predicate.list: Predicate.list Predicate
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Predicate.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 132
   * AxisSpecifier: AxisName DOUBLE_COLON
   */
  yyval = PyObject_CallFunction(axis_specifier, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--AxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 16: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 160
   * NodeTest: NameTest
   */
  yyval = PyObject_CallFunction(name_test, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 17: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 169
   * NodeTest: NodeType '(' ')'
   */
  yyval = PyObject_CallFunction(node_type, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 18: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 180
   * NodeTest: NodeType '(' Literal ')'
   */
  yyval = PyObject_CallFunction(node_type, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 19: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 196
   * Predicate: '[' PredicateExpr ']'
   */
  yyval = PyObject_CallFunction(predicate, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Predicate(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 21: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 218
   * AbbreviatedAbsoluteLocationPath: DOUBLE_SLASH RelativeLocationPath
   */
  yyval = PyObject_CallFunction(abbreviated_absolute_location_path, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 22: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 232
   * AbbreviatedRelativeLocationPath: RelativeLocationPath DOUBLE_SLASH Step
   */
  yyval = PyObject_CallFunction(abbreviated_relative_location_path, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedRelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 25: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 257
   * AbbreviatedAxisSpecifier: '@'
   */
  yyval = PyObject_CallFunction(axis_specifier, "s", "attribute");
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 26: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 266
   * AbbreviatedAxisSpecifier:
   */
  yyval = PyObject_CallFunction(axis_specifier, "s", "child");
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAxisSpecifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 28: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 286
   * PrimaryExpr: VariableReference
   */
  yyval = PyObject_CallFunction(variable_reference, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 29: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 295
   * PrimaryExpr: '(' Expr ')'
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 30: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 307
   * PrimaryExpr: Literal
   */
  yyval = PyObject_CallFunction(string_literal, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 31: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 316
   * PrimaryExpr: Number
   */
  yyval = PyObject_CallFunction(number_literal, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 33: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 333
   * FunctionCall: FunctionName '(' ')'
   */
  yyval = PyObject_CallFunction(function_call, "O[]", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 34: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 344
   * FunctionCall: FunctionName '(' Argument.list ')'
   */
  yyval = PyObject_CallFunction(function_call, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 35: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 360
   * Argument.list: Argument
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Argument.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 36: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 372
   * Argument.list: Argument.list ',' Argument
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Argument.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 39: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 401
   * UnionExpr: UnionExpr '|' PathExpr
   */
  yyval = PyObject_CallFunction(union_expr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--UnionExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 42: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 422
   * PathExpr: FilterExpr '/' RelativeLocationPath
   */
  yyval = PyObject_CallFunction(path_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 43: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 433
   * PathExpr: FilterExpr DOUBLE_SLASH RelativeLocationPath
   */
  yyval = PyObject_CallFunction(path_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 45: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 452
   * FilterExpr: PrimaryExpr Predicate.list
   */
  value_ptr[2] = PyObject_CallFunction(predicates, "N", value_ptr[2]);
  yyval = PyObject_CallFunction(filter_expr, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--FilterExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 47: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 470
   * OrExpr: OrExpr OR_OP AndExpr
   */
  yyval = PyObject_CallFunction(or_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--OrExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 488
   * AndExpr: AndExpr AND_OP EqualityExpr
   */
  yyval = PyObject_CallFunction(and_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AndExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 51: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 506
   * EqualityExpr: EqualityExpr EQUALITY_OP RelationalExpr
   */
  yyval = PyObject_CallFunction(equality_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--EqualityExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 53: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 524
   * RelationalExpr: RelationalExpr RELATIONAL_OP AdditiveExpr
   */
  yyval = PyObject_CallFunction(relational_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 55: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 542
   * AdditiveExpr: AdditiveExpr '+' MultiplicativeExpr
   */
  yyval = PyObject_CallFunction(additive_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 553
   * AdditiveExpr: AdditiveExpr '-' MultiplicativeExpr
   */
  yyval = PyObject_CallFunction(additive_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 58: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 571
   * MultiplicativeExpr: MultiplicativeExpr MULTIPLICATIVE_OP UnaryExpr
   */
  yyval = PyObject_CallFunction(multiplicative_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 589
   * UnaryExpr: '-' UnionExpr
   */
  yyval = PyObject_CallFunction(unary_expr, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);

      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    }

    yyn = yytable[yyn];

    /* yyn is what to do for this token type in this state.
       Negative => reduce, -yyn is rule number.
       Positive => shift, yyn is new state.
         New state is final state => don't bother to shift
         just return success.
       0, or max negative number => error. */

    if (yyn > YYFLAG && yyn < 0) {
      yyn = -yyn;

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 3: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 15
   * AbsoluteLocationPath: '/'
   */
  yyval = PyObject_CallFunction(absolute_location_path, "O", Py_None);
  if (self->verbose) {
    fprintf(stderr, "--AbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 24
   * AbsoluteLocationPath: '/' RelativeLocationPath
   */
  yyval = PyObject_CallFunction(absolute_location_path, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 41
   * RelativeLocationPath: Step
   */
  yyval = PyObject_CallFunction(relative_location_path, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--RelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 7: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 50
   * RelativeLocationPath: RelativeLocationPath '/' Step
   */
  yyval = PyObject_CallFunction(relative_location_path, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 9: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 68
   * Step: AxisSpecifier NodeTest
   */
  yyval = PyObject_CallFunction(location_step, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 10: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 78
   * Step: AxisSpecifier NodeTest Predicate.list
   */
  value_ptr[3] = PyObject_CallFunction(predicates, "N", value_ptr[3]);
  yyval = PyObject_CallFunction(location_step, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 11: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 90
   * Step: AbbreviatedStep
   */
  yyval = PyObject_CallFunction(abbreviated_step, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 12: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 103
   * Predicate.list: Predicate
   */
  yyval = PyList_New(1);
  Py_INCREF(value_ptr[1]);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Predicate.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 13: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 115
   * Predicate.list: Predicate.list Predicate
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Predicate.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 132
   * AxisSpecifier: AxisName DOUBLE_COLON
   */
  yyval = PyObject_CallFunction(axis_specifier, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--AxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 16: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 160
   * NodeTest: NameTest
   */
  yyval = PyObject_CallFunction(name_test, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 17: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 169
   * NodeTest: NodeType '(' ')'
   */
  yyval = PyObject_CallFunction(node_type, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 18: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 180
   * NodeTest: NodeType '(' Literal ')'
   */
  yyval = PyObject_CallFunction(node_type, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--NodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 19: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 196
   * Predicate: '[' PredicateExpr ']'
   */
  yyval = PyObject_CallFunction(predicate, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Predicate(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 21: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 218
   * AbbreviatedAbsoluteLocationPath: DOUBLE_SLASH RelativeLocationPath
   */
  yyval = PyObject_CallFunction(abbreviated_absolute_location_path, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 22: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 232
   * AbbreviatedRelativeLocationPath: RelativeLocationPath DOUBLE_SLASH Step
   */
  yyval = PyObject_CallFunction(abbreviated_relative_location_path, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedRelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 25: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 257
   * AbbreviatedAxisSpecifier: '@'
   */
  yyval = PyObject_CallFunction(axis_specifier, "s", "attribute");
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 26: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 266
   * AbbreviatedAxisSpecifier:
   */
  yyval = PyObject_CallFunction(axis_specifier, "s", "child");
  if (self->verbose) {
    fprintf(stderr, "--AbbreviatedAxisSpecifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 28: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 286
   * PrimaryExpr: VariableReference
   */
  yyval = PyObject_CallFunction(variable_reference, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 29: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 295
   * PrimaryExpr: '(' Expr ')'
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 30: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 307
   * PrimaryExpr: Literal
   */
  yyval = PyObject_CallFunction(string_literal, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 31: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 316
   * PrimaryExpr: Number
   */
  yyval = PyObject_CallFunction(number_literal, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrimaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 33: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 333
   * FunctionCall: FunctionName '(' ')'
   */
  yyval = PyObject_CallFunction(function_call, "O[]", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 34: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 344
   * FunctionCall: FunctionName '(' Argument.list ')'
   */
  yyval = PyObject_CallFunction(function_call, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 35: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 360
   * Argument.list: Argument
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Argument.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 36: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 372
   * Argument.list: Argument.list ',' Argument
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Argument.list(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 39: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 401
   * UnionExpr: UnionExpr '|' PathExpr
   */
  yyval = PyObject_CallFunction(union_expr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--UnionExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 42: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 422
   * PathExpr: FilterExpr '/' RelativeLocationPath
   */
  yyval = PyObject_CallFunction(path_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 43: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 433
   * PathExpr: FilterExpr DOUBLE_SLASH RelativeLocationPath
   */
  yyval = PyObject_CallFunction(path_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 45: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 452
   * FilterExpr: PrimaryExpr Predicate.list
   */
  value_ptr[2] = PyObject_CallFunction(predicates, "N", value_ptr[2]);
  yyval = PyObject_CallFunction(filter_expr, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--FilterExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 47: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 470
   * OrExpr: OrExpr OR_OP AndExpr
   */
  yyval = PyObject_CallFunction(or_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--OrExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 488
   * AndExpr: AndExpr AND_OP EqualityExpr
   */
  yyval = PyObject_CallFunction(and_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AndExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 51: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 506
   * EqualityExpr: EqualityExpr EQUALITY_OP RelationalExpr
   */
  yyval = PyObject_CallFunction(equality_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--EqualityExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 53: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 524
   * RelationalExpr: RelationalExpr RELATIONAL_OP AdditiveExpr
   */
  yyval = PyObject_CallFunction(relational_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 55: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 542
   * AdditiveExpr: AdditiveExpr '+' MultiplicativeExpr
   */
  yyval = PyObject_CallFunction(additive_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 553
   * AdditiveExpr: AdditiveExpr '-' MultiplicativeExpr
   */
  yyval = PyObject_CallFunction(additive_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 58: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 571
   * MultiplicativeExpr: MultiplicativeExpr MULTIPLICATIVE_OP UnaryExpr
   */
  yyval = PyObject_CallFunction(multiplicative_expr, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from amara/xpath/parser/xpath_grammar.bgen.frag, line 589
   * UnaryExpr: '-' UnionExpr
   */
  yyval = PyObject_CallFunction(unary_expr, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);

      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    } else if (yyn == YYFINAL) {
      /* Hooray!  Process complete. */
      lexer_free(lexer);
      return value_ptr[-1];
    } else if (yyn <= 0) {
      /* Now it is either 0 or YYFLAG */
      return report_error(yystate, yytoken, yylval, lexer);
    }

    /* Shift the lookahead token. */

    TRACE("Shifting token %d (%s), ", yychar, token_names[yytoken]);

    if (yychar != YYEOF) {
      yychar = YYEMPTY;
    }

    *++value_ptr = yylval;

    yystate = yyn;
    continue;
  }

  /* should never get here */
  Py_INCREF(Py_None);
  lexer_free(lexer);
  return Py_None;
}

/** lexer routines ****************************************************/

static lexerobject *lexer_new(PyObject *text)
{
  lexerobject *lexer;

  lexer = PyMem_New(lexerobject, 1);
  if (lexer == NULL) {
    PyErr_NoMemory();
    return NULL;
  }

  /* attempt to coerce given object to unicode using default rules */
  lexer->text = PyUnicode_FromObject(text);
  if (lexer->text == NULL) {
    PyMem_Free(lexer);
    return NULL;
  }
  lexer->position = PyUnicode_AS_UNICODE(lexer->text);
  lexer->end = lexer->position + PyUnicode_GET_SIZE(lexer->text);
  lexer->state = LEXER_START_STATE;

  /* create initial backtracking stack */
  lexer->positions = PyMem_New(Py_UNICODE *, LEXER_INITIAL_BACKTRACKS);
  if (lexer->positions == NULL) {
    PyErr_NoMemory();
    Py_DECREF(lexer->text);
    PyMem_Free(lexer);
    return NULL;
  }
  lexer->allocated = LEXER_INITIAL_BACKTRACKS;
  lexer->backtracks = 0;
  return lexer;
}

static void lexer_free(lexerobject *lexer)
{
  PyMem_Free(lexer->positions);
  Py_DECREF(lexer->text);
  PyMem_Free(lexer);
}

static int lexer_save_position(lexerobject *lexer) {
  Py_UNICODE **positions;
  size_t new_allocated;
  int allocated, newsize;

  /* Bypass realloc() when a previous overallocation is large enough
     to accommodate the newsize.
  */
  newsize = lexer->backtracks + 1;
  allocated = lexer->allocated;
  positions = lexer->positions;
  if (newsize >= allocated) {
    /* This over-allocates proportional to the list size, making room
     * for additional growth.  The over-allocation is mild, but is
     * enough to give linear-time amortized behavior over a long
     * sequence of appends() in the presence of a poorly-performing
     * system realloc().
     * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
     */
    new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6) + newsize;
    if (PyMem_Resize(positions, Py_UNICODE *, new_allocated) == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    lexer->allocated = new_allocated;
    lexer->positions = positions;
  }
  lexer->positions[lexer->backtracks] = lexer->position;
  lexer->backtracks = newsize;
  return 0;
}

static Py_UNICODE *lexer_restore_position(lexerobject *lexer) {
  assert(lexer->backtracks > 0);
  lexer->position = lexer->positions[--lexer->backtracks];
  return lexer->position;
}

static int lexer_charset(parserobject *self, Py_UCS4 *set, Py_UCS4 ch,
                         int ok)
{
  unsigned char *charset;

  /* check if character is a member of the given set */
  /* Note, the tests are stored sorted to allow for quick exits */

  for (;;) {
    switch (*set++) {

    case LEXER_CHARSET_LITERAL:
      /* <LITERAL> <code> */
      REGEX_TRACE("CHARSET_LITERAL, %d == %d\n", ch, set[0]);
      if (ch < set[0])
        return !ok;
      else if ((Py_UCS4)ch == set[0])
        return ok;
      set++;
      break;

    case LEXER_CHARSET_RANGE:
      /* <RANGE> <lower> <upper> */
      REGEX_TRACE("CHARSET_RANGE, %d <= %d <= %d\n", set[0], ch, set[1]);
      if (ch < set[0])
        return !ok;
      else if (ch <= set[1])
        return ok;
      set += 2;
      break;

    case LEXER_CHARSET_SMALL:
      /* <SMALL> <charset index> */
      REGEX_TRACE("CHARSET_SMALL, index=%d\n", set[0]);
      charset = lexer_charsets[*set++];
      if (ch < 256 && (charset[ch >> 3] & (1 << (ch & 7))))
        return ok;
      break;

    case LEXER_CHARSET_BIG:
      /* <BIG> <blockmap index> */
      REGEX_TRACE("CHARSET_BIG, index=%d\n", set[0]);
      charset = lexer_charsets[lexer_blockmaps[*set++][ch >> 8]];
      if (ch < 65536 && charset[(ch & 255) >> 3] & (1 << (ch & 7)))
        return ok;
      break;

    case LEXER_CHARSET_FAILURE:
      /* nothing matched in charset */
      REGEX_TRACE("CHARSET_FAILURE\n");
      return !ok;

    default:
      REGEX_TRACE("**INTERNAL CHARSET ERROR**\n");
      return -1;
    }
  }
}

/* return values:
   1 -> sucessful match,
   0 -> no match,
   -1 -> error,
*/

#ifdef Py_UNICODE_WIDE
#define GET_CHAR_AND_ADVANCE() ch = *ptr++;
#else
#define GET_CHAR_AND_ADVANCE()                                          \
  if ((0xD800 <= ptr[0] && ptr[0] <= 0xDBFF) &&                         \
      (0xDC00 <= ptr[1] && ptr[1] <= 0xDFFF)) {                         \
    ch = (((ptr[0] & 0x03FF) << 10) | (ptr[1] & 0x03FF)) + 0x00010000;  \
    ptr += 2;                                                           \
  } else {                                                              \
    ch = *ptr++;                                                        \
  }
#endif

static int lexer_match(parserobject *self, lexerobject *lexer,
                       Py_UCS4 *pattern)
{
  Py_UNICODE *ptr = lexer->position;
  Py_UNICODE *end;
  Py_UCS4 ch;
  int i, count;

  REGEX_TRACE("LEXER_MATCH, position %" YY_FORMAT_PTRDIFF_T "d\n",
              (YY_PTRDIFF_T)(lexer->position -
                             PyUnicode_AS_UNICODE(lexer->text)));

  while (1) {
    switch (*pattern++) {

    case LEXER_OP_FAILURE:
      /* immediate failure */
      REGEX_TRACE("OP_FAILURE\n");
      return 0;

    case LEXER_OP_SUCCESS:
      /* end of pattern */
      REGEX_TRACE("OP_SUCCESS\n");
      lexer->position = ptr;
      return 1;

    case LEXER_OP_BOL:
      /* beginning of line */
      /* <BOL> */
      REGEX_TRACE("OP_BOL\n");
      if (ptr == PyUnicode_AS_UNICODE(lexer->text) || ptr[-1] == '\n')
        break;
      return 0;

    case LEXER_OP_EOL:
      /* end of line */
      /* <EOL> */
      REGEX_TRACE("OP_EOL\n");
      if (ptr >= lexer->end || ptr[0] == '\n') break;
      return 0;

    case LEXER_OP_EOF:
      /* end of file */
      /* <EOF> */
      REGEX_TRACE("OP_EOF\n");
      if (ptr >= lexer->end) break;
      return 0;

    case LEXER_OP_ANY:
      /* match anything (except a newline) */
      /* <ANY> */
      REGEX_TRACE("OP_ANY\n");
      if (ptr >= lexer->end || ptr[0] == '\n')
        return 0;
      ptr++;
      break;

    case LEXER_OP_LITERAL:
      /* match literal character */
      /* <LITERAL> <code> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_LITERAL, %d == %d\n", ch, pattern[0]);
      if (ch != pattern[0])
        return 0;
      pattern++;
      break;

    case LEXER_OP_NOT_LITERAL:
      /* match anything that is not literal character */
      /* <NOT_LITERAL> <code> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_NOT_LITERAL, %d != %d\n", ch, pattern[0]);
      if (ch == pattern[0])
        return 0;
      pattern++;
      break;

    case LEXER_OP_CHARSET:
      /* match set member */
      /* <CHARSET> <skip> <set> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_CHARSET, skip %d\n", pattern[0]);
      i = lexer_charset(self, pattern + 1, ch, 1);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;

    case LEXER_OP_NOT_CHARSET:
      /* match set non-member */
      /* <NOT_CHARSET> <skip> <set> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_NOT_CHARSET, skip %d\n", pattern[0]);
      i = lexer_charset(self, pattern + 1, ch, 0);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;

    case LEXER_OP_ASSERT:
      /* lookahead assertion */
      /* <ASSERT> <skip> <pattern> */
      REGEX_TRACE("OP_ASSERT, skip %d\n", pattern[0]);
      lexer->position = ptr;
      i = lexer_match(self, lexer, pattern + 1);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;

    case LEXER_OP_BRANCH:
      /* alternation */
      /* <BRANCH> <skip0> <code0> <skip1> <code1> ... <NULL> */

      end = NULL;
      count = 0;
      while (pattern[0]) {
        /* reset start position each time through */
        REGEX_TRACE("OP_BRANCH %d, skip %d\n", count++, pattern[0]);
        lexer->position = ptr;

        i = lexer_match(self, lexer, pattern + 1);
        if (i < 0)
          return i;
        else if (i && lexer->position > end)
          /* successful match which is longer than the current best matched */
          end = lexer->position;

        /* advance to the next pattern */
        pattern += pattern[0];
      }

      /* advance pattern past NULL */
      pattern++;

      /* advance to the best matching position if there was a match */
      if (end) {
        lexer->position = ptr = end;
        break;
      }

      return 0;

    case LEXER_OP_REPEAT:
      /* repetition */
      /* <REPEAT> <skip> <1=min> item */
      {
        Py_UCS4 *item = pattern + 2;
        Py_UCS4 *next = pattern + pattern[0];
        int minimum = pattern[1];
        int backtracks;

        lexer->position = ptr;
        for (count = 0, i = 1; i == 1 && count < minimum; count++) {
          REGEX_TRACE("OP_REPEAT<stage 1>, min %d, now %d\n",
                      minimum, count);
          i = lexer_match(self, lexer, item);
        }

        /* either internal error or failed minimum matches */
        if (i <= 0)
          return i;

        backtracks = lexer->backtracks;

        /* match as many items as possible */
        for (; i == 1; count++) {
          REGEX_TRACE("OP_REPEAT<stage 2>, now %d\n", count);
          if (lexer_save_position(lexer) < 0)
            return -1;
          i = lexer_match(self, lexer, item);
        }

        if (i < 0) {
          /* internal error */
          lexer->backtracks = backtracks;
          return i;
        }

        /* backtracking assert of tail match until success */
        do {
          REGEX_TRACE("OP_REPEAT<stage 3>, now %d\n", count);
          /* update position to previous successful match */
          ptr = lexer_restore_position(lexer);
          if (ptr == NULL)
            return -1;
          i = lexer_match(self, lexer, next);
        } while (i == 0 && --count > minimum);

        /* discard remaining backtrack positions */
        lexer->backtracks = backtracks;

        if (i <= 0) {
          return i;
        }
        pattern = next;
      }
      break;

    case LEXER_OP_REPEAT_RANGE:
      /* repetition */
      /* <REPEAT_RANGE> <skip> <1=min> <2=max> item */
      {
        Py_UCS4 *item = pattern + 3;
        Py_UCS4 *next = pattern + pattern[0];
        int minimum = pattern[1];
        int maximum = pattern[2];
        int backtracks;

        lexer->position = ptr;
        for (count = 0, i = 1; i == 1 && count < minimum; count++) {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 1>, min %d, now %d\n",
                      minimum, count);
          i = lexer_match(self, lexer, item);
        }

        /* either internal error or failed minimum matches */
        if (i <= 0)
          return i;

        backtracks = lexer->backtracks;

        /* consume up to 'maximum' matches */
        for (; i == 1 && count < maximum; count++) {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 2>, max %d, now %d\n",
                      maximum, count);
          if (lexer_save_position(lexer) < 0)
            return -1;
          i = lexer_match(self, lexer, item);
        }

        if (i < 0) {
          /* internal error */
          lexer->backtracks = backtracks;
          return i;
        }

        /* maximum matches reached, update saved position */
        if (i == 1)
          ptr = lexer->position;

        /* backtracking assert of tail match until success */
        do {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 3>, now %d\n", count);
          if (i == 0) {
            /* update position to last successful match */
            ptr = lexer_restore_position(lexer);
            if (ptr == NULL)
              return -1;
          }
          i = lexer_match(self, lexer, next);
        } while (i == 0 && --count > minimum);

        /* discard remaining backtrack positions */
        lexer->backtracks = backtracks;

        if (i <= 0)
          return i;

        pattern = next;
      }
      break;

    default:
      REGEX_TRACE("**INTERNAL MATCH ERROR**\n");
      return -1;
    }
  }
}

static int parser_yylex(parserobject *self, lexerobject *lexer,
                        PyObject **yyvalue)
{
  Py_UNICODE *yypos = lexer->position;

  while (yypos < lexer->end) {
    Py_UNICODE *yyend = NULL;
    int yyaccept = -1;
    int yyi;
    Py_UCS4 **yypatterns = (Py_UCS4 **)lexer_patterns[lexer->state];
    const int *yyactions = lexer_actions[lexer->state];

    REGEX_TRACE("Using patterns from lexer state %d\n", lexer->state);
    for (yyi = 0; yypatterns[yyi]; yyi++) {
      int yymatched;
      /* reset position each time through */
      lexer->position = yypos;

      REGEX_TRACE("--- pattern %d...\n", yyi);
      yymatched = lexer_match(self, lexer, yypatterns[yyi]);

      if (yymatched > 0 && lexer->position > yyend) {
        /* successful match which is longer than the current best matched */
        yyend = lexer->position;
        yyaccept = yyi;
      } else if (yymatched < 0) {
        /* internal error */
        REGEX_TRACE("--- pattern %d internal error\n", yyi);
        PyErr_SetString(PyExc_RuntimeError,
                        "internal error in regular expression engine");
        return YYERROR;
      }
      REGEX_TRACE("--- pattern %d %s\n", yyi, 
                  yymatched ? "success" : "failed");
    }

    if (yyaccept < 0) {
      /* default rule (matches '.') */
      TRACE("accepting default rule, returning '%c'\n", (int)(*yypos));
      lexer->position++;
      *yyvalue = PyUnicode_FromUnicode(yypos, 1);
      if (*yyvalue == NULL) return YYERROR;
      return (int)(*yypos);
    }
    /* get the action block for this match */
    switch (yyactions[yyaccept]) {
case 0: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 8 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:8, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition INITIAL, ");
    TRACE("returning OR_OP\n");
  }
  /* change the start condition */
  lexer->state = LEXER_INITIAL;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return OR_OP;
  break;
}
case 1: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 13 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:13, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition INITIAL, ");
    TRACE("returning AND_OP\n");
  }
  /* change the start condition */
  lexer->state = LEXER_INITIAL;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return AND_OP;
  break;
}
case 2: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 18 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:18, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition INITIAL, ");
    TRACE("returning MULTIPLICATIVE_OP\n");
  }
  /* change the start condition */
  lexer->state = LEXER_INITIAL;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return MULTIPLICATIVE_OP;
  break;
}
case 3: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 24 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:24, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("discarding, ");
  }
  /* discard whatever was matched */
  yypos = yyend;
  break;
}
case 4: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 26 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:26, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition INITIAL, ");
    TRACE("scannar backing up, ");
  }
  /* change the start condition */
  lexer->state = LEXER_INITIAL;
  break;
}
case 5: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 31 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:31, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition OPERATOR, ");
    TRACE("returning '%c'\n", (int)(*yypos));
  }
  /* change the start condition */
  lexer->state = LEXER_OPERATOR;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return (int)(*yypos);
  break;
}
case 6: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 36 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:36, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("returning DOUBLE_COLON\n");
  }
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return DOUBLE_COLON;
  break;
}
case 7: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 40 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:40, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("returning DOUBLE_SLASH\n");
  }
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return DOUBLE_SLASH;
  break;
}
case 8: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 44 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:44, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("returning EQUALITY_OP\n");
  }
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return EQUALITY_OP;
  break;
}
case 9: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 48 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:48, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("returning RELATIONAL_OP\n");
  }
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return RELATIONAL_OP;
  break;
}
case 10: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 53 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:53, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("returning NodeType\n");
  }
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return NodeType;
  break;
}
case 11: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 58 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:58, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("returning AxisName\n");
  }
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return AxisName;
  break;
}
case 12: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 63 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:63, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition OPERATOR, ");
    TRACE("returning Literal\n");
  }
  /* change the start condition */
  lexer->state = LEXER_OPERATOR;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return Literal;
  break;
}
case 13: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 68 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:68, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition OPERATOR, ");
    TRACE("returning Number\n");
  }
  /* change the start condition */
  lexer->state = LEXER_OPERATOR;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return Number;
  break;
}
case 14: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 73 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:73, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition OPERATOR, ");
    TRACE("returning VariableReference\n");
  }
  /* change the start condition */
  lexer->state = LEXER_OPERATOR;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return VariableReference;
  break;
}
case 15: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 78 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:78, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("returning FunctionName\n");
  }
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return FunctionName;
  break;
}
case 16: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 82 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:82, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition OPERATOR, ");
    TRACE("returning NameTest\n");
  }
  /* change the start condition */
  lexer->state = LEXER_OPERATOR;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return NameTest;
  break;
}
case 17: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 87 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:87, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition OPERATOR, ");
    TRACE("returning DOUBLE_DOT\n");
  }
  /* change the start condition */
  lexer->state = LEXER_OPERATOR;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return DOUBLE_DOT;
  break;
}
case 18: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 93 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:93, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("switching to start condition OPERATOR, ");
    TRACE("returning '%c'\n", (int)(*yypos));
  }
  /* change the start condition */
  lexer->state = LEXER_OPERATOR;
  /* create the value object for the matched text */
  *yyvalue = PyUnicode_FromUnicode(yypos, (yyend - yypos));
  if (*yyvalue == NULL) return YYERROR;
  /* update stored position */
  lexer->position = yyend;
  return (int)(*yypos);
  break;
}
case 19: {
  /* from amara/xpath/parser/xpath_lexer_patterns.bgen.frag, line 99 */
  if (self->verbose) {
    char *repr = unicode_escape(yypos, (yyend - yypos));
    TRACE("accepting rule at amara/xpath/parser/xpath_lexer_patterns.bgen.frag:99, matched ");
    TRACE("'%s', ", repr);
    PyMem_Del(repr);
    TRACE("discarding, ");
  }
  /* discard whatever was matched */
  yypos = yyend;
  break;
}
    }
  }
  /* Reached end of input */
  return YYEOF;
}

/** Type Object *******************************************************/

static int parser_traverse(parserobject *self, visitproc visit, void *arg)
{
  int rv;

  if (self->dict) {
    rv = visit(self->dict, arg);
    if (rv != 0) return rv;
  }
  return 0;
}

static int parser_clear(parserobject *self)
{
  PyObject *tmp;

  if (self->dict) {
    tmp = self->dict;
    self->dict = NULL;
    Py_DECREF(tmp);
  }
  return 0;
}

static void parser_dealloc(parserobject *self)
{
  parser_clear(self);
  self->ob_type->tp_free((PyObject *) self);
}

static int parser_init(parserobject *self, PyObject *args, PyObject *kwds)
{
  PyObject *debug=NULL;
  static char *kwlist[] = { "debug", NULL };

  if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:" PARSER_NAME, kwlist,
                                   &debug))
    return -1;

  if (debug) {
    self->verbose = PyObject_IsTrue(debug);
  }

  return 0;
}

static PyObject *parser_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  parserobject *self;

  self = (parserobject *) type->tp_alloc(type, 0);
  if (self != NULL) {
    self->dict = PyDict_New();
    if (self->dict == NULL) {
      Py_DECREF(self);
      return NULL;
    }
    self->verbose = 0;
  }
  return (PyObject *) self;
}

static PyMethodDef parser_methods[] = {
  { "parse", (PyCFunction) parser_parse, METH_O, parse_doc },
  { NULL, NULL }
};

static PyMemberDef parser_members[] = {
  { "debug", T_INT, offsetof(parserobject, verbose) },
  { NULL }
};

static char parser_doc[] = PARSER_NAME "\
([debug]) -> parser\n\
Create a new parser object.\n\
\n\
The optional debug argument, when true, enables the builtin trace facility.\n\
The trace facility uses stderr to display each step taken by the parser.";

static PyTypeObject Parser_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ MODULE_NAME "." "parser",
  /* tp_basicsize      */ sizeof(parserobject),
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) parser_dealloc,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) 0,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ (Py_TPFLAGS_DEFAULT | 
                           Py_TPFLAGS_BASETYPE |
                           Py_TPFLAGS_HAVE_GC |
                           0),
  /* tp_doc            */ (char *) parser_doc,
  /* tp_traverse       */ (traverseproc) parser_traverse,
  /* tp_clear          */ (inquiry) parser_clear,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) parser_methods,
  /* tp_members        */ (PyMemberDef *) parser_members,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ offsetof(parserobject, dict),
  /* tp_init           */ (initproc) parser_init,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) parser_new,
  /* tp_free           */ 0,
};

/* Helper functions */

/* caller is responsible for releasing the memory */
static char *unicode_escape(Py_UNICODE *s, int len)
{
  static const char *hexdigit = "0123456789ABCDEF";
  char *repr, *p;
  int i, size;

  /* Do one pass to get the repr'ed size */
  size = 1;  /* zero terminator */
  for (i = 0; i < len; i++) {
#ifdef Py_UNICODE_WIDE
    if (s[i] >= 65536) size += 10;  /* \UHHHHHHHH */
    else
#endif
    if (s[i] >= 256) size += 6;  /* \uHHHH */
    else if (s[i] == 9 || s[i] == 10 || s[i] == 13) size += 2;  /* \t \n \r */
    else if (s[i] < 32 || s[i] >= 128) size += 4;  /* \xHH */
    else size++; /* printable US-ASCII */
  }

  repr = p = PyMem_New(char, size + 1);
  if (repr == NULL) return NULL;

  while (len-- > 0) {
    Py_UNICODE ch = *s++;
#ifdef Py_UNICODE_WIDE
    /* Map 32-bit characters to '\Uxxxxxxxx' */
    if (ch >= 65536) {
      *p++ = '\\';
      *p++ = 'U';
      *p++ = hexdigit[(ch >> 28) & 0xf];
      *p++ = hexdigit[(ch >> 24) & 0xf];
      *p++ = hexdigit[(ch >> 20) & 0xf];
      *p++ = hexdigit[(ch >> 16) & 0xf];
      *p++ = hexdigit[(ch >> 12) & 0xf];
      *p++ = hexdigit[(ch >> 8) & 0xf];
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Map 16-bit characters to '\uxxxx' */
    else
#endif
    if (ch >= 256) {
      *p++ = '\\';
      *p++ = 'u';
      *p++ = hexdigit[(ch >> 12) & 0xf];
      *p++ = hexdigit[(ch >> 8) & 0xf];
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Map special whitespace to '\t', \n', '\r' */
    else if (ch == 9) {
      *p++ = '\\';
      *p++ = 't';
    }
    else if (ch == 10) {
      *p++ = '\\';
      *p++ = 'n';
    }
    else if (ch == 13) {
      *p++ = '\\';
      *p++ = 'r';
    }
    /* Map non-printable US ASCII to '\xhh' */
    else if (ch < 32 || ch >= 128) {
      *p++ = '\\';
      *p++ = 'x';
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Copy everything else as-is */
    else
      *p++ = (char) ch;
  }

  *p = '\0';

  return repr;
}

static void calculate_position(lexerobject *lexer, int *line, int *column) {
  /* Determine line and column numbers */
  Py_UNICODE *p;

  *line = 1;
  *column = 1;

  for (p = PyUnicode_AS_UNICODE(lexer->text); p < lexer->end; p++) {
    if ((char)*p == '\n') {
      *line += 1;
      *column = 1;
    } else {
      *column += 1;
    }
  }
}

#define YYNTOKENS (sizeof(token_names) / sizeof(char *))

static PyObject *report_error(int yystate, int yytoken, PyObject* lval, 
                              lexerobject *lexer) 
{
  size_t yysize;
  int yyx, yyn;
  int yyline, yycolumn;
  char *yyvalue, *yymsg;
  PyObject *yyerror;

  if (lval) {
    yyvalue = unicode_escape(PyUnicode_AS_UNICODE(lval),
                             PyUnicode_GET_SIZE(lval));
    if (yyvalue == NULL) return NULL;
  } else {
    yyvalue = NULL;
  }

  calculate_position(lexer, &yyline, &yycolumn);
  Py_DECREF(lexer->text);

  yysize = 0;
  yyn = action_idx[yystate];
  if (YYFLAG < yyn && yyn < YYLAST) {
    /* Ensure `yyx` is positive to avoid negative indexing. */
    for (yyx = (yyn < 0 ? -yyn : 0); yyx < YYNTOKENS; yyx++) {
      if (yycheck[yyx + yyn] == yyx) {
        /* add the length of the token label and the joining " or " */
        yysize += strlen(token_names[yyx]) + 4;
      }
    }
    if (yysize > 0) {
      /* make room for ", expecting " */
      yysize += sizeof(", expecting ");
    } else {
      /* indicate no additional labels */
      yyn = YYFLAG;
    }
  }
  /* sizeof() includes the null-terminator. */
  yysize += sizeof("unexpected ") + strlen(token_names[yytoken]);

  yymsg = PyMem_New(char, yysize);
  if (yymsg == NULL) {
    PyErr_NoMemory();
    goto finally;
  } else {
    strcpy(yymsg, "unexpected ");
    strcat(yymsg, token_names[yytoken]);
    if (yyvalue) {
      strcat(yymsg, " (");
      strcat(yymsg, yyvalue);
      strcat(yymsg, ")");
    }
    if (YYFLAG < yyn && yyn < YYLAST) {
      /* at least one token label will be added (guarenteed by above ) */
      strcat(yymsg, ", expecting ");
      /* Ensure `yyx` is positive to avoid negative indexing. */
      for (yysize = 0, yyx = (yyn < 0 ? -yyn : 0); yyx < YYNTOKENS; yyx++) {
        if (yycheck[yyx + yyn] == yyx) {
          /* add the token label and the joining " or " */
          if (yysize)
            strcat(yymsg, " or ");
          else
            yysize++;
          strcat(yymsg, token_names[yyx]);
        }
      }
    }
    yyerror = Py_BuildValue("s(OllO)", 
                            yymsg,              /* error string */
                            Py_None,            /* filename */
                            yyline, yycolumn,   /* position */
                            Py_None);           /* source line text */
    if (yyerror != NULL) {
      PyErr_SetObject(YY_ErrorObject, yyerror);
      Py_DECREF(yyerror);
    }
    PyMem_Del(yymsg);
  }
finally:
  if (yyvalue) {
    PyMem_Del(yyvalue);
  }
  return NULL;
}

static void print_reduce(int ruleno) {
  int count;
  const int *token;

  PySys_WriteStderr("Reducing via rule %d (%s), ", ruleno, rule_info[ruleno]);
  /* print the symbols being reduced and their result. */

  count = ruleno;
  token = rhs_tokens;
  while (--count) while (*++token);

  while (*++token) {
    PySys_WriteStderr("%s ", token_names[*token]);
  }
  PySys_WriteStderr("-> %s\n", token_names[derives[ruleno]]);
}

static void print_state_stack(int *stack, int *end) {
  int *curr = stack;

  PySys_WriteStderr("state stack now");
  while (curr <= end) {
    PySys_WriteStderr(" %d", *curr++);
  }
  PySys_WriteStderr("\n");
}

/** Error Type *******************************************************/

#if PY_VERSION_HEX < 0x02050000 /* YY_Error_str is a class method */
static PyObject *YY_Error_str(PyObject *yyerror, PyObject *yyarg)
#else /* YY_Error_str is a tp_str slot method */
static PyObject *YY_Error_str(PyObject *yyerror)
#endif
{
  PyObject *yymsg, *yylineno, *yyoffset, *yyresult;
  int yy_have_lineno = 0;
  int yy_have_offset = 0;
  if ((yymsg = PyObject_GetAttrString(yyerror, "msg")) == NULL)
    return NULL;

  yyresult = PyObject_Str(yymsg);
  Py_DECREF(yymsg);
  if (yyresult == NULL || !PyString_Check(yyresult))
    return yyresult;

  if ((yylineno = PyObject_GetAttrString(yyerror, "lineno")) == NULL)
    PyErr_Clear();
  else
    yy_have_lineno = PyInt_Check(yylineno);

  if ((yyoffset = PyObject_GetAttrString(yyerror, "offset")) == NULL)
    PyErr_Clear();
  else
    yy_have_offset = PyInt_Check(yyoffset);

  if (yy_have_lineno) {
    size_t yysize = PyString_GET_SIZE(yymsg) + 64;
    char *yybuffer = PyMem_Malloc(yysize);
    if (yybuffer) {
      if (yy_have_offset)
        PyOS_snprintf(yybuffer, yysize,
                      "syntax error at line %ld, column %ld: %s",
                      PyInt_AsLong(yylineno), PyInt_AsLong(yyoffset),
                      PyString_AsString(yyresult));
      else
        PyOS_snprintf(yybuffer, yysize,
                      "syntax error at line %ld: %s",
                      PyInt_AsLong(yylineno), PyString_AsString(yyresult));
      yymsg = PyString_FromString(yybuffer);
      PyMem_Free(yybuffer);
      if (yymsg) {
        Py_DECREF(yyresult);
        yyresult = yymsg;
      } else {
        PyErr_Clear();
      }
    }
  }
  Py_XDECREF(yylineno);
  Py_XDECREF(yyoffset);
  return yyresult;
}

#if PY_VERSION_HEX < 0x02050000 /* YY_ErrorObject must be an old-style class */
static int YY_Error_Ready(void)
{
  static PyMethodDef yyml = { "__str__", YY_Error_str, METH_O };
  PyObject *yydict, *yyfunc;

  yydict = PyDict_New();
  if (yydict == NULL)
    return -1;
  /* get the function object */
  yyfunc = PyCFunction_New(&yyml, NULL);
  if (yyfunc == NULL) {
    Py_DECREF(yydict);
    return -1;
  }
  /* add the function to the namespace dictionary */
  if (PyDict_SetItemString(yydict, yyml.ml_name, yyfunc) < 0) {
    Py_DECREF(yyfunc);
    Py_DECREF(yydict);
    return -1;
  }
  Py_DECREF(yyfunc);

  YY_ErrorObject = PyErr_NewException(MODULE_NAME ".error",
                                      PyExc_SyntaxError, yydict);
  Py_DECREF(yydict);
  if (YY_ErrorObject == NULL)
    return -1;

  return 0;
}
#else /* YY_ErrorObject can be a new-style class */
static PyTypeObject YY_Error_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ MODULE_NAME ".error",
  /* tp_basicsize      */ 0,
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) 0,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) YY_Error_str,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ Py_TPFLAGS_DEFAULT,
  /* tp_doc            */ (char *) 0,
  /* tp_traverse       */ (traverseproc) 0,
  /* tp_clear          */ (inquiry) 0,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) 0,
  /* tp_members        */ (PyMemberDef *) 0,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ 0,
  /* tp_init           */ (initproc) 0,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) 0,
  /* tp_free           */ 0,
};

static int YY_Error_Ready(void)
{
  YY_ErrorObject = (PyObject *)&YY_Error_Type;
  YY_Error_Type.tp_base = (PyTypeObject *)PyExc_SyntaxError;
  return PyType_Ready(&YY_Error_Type);
}
#endif

/** Interactive parser ************************************************/

#define CONSOLE_NAME PARSER_NAME "Console"

typedef struct {
  PyObject_HEAD
  parserobject *parser;
  PyObject *dict;
} consoleobject;

static PyObject *console_new(PyTypeObject *type, PyObject *args,
                             PyObject *kwds)
{
  consoleobject *self;

  self = (consoleobject *) type->tp_alloc(type, 0);
  if (self != NULL) {
    PyObject *args = Py_BuildValue("(i)", 1);
    if (args == NULL) {
      Py_DECREF(self);
      return NULL;
    }
    self->parser = (parserobject *) parser_new(&Parser_Type, args, NULL);
    Py_DECREF(args);
    if (self->parser == NULL) {
      Py_DECREF(self);
      return NULL;
    }
  }
  return (PyObject *) self;
}

static int console_init(consoleobject *self, PyObject *args, PyObject *kwds)
{
  PyObject *bases, *base, *result;
  int size, i;

  if (!PyArg_ParseTuple(args, ":" CONSOLE_NAME)) return -1;

  bases = self->ob_type->tp_bases;
  size = PyTuple_GET_SIZE(bases);
  for (i = 0; i < size; i++) {
    base = PyTuple_GET_ITEM(bases, i);
    result = PyObject_CallMethod(base, "__init__", "O", (PyObject *) self);
    if (result == NULL) return -1;
    Py_DECREF(result);
  }
  return 0;
}

static void console_dealloc(consoleobject *self)
{
  Py_XDECREF(self->parser);
  self->ob_type->tp_free((PyObject *) self);
}

static PyObject *console_cmdloop(consoleobject *self, PyObject *args)
{
  PyObject *result=NULL, *builtins=NULL, *readline=NULL, *old_completer=NULL;
  int stop;

  builtins = PyImport_ImportModule("__builtin__");
  if (builtins == NULL) goto exit;

  readline = PyImport_ImportModule("readline");
  if (readline == NULL) {
    if (!PyErr_ExceptionMatches(PyExc_ImportError)) goto exit;
    PyErr_Clear();
  } else {
#if PY_VERSION_HEX > 0x02030000
    /* old_completer = readline.get_completer() */
    old_completer = PyObject_CallMethod(readline, "get_completer", NULL);
    if (old_completer == NULL) goto exit;
#endif
    /* readline.set_completer(self.complete) */
    result = PyObject_GetAttrString((PyObject *) self, "complete");
    if (result == NULL) goto exit;
    result = PyObject_CallMethod(readline, "set_completer", "N", result);
    if (result == NULL) goto exit;
    Py_DECREF(result);
    /* readline.parse_and_bind("tab: complete") */
    result = PyObject_CallMethod(readline, "parse_and_bind", "s",
                                 "tab: complete");
    if (result == NULL) goto exit;
    Py_DECREF(result);
  }

  stop = 0;
  do {
    result = PyObject_GetAttrString((PyObject *) self, "prompt");
    if (result == NULL) goto finally;
    result = PyObject_CallMethod(builtins, "raw_input", "N", result);
    if (result == NULL) {
      if (PyErr_ExceptionMatches(PyExc_EOFError) ||
          PyErr_ExceptionMatches(PyExc_KeyboardInterrupt)) {
        PyErr_Clear();
        PySys_WriteStdout("\n");
        Py_INCREF(Py_None);
        result = Py_None;
      }
      goto finally;
    }
    result = PyObject_CallMethod((PyObject *) self, "onecmd", "N", result);
    if (result == NULL) goto finally;
    stop = PyObject_IsTrue(result);
    Py_DECREF(result);
  } while (!stop);

  Py_INCREF(Py_None);
  result = Py_None;

 finally:
#if PY_VERSION_HEX > 0x02030000
  if (readline != NULL && old_completer != NULL) {
    PyObject *rv;
    rv = PyObject_CallMethod(readline, "set_completer", "O", old_completer);
    if (rv == NULL) {
      Py_XDECREF(result);
      result = rv;
    } else {
      Py_DECREF(rv);
    }
  }
#endif
 exit:
  Py_XDECREF(old_completer);
  Py_XDECREF(readline);
  Py_XDECREF(builtins);
  return result;
}

static PyObject *console_emptyline(consoleobject *self, PyObject *noarg)
{
  Py_INCREF(Py_None);
  return Py_None;
}

static char console_exit_doc[] = "terminate the console";

static PyObject *console_exit(consoleobject *self, PyObject *arg)
{
  Py_INCREF(Py_True);
  return Py_True;
}

static char console_debug_doc[] = "sets or displays the debug level";

static PyObject *console_debug(consoleobject *self, PyObject *arg)
{
  PyObject *verbose;

  if (PyObject_IsTrue(arg)) {
    if ((verbose = PyNumber_Int(arg)) == NULL) {
      if (PyErr_ExceptionMatches(PyExc_ValueError)) {
        PyErr_Clear();
        PySys_WriteStdout("usage: debug <level>\n");
        Py_INCREF(Py_None);
        return Py_None;
      }
      return NULL;
    }
    self->parser->verbose = PyInt_AsLong(verbose);
    Py_DECREF(verbose);
  }
  PySys_WriteStdout("debug level is %d\n", self->parser->verbose);
  Py_INCREF(Py_None);
  return Py_None;
}

static char console_parse_doc[] = "parses an expression";

static PyObject *console_parse(consoleobject *self, PyObject *arg)
{
  PyObject *result, *value;

  result = parser_parse(self->parser, arg);
  if (result == NULL) {
    PyObject *exc, *tb;
    if (!PyErr_ExceptionMatches(PyExc_SyntaxError)) return NULL;
    PyErr_Fetch(&exc, &value, &tb);
    if (value && value != Py_None) {
      result = PyObject_Str(value);
    }
    Py_XDECREF(exc);
    Py_XDECREF(value);
    Py_XDECREF(tb);
    if (result == NULL) return NULL;
  }

  value = PyObject_Str(result);
  Py_DECREF(result);
  if (value == NULL) return NULL;

  PySys_WriteStdout("%s\n", PyString_AsString(value));
  Py_DECREF(value);

  Py_INCREF(Py_None);
  return Py_None;
}

static PyMethodDef console_methods[] = {
  { "cmdloop", (PyCFunction) console_cmdloop, METH_NOARGS },
  { "emptyline", (PyCFunction) console_emptyline, METH_NOARGS },
  { "do_exit", (PyCFunction) console_exit, METH_O, console_exit_doc },
  { "do_quit", (PyCFunction) console_exit, METH_O, console_exit_doc },
  { "do_debug", (PyCFunction) console_debug, METH_O, console_debug_doc },
  { "do_parse", (PyCFunction) console_parse, METH_O, console_parse_doc },
  { NULL }
};

static PyTypeObject Console_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ MODULE_NAME "." "console",
  /* tp_basicsize      */ sizeof(consoleobject),
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) console_dealloc,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) 0,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ (Py_TPFLAGS_DEFAULT |
                           Py_TPFLAGS_BASETYPE |
                           0),
  /* tp_doc            */ (char *) 0,
  /* tp_traverse       */ (traverseproc) 0,
  /* tp_clear          */ (inquiry) 0,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) console_methods,
  /* tp_members        */ (PyMemberDef *) 0,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ offsetof(consoleobject, dict),
  /* tp_init           */ (initproc) console_init,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) console_new,
  /* tp_free           */ 0,
};

static PyMethodDef module_methods[] = {
  { NULL }
};

static void module_dealloc(void *module)
{
  const yyimport_t *yyimp;

  /* forget references to loaded modules */
  for (yyimp = yymodule_imports; yyimp->yymodule; yyimp++) {
    Py_CLEAR(*yyimp->yyptr);
  }
#if PY_VERSION_HEX < 0x02050000
  Py_CLEAR(YY_ErrorObject);
#else
  PyType_CLEAR(&YY_Error_Type);
#endif
  PyType_CLEAR(&Console_Type);
  PyType_CLEAR(&Parser_Type);
}

PyMODINIT_FUNC MODULE_INITFUNC(void) {
  PyObject *import, *class, *item, *module;
  const yyimport_t *yyimp;

  if (PyType_Ready(&Parser_Type) < 0) return;
  if (YY_Error_Ready() < 0) return;

  /* Setup the console type's base classes */
  import = PyImport_ImportModule("cmd");
  if (import == NULL) return;
  class = PyObject_GetAttrString(import, "Cmd");
  Py_DECREF(import);
  if (class == NULL) return;
  Console_Type.tp_base = &PyBaseObject_Type;
  Console_Type.tp_bases = Py_BuildValue("(NO)", class, &PyBaseObject_Type);
  if (Console_Type.tp_bases == NULL) return;
  if (PyType_Ready(&Console_Type) < 0) return;

  item = PyString_FromString(PARSER_NAME "> ");
  if (PyDict_SetItemString(Console_Type.tp_dict, "prompt", item) < 0) return;
  Py_DECREF(item);

  module = Py_InitModule(MODULE_BASENAME, module_methods);
  if (module == NULL) return;

  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, "parser", (PyObject *)&Parser_Type);
  Py_INCREF(&Console_Type);
  PyModule_AddObject(module, "console", (PyObject *)&Console_Type);
  Py_INCREF(YY_ErrorObject);
  PyModule_AddObject(module, "error", YY_ErrorObject);
#ifndef BisonGen_FORWARDS_COMPATIBLE
  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, "new", (PyObject *)&Parser_Type);
  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, PARSER_NAME, (PyObject *)&Parser_Type);
#endif
  /* import required modules */
  for (yyimp = yymodule_imports; yyimp->yymodule; yyimp++) {
    *yyimp->yyptr = yy_import(yyimp->yymodule, yyimp->yyname);
    if (*yyimp->yyptr == NULL) return;
  }

  /* register the finalizer function */
  PyModule_AddObject(module, "__del__",
                     PyCObject_FromVoidPtr(module, module_dealloc));
}
