# Rekall Memory Forensics
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
# Copyright 2013 Google Inc. All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

# pylint: disable=protected-access

import distorm3

from rekall import obj
from rekall import scan
from rekall.plugins.windows.malware import devicetree
from rekall.plugins.windows import common
from rekall.plugins.overlays.windows import pe_vtypes

callback_types = {
    '_NOTIFICATION_PACKET' : [0x10, {
            'ListEntry' : [0x0, ['_LIST_ENTRY']],
            'DriverObject' : [0x8, ['pointer', ['_DRIVER_OBJECT']]],
    'NotificationRoutine' : [0xC, ['unsigned int']],
            }],
    '_KBUGCHECK_CALLBACK_RECORD' : [0x20, {
            'Entry' : [0x0, ['_LIST_ENTRY']],
            'CallbackRoutine' : [0x8, ['unsigned int']],
            'Buffer' : [0xC, ['pointer', ['void']]],
            'Length' : [0x10, ['unsigned int']],
            'Component' : [0x14, ['pointer', ['String', dict(length=64)]]],
            'Checksum' : [0x18, ['pointer', ['unsigned int']]],
            'State' : [0x1C, ['unsigned char']],
            }],
    '_KBUGCHECK_REASON_CALLBACK_RECORD' : [0x1C, {
            'Entry' : [0x0, ['_LIST_ENTRY']],
            'CallbackRoutine' : [0x8, ['unsigned int']],
            'Component' : [0xC, ['pointer', ['String', dict(length=8)]]],
            'Checksum' : [0x10, ['pointer', ['unsigned int']]],
            'Reason' : [0x14, ['unsigned int']],
            'State' : [0x18, ['unsigned char']],
            }],
    '_SHUTDOWN_PACKET' : [0xC, {
            'Entry' : [0x0, ['_LIST_ENTRY']],
            'DeviceObject' : [0x8, ['pointer', ['_DEVICE_OBJECT']]],
            }],
    '_EX_CALLBACK_ROUTINE_BLOCK' : [0x8, {
            'RundownProtect' : [0x0, ['unsigned int']],
            'Function' : [0x4, ['unsigned int']],
            'Context' : [0x8, ['unsigned int']],
            }],
    '_GENERIC_CALLBACK' : [0xC, {
            'Callback' : [0x4, ['pointer', ['void']]],
            'Associated' : [0x8, ['pointer', ['void']]],
            }],
    '_REGISTRY_CALLBACK_LEGACY' : [0x38, {
            'CreateTime' : [0x0, ['WinTimeStamp', {}]],
            }],
    '_REGISTRY_CALLBACK' : [None, {
            'ListEntry' : [0x0, ['_LIST_ENTRY']],
            'Function' : [0x1C, ['pointer', ['void']]],
            }],
    '_DBGPRINT_CALLBACK' : [0x14, {
            'Function' : [0x8, ['pointer', ['void']]],
            }],
    '_NOTIFY_ENTRY_HEADER' : [None, {
            'ListEntry' : [0x0, ['_LIST_ENTRY']],
            'EventCategory' : [0x8, ['Enumeration', dict(
                        target='long', choices={
                            0: 'EventCategoryReserved',
                            1: 'EventCategoryHardwareProfileChange',
                            2: 'EventCategoryDeviceInterfaceChange',
                            3: 'EventCategoryTargetDeviceChange'})]],
            'CallbackRoutine' : [0x14, ['unsigned int']],
            'DriverObject' : [0x1C, ['pointer', ['_DRIVER_OBJECT']]],
            }],
    }


class _SHUTDOWN_PACKET(obj.Struct):
    """Class for shutdown notification callbacks"""

    def sanity_check(self, vm):
        """
        Perform some checks to see if this object can exist in the provided
        address space.
        """

        if (not vm.is_valid_address(self.Entry.Flink) or
            not vm.is_valid_address(self.Entry.Blink) or
            not vm.is_valid_address(self.DeviceObject)):
            return False

        # Dereference the device object
        device = self.DeviceObject.dereference(vm=vm)

        # Carve out the device's object header and check its type
        object_header = self.obj_profile.Object(
            "_OBJECT_HEADER",
            offset=(device.obj_offset -
                    self.obj_profile.get_obj_offset("_OBJECT_HEADER", "Body")),
            vm=vm)

        return object_header.get_object_type(vm) == "Device"

class AbstractCallbackScanner(common.PoolScanner):
    """Return the offset of the callback, no object headers"""


class PoolScanFSCallback(AbstractCallbackScanner):
    """PoolScanner for File System Callbacks"""
    checks = [('PoolTagCheck', dict(tag="IoFs")),
            ('CheckPoolSize', dict(condition=lambda x: x == 0x18)),
            ('CheckPoolType', dict(non_paged=True, paged=True,
                                   free=True)),
            ]

    def scan(self, **kwargs):
        for pool_header in super(PoolScanFSCallback, self).scan(**kwargs):
            callback = self.profile.Object(
                '_NOTIFICATION_PACKET', offset=pool_header.end(),
                vm=self.address_space)

            yield ("IoRegisterFsRegistrationChange",
                   callback.NotificationRoutine, None)


class PoolScanShutdownCallback(AbstractCallbackScanner):
    """PoolScanner for Shutdown Callbacks"""
    checks = [('PoolTagCheck', dict(tag="IoSh")),
              ('CheckPoolSize', dict(condition=lambda x: x == 0x18)),
              ('CheckPoolType', dict(non_paged=True, paged=True,
                                     free=True)),
              ('CheckPoolIndex', dict(value=0)),
              ]

    def __init__(self, kernel_address_space=None, **kwargs):
        super(PoolScanShutdownCallback, self).__init__(**kwargs)
        self.kernel_address_space = kernel_address_space
        self.profile = devicetree.DeviceModification(self.profile)

    def scan(self, offset=0, **kwargs):
        for pool_header in super(PoolScanShutdownCallback, self).scan(
            offset=offset, **kwargs):

            # Instantiate the object in physical space but give it a native VM
            # of kernel space
            callback = self.profile._SHUTDOWN_PACKET(
                offset=pool_header.end(), vm=self.address_space)

            if not callback.sanity_check(self.kernel_address_space):
                continue

            # Get the callback's driver object. We've already
            # checked the sanity of the device object pointer.
            driver_obj = callback.DeviceObject.dereference(
                vm=self.kernel_address_space).DriverObject

            function_pointer = driver_obj.MajorFunction['IRP_MJ_SHUTDOWN']
            details = driver_obj.DriverName

            yield "IoRegisterShutdownNotification", function_pointer, details


class PoolScanGenericCallback(AbstractCallbackScanner):
    """PoolScanner for Generic Callbacks"""
    checks = [('PoolTagCheck', dict(tag="Cbrb")),
              ('CheckPoolSize', dict(condition=lambda x: x == 0x18)),
              ('CheckPoolType', dict(non_paged=True, paged=True, free=True)),
              ]

    def scan(self, **kwargs):
        """
        Enumerate generic callbacks of the following types:

        * PsSetCreateProcessNotifyRoutine
        * PsSetThreadCreateNotifyRoutine
        * PsSetLoadImageNotifyRoutine
        * CmRegisterCallback (on XP only)
        * DbgkLkmdRegisterCallback (on Windows 7 only)

        The only issue is that you can't distinguish between the types by just
        finding the generic callback structure
        """
        for pool_header in super(PoolScanGenericCallback, self).scan(**kwargs):
            callback = self.profile.Object(
                '_GENERIC_CALLBACK', offset=pool_header.end(),
                vm=self.address_space)

            yield "GenericKernelCallback", callback.Callback, None


class PoolScanDbgPrintCallback(AbstractCallbackScanner):
    """PoolScanner for DebugPrint Callbacks on Vista and 7"""
    checks = [('PoolTagCheck', dict(tag="DbCb")),
              ('CheckPoolSize', dict(condition=lambda x: x == 0x20)),
              ('CheckPoolType', dict(non_paged=True, paged=True, free=True)),
              ]

    def scan(self, offset=0, **kwargs):
        """Enumerate DebugPrint callbacks on Vista and 7"""
        for pool_header in super(PoolScanDbgPrintCallback, self).scan(
            offset=offset, **kwargs):

            callback = self.profile.Object(
                '_DBGPRINT_CALLBACK', offset=pool_header.end(),
                vm=self.address_space)

            yield "DbgSetDebugPrintCallback", callback.Function, None


class PoolScanRegistryCallback(AbstractCallbackScanner):
    """PoolScanner for DebugPrint Callbacks on Vista and 7"""
    checks = [('PoolTagCheck', dict(tag="CMcb")),
              # Seen as 0x38 on Vista SP2 and 0x30 on 7 SP0
              ('CheckPoolSize', dict(condition=lambda x: x >= 0x38)),
              ('CheckPoolType', dict(non_paged=True, paged=True, free=True)),
              ('CheckPoolIndex', dict(value=4)),
              ]

    def scan(self, offset=0, **kwargs):
        """
        Enumerate registry callbacks on Vista and 7.

        These callbacks are installed via CmRegisterCallback
        or CmRegisterCallbackEx.
        """
        for pool_header in super(PoolScanRegistryCallback, self).scan(
            offset=offset, **kwargs):

            callback = self.profile.Object(
                '_REGISTRY_CALLBACK', offset=pool_header.end(),
                vm=self.address_space)

            yield "CmRegisterCallback", callback.Function, None


class PoolScanPnp9(AbstractCallbackScanner):
    """PoolScanner for Pnp9 (EventCategoryHardwareProfileChange)"""
    checks = [('PoolTagCheck', dict(tags=["Pnp9", "PnpD", "PnpC"])),
              # seen as 0x2C on W7, 0x28 on vistasp0 (4 less but needs 8 less)
              ('CheckPoolSize', dict(condition=lambda x: x >= 0x30)),
              ('CheckPoolType', dict(non_paged=True, paged=True, free=True)),
              ('CheckPoolIndex', dict(value=1)),
              ]

    def __init__(self, kernel_address_space=None, **kwargs):
        self.kernel_address_space = kernel_address_space
        super(PoolScanPnp9, self).__init__(**kwargs)

    def scan(self, offset=0, **kwargs):
        """Enumerate IoRegisterPlugPlayNotification"""
        for pool_header in super(PoolScanPnp9, self).scan(
            offset=offset, **kwargs):
            entry = self.profile.Object(
                "_NOTIFY_ENTRY_HEADER", offset=pool_header.end(),
                vm=self.address_space)

            # Dereference the driver object pointer
            driver = entry.DriverObject.dereference(
                vm=self.kernel_address_space)

            # Instantiate an object header for the driver name
            header = self.profile.Object(
                "_OBJECT_HEADER",
                offset=(driver.obj_offset -
                        driver.obj_profile.get_obj_offset(
                        "_OBJECT_HEADER", "Body")),
                vm=driver.obj_vm)

            # Grab the object name
            driver_name = header.NameInfo.Name.v()

            yield entry.EventCategory, entry.CallbackRoutine, driver_name


class Callbacks(common.KDBGMixin, common.AbstractWindowsCommandPlugin):
    "Print system-wide notification routines."

    __name = "callbacks"

    def __init__(self, scan_in_kernel_address_space=False, **kwargs):
        """Scan for callbacks.

        Args:
           scan_in_kernel_address_space: If False we will use the physical
           address space for scanning, while if true we scan in the kernel
           address space.
        """
        super(Callbacks, self).__init__(**kwargs)
        self.scan_in_kernel_address_space = scan_in_kernel_address_space

        if self.profile.metadata("memory_model") == "32bit":
            # Add some plugin specific vtypes.
            self.profile.add_types(callback_types)
            self.profile.add_classes({
                    '_SHUTDOWN_PACKET': _SHUTDOWN_PACKET,
                    })

            self.profile = pe_vtypes.PEFileImplementation.Modify(
                self.profile)

        else:
            raise obj.ProfileError("This plugin only supports 32 bit profiles "
                                   "for now.")

    def get_kernel_callbacks(self, nt_mod):
        """
        Enumerate the Create Process, Create Thread, and Image Load callbacks.

        On some systems, the byte sequences will be inaccurate or the exported
        function will not be found. In these cases, the PoolScanGenericCallback
        scanner will pick up the pool associated with the callbacks.
        """

        routines = [
                   # push esi; mov esi, offset _PspLoadImageNotifyRoutine
                   ('PsSetLoadImageNotifyRoutine', "\x56\xbe"),
                   # push esi; mov esi, offset _PspCreateThreadNotifyRoutine
                   ('PsSetCreateThreadNotifyRoutine', "\x56\xbe"),
                   # mov edi, offset _PspCreateProcessNotifyRoutine
                   ('PsSetCreateProcessNotifyRoutine', "\xbf"),
                   ]

        for symbol, hexbytes in routines:
            # Locate the exported symbol in the NT module
            func = nt_mod.PE.GetProcAddress(symbol)
            if not func:
                continue

            #match = func.Search(["PUSH ESI", "MOV ESI"], 100)
            #if not match:
            #    continue
            #offset, _, instruction = match[1]

            # Find the global variable referenced by the exported symbol
            data = nt_mod.obj_vm.read(func.obj_offset, 100)

            offset = data.find(hexbytes)
            if offset == -1:
                continue

            # Read the pointer to the list
            p = self.profile.Pointer(
                offset=func.obj_offset + offset + len(hexbytes),
                vm=nt_mod.obj_vm)

            # The list is an array of 8 _EX_FAST_REF objects
            addrs = self.profile.Array(count=8, target='_EX_FAST_REF',
                                       offset=p, vm=nt_mod.obj_vm)

            for addr in addrs:
                callback = addr.dereference_as("_GENERIC_CALLBACK")
                if callback:
                    yield symbol, callback.Callback, None

    def get_bugcheck_callbacks(self):
        """
        Enumerate generic Bugcheck callbacks.

        Note: These structures don't exist in tagged pools, but you can find
        them via KDDEBUGGER_DATA64 on all versions of Windows.
        """

        KeBugCheckCallbackListHead = self.kdbg.KeBugCheckCallbackListHead.dereference_as(
            '_KBUGCHECK_CALLBACK_RECORD')

        for l in KeBugCheckCallbackListHead.Entry.list_of_type(
            "_KBUGCHECK_CALLBACK_RECORD", "Entry"):
            yield ("KeBugCheckCallbackListHead", l.CallbackRoutine,
                   l.Component.dereference())

    def get_registry_callbacks_legacy(self, nt_mod):
        """
        Enumerate registry change callbacks.

        This method of finding a global variable via disassembly of the
        CmRegisterCallback function is only for XP systems. If it fails on
        XP you can still find the callbacks using PoolScanGenericCallback.

        On Vista and Windows 7, these callbacks are registered using the
        CmRegisterCallbackEx function.
        """

        symbol = "CmRegisterCallback"

        func = nt_mod.PE.GetProcAddress(symbol)
        if not func:
            return

        # Read the function prologue
        data = nt_mod.obj_vm.read(func.obj_offset, 200)

        c = 0
        vector = None

        # Looking for MOV EBX, CmpCallBackVector
        # This may be the first or second MOV EBX instruction
        for op in distorm3.Decompose(
            func.obj_offset, data, distorm3.Decode32Bits):
            if (op.valid and op.mnemonic == "MOV" and
                len(op.operands) == 2 and op.operands[0].name == 'EBX'):
                vector = op.operands[1].value
                if c == 1:
                    break
                else:
                    c += 1

        # Can't find the global variable
        if vector == None:
            return

        # The vector is an array of 100 _EX_FAST_REF objects
        addrs = self.profile.Array(
            count=100, offset=vector, vm=nt_mod.obj_vm, target="_EX_FAST_REF")

        for addr in addrs:
            callback = addr.dereference_as("_EX_CALLBACK_ROUTINE_BLOCK")
            if callback:
                yield symbol, callback.Function, None

    def get_bugcheck_reason_callbacks(self, nt_mod):
        """
        Enumerate Bugcheck Reason callbacks.

        Note: These structures don't exist in tagged pools, so we
        find them by locating the list head which is a non-exported
        NT symbol. The method works on all x86 versions of Windows.

        mov [eax+KBUGCHECK_REASON_CALLBACK_RECORD.Entry.Blink],
                offset _KeBugCheckReasonCallbackListHead
        """
        symbol = "KeRegisterBugCheckReasonCallback"
        hexbytes = "\xC7\x40\x04"

        func = nt_mod.PE.GetProcAddress(symbol)
        if not func:
            return

        data = nt_mod.obj_vm.read(func.obj_offset, 100)

        # Search for the pattern
        offset = data.find(hexbytes)
        if offset == -1:
            return

        p = self.profile.Pointer(
            offset=func.obj_offset + offset + len(hexbytes),
            vm=nt_mod.obj_vm)

        bugs = p.dereference_as('_KBUGCHECK_REASON_CALLBACK_RECORD')

        for l in bugs.Entry.list_of_type(
            "_KBUGCHECK_REASON_CALLBACK_RECORD", "Entry"):
            yield symbol, l.CallbackRoutine, l.Component.dereference()

    def generate_hits(self):
        # Get the OS version we're analyzing
        version = (self.profile.metadata('major', 0),
                   self.profile.metadata('minor', 0))

        # Call the modules plugin to get all the modules.
        lsmod = self.session.plugins.modules(session=self.session)
        modlist = list(lsmod.lsmod())

        # Get a scanner group - this will scan for all these in one pass.
        scanners = dict(
            PoolScanFSCallback=PoolScanFSCallback(profile=self.profile),

            PoolScanShutdownCallback=PoolScanShutdownCallback(
                profile=self.profile,
                kernel_address_space=self.kernel_address_space),

            PoolScanGenericCallback=PoolScanGenericCallback(
                profile=self.profile),
            )

        # Valid for Vista and later
        if version >= (6, 0):
            scanners.update(
                PoolScanDbgPrintCallback=PoolScanDbgPrintCallback(
                    profile=self.profile),

                PoolScanRegistryCallback=PoolScanRegistryCallback(
                    profile=self.profile),

                PoolScanPnp9=PoolScanPnp9(
                    profile=self.profile,
                    kernel_address_space=self.kernel_address_space),
                )

        # Run through the hits but
        address_space = self.physical_address_space
        if self.scan_in_kernel_address_space:
            address_space = self.kernel_address_space

        self.scanners = scan.DiscontigScannerGroup(
            session=self.session, address_space=address_space,
            scanners=scanners)

        for _, info in self.scanners.scan():
            yield info

        # First few routines are valid on all OS versions
        for info in self.get_bugcheck_callbacks():
            yield info

        for info in self.get_bugcheck_reason_callbacks(modlist[0]):
            yield info

        for info in self.get_kernel_callbacks(modlist[0]):
            yield info

        # Valid for XP
        if version == (5, 1):
            for info in self.get_registry_callbacks_legacy(modlist[0]):
                yield info

    def render(self, renderer):

        renderer.table_header([("Type", "type", "36"),
                               ("Callback", "callback", "[addrpad]"),
                               ("Module", "module", "20"),
                               ("Details", "details", ""),
                               ])


        # We use the modules plugin to help locate the module containing the
        # callbacks.
        modules_plugin = self.session.plugins.modules(session=self.session)

        for (sym, cb, detail) in self.generate_hits():
            module = modules_plugin.find_module(cb)

            ## The original callbacks plugin searched driver objects
            ## if the owning module isn't found (Rustock.B). We leave that
            ## task up to the user this time, and will be incoporating
            ## some different module association methods later.
            if module:
                module_name = module.BaseDllName or module.FullDllName
            else:
                module_name = "UNKNOWN"

            renderer.table_row(sym, cb, module_name, detail)
