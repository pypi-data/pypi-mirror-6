# Rekall Memory Forensics
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
# Copyright 2013 Google Inc. All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

from rekall.plugins.windows import common


class Timers(common.WindowsCommandPlugin):
    """Print kernel timers and associated module DPCs"""

    __name = "timers"

    def _timers(self):
        if self.profile.get_constant("KiTimerTableListHead"):
            # On XP x64, Windows 2003 SP1-SP2, and Vista SP0-SP2,
            # KiTimerTableListHead is an array of 512 _KTIMER_TABLE_ENTRY
            # structs.
            if self.profile.has_type("_KTIMER_TABLE_ENTRY"):
                lists = self.profile.get_constant_object(
                    "KiTimerTableListHead",
                    target="Array",
                    target_args=dict(
                        target='_KTIMER_TABLE_ENTRY',
                        count=512)
                    )

                for l in lists:
                    for t in l.Entry.list_of_type("_KTIMER", "TimerListEntry"):
                        yield t

            else:
                # On XP SP0-SP3 x86 and Windows 2003 SP0, KiTimerTableListHead
                # is an array of 256 _LIST_ENTRY for _KTIMERs.
                lists = self.profile.get_constant_object(
                    "KiTimerTableListHead",
                    target="Array",
                    target_args=dict(
                        target='_LIST_ENTRY',
                        count=256)
                    )

                for l in lists:
                    for t in l.list_of_type("_KTIMER", "TimerListEntry"):
                        yield t
        else:
            # On Windows 7, there is no more KiTimerTableListHead. The list is
            # at _KPCR.PrcbData.TimerTable.TimerEntries (credits to Matt Suiche
            # for this one. See http://pastebin.com/FiRsGW3f).
            kpcr = self.session.plugins.kpcr().kpcr()
            for table in kpcr.Prcb.TimerTable.TimerEntries:
                self.session.report_progress("Table %r", table)
                for t in table.Entry.list_of_type_fast(
                    "_KTIMER", "TimerListEntry"):
                    yield t

    def timers(self):
        """A generator of timer objects."""
        # Sort the timers by address to make them easier to inspect.
        for timer in self._timers():
            # This is the code from reactos which checks for this:
            # #define ASSERT_TIMER(E) \
            #    NT_ASSERT(((E)->Header.Type == TimerNotificationObject) || \
            #              ((E)->Header.Type == TimerSynchronizationObject))
            if timer.Header.Type not in ["TimerNotificationObject",
                                         "TimerNotificationObject"]:
                continue

            self.session.report_progress("Looking at %#x", timer)

            # Ignore timers without DPCs
            if (not timer.Dpc.is_valid() or
                not timer.Dpc.DeferredRoutine.is_valid()):
                continue

            yield timer

    def render(self, renderer):
        renderer.table_header([("Offset", "offset", "[addrpad]"),
                               ("DueTime(H)          ", "due_high", "#020x"),
                               ("Period(ms)", "period", ">10"),
                               ("Signaled", "signaled", ">10"),
                               ("Routine", "routine", "[addrpad]"),
                               ("Module", "module", "20")])

        for timer in self.timers():
            if timer.Header.SignalState.v():
                signaled = "Yes"
            else:
                signaled = "-"

            renderer.table_row(
                timer,
                timer.DueTime.QuadPart,
                timer.Period,
                signaled,
                timer.Dpc.DeferredRoutine,
                self.session.address_resolver.format_address(
                    timer.Dpc.DeferredRoutine,
                    max_distance=0xFFFFFFFFFFFFF))
