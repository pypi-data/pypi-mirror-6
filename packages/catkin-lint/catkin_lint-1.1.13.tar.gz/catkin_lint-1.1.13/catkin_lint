#!/usr/bin/env python
"""
Copyright (c) 2013 Fraunhofer FKIE

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""
import os
import sys
# If run from the source tree
libdir = os.path.join(sys.path[0], "lib")
if os.path.isdir(os.path.join(libdir, "catkin_lint")): sys.path.insert(0, libdir)

import re
from catkin_pkg.packages import find_packages
from catkin_lint import __version__ as catkin_lint_version
import catkin_lint.cmake as cmake
import catkin_lint.util as util
from catkin_lint.diagnostics import msg
import textwrap

# Immutable variables must not be changed at all
immutable_vars = frozenset([
    "CMAKE_BUILD_TYPE",
    "CMAKE_C_COMPILER",
    "CMAKE_CXX_COMPILER",
    "PROJECT_NAME",
    "EXECUTABLE_OUTPUT_PATH",
    "LIBRARY_OUTPUT_PATH",
    "CATKIN_PACKAGE_BIN_DESTINATION",
    "CATKIN_PACKAGE_ETC_DESTINATION",
    "CATKIN_PACKAGE_INCLUDE_DESTINATION",
    "CATKIN_PACKAGE_LIB_DESTINATION",
    "CATKIN_PACKAGE_PYTHON_DESTINATION",
    "CATKIN_PACKAGE_SHARE_DESTINATION",
    "CATKIN_GLOBAL_BIN_DESTINATION",
    "CATKIN_GLOBAL_ETC_DESTINATION",
    "CATKIN_GLOBAL_INCLUDE_DESTINATION",
    "CATKIN_GLOBAL_LIB_DESTINATION",
    "CATKIN_GLOBAL_LIBEXEC_DESTINATION",
    "CATKIN_GLOBAL_PYTHON_DESTINATION",
    "CATKIN_GLOBAL_SHARE_DESTINATION"
])
# Critical variables contain important values that must not be overwritten,
# but appending additional items is okay
critical_vars = frozenset([
    "CMAKE_C_FLAGS",
    "CMAKE_CXX_FLAGS",
    "CMAKE_INCLUDE_PATH",
    "CMAKE_LIBRARY_PATH",
    "CMAKE_FIND_ROOT_PATH",
    "CMAKE_MODULE_PATH","CMAKE_PREFIX_PATH"
])
# Singleton commands may not appear more than once
singleton_cmds = frozenset([
    "project",
    "generate_messages",
    "catkin_package",
    "catkin_metapackage",
    "catkin_python_setup"
])

# Check for meaningless package descriptions
buzzwords = [
    r"(an)?other",
    r"(python\s+|c(\+\+)?\s+|java\s+)?code(\s+snippets?)?",
    r"(ros\s+)?nodes?",
    r"\d+",
    r"a\s+few",
    r"add(s|ed)?",
    r"all",
    r"an?",
    r"and",
    r"are",
    r"be",
    r"boilerplate",
    r"both",
    r"can",
    r"comprise(s|d)?",
    r"contain(s|ed)?",
    r"describe(s|d)?",
    r"descriptions?",
    r"did",
    r"different",
    r"do(es)?",
    r"done",
    r"examples?",
    r"executables?",
    r"for",
    r"from",
    r"functionalit(y|ies)",
    r"had",
    r"has",
    r"have",
    r"implementations?",
    r"in",
    r"include(s|d)?",
    r"interfaces?",
    r"into",
    r"is",
    r"librar(y|ies)",
    r"meaningless",
    r"miscellaneous",
    r"multiple",
    r"no(thing|ne|t)?",
    r"of",
    r"offer(s|ed)",
    r"one",
    r"or",
    r"packages?",
    r"programs?",
    r"provide(s|d)?",
    r"purpose",
    r"routines?",
    r"runs?",
    r"sets?",
    r"several",
    r"some",
    r"suppl(y|ies|ied)",
    r"that",
    r"the",
    r"these",
    r"this",
    r"those",
    r"three",
    r"to",
    r"todo",
    r"tools?",
    r"two",
    r"use[sd]?",
    r"useful",
    r"various",
    r"versions?",
    r"which",
    r"with",
    r"work\s+in\s+progress",
]

ERROR = 0
WARNING = 1
NOTICE = 2

diagnostic_label = { ERROR : "error", WARNING : "warning", NOTICE : "notice" }

def learn_packages(pkgs, catkin_pkgs, other_pkgs):
  for m in pkgs.values():
    is_catkin = True
    for e in m.exports:
      if e.tagname == "build_type" and e.content != "catkin":
        is_catkin = False
        break
    if is_catkin:
      catkin_pkgs.add(m.name)
    else:
      other_pkgs.add(m.name)

def check_catkin_pkg(path, manifest, results, is_ros_package, is_rosdep):
    pkg_buildtool_dep = set([dep.name for dep in manifest.buildtool_depends])
    pkg_build_dep = set([dep.name for dep in manifest.build_depends])
    pkg_run_dep = set([dep.name for dep in manifest.run_depends])
    pkg_test_dep = set([dep.name for dep in manifest.test_depends])
    in_macro = False
    in_function = False
    cmlist = open(os.path.join(path, "CMakeLists.txt"), "r")
    cm_build_dep = set([])
    cm_run_dep = set([])
    cm_msg_dep = set([])
    cm_finds = set([])
    cm_commands = set([])
    cm_build_bins = set([])
    cm_build_libs = set([])
    cm_build_includes = set([])
    cm_export_libs = set([])
    cm_export_targets = set([])
    cm_export_includes = set([])
    cm_target_outputs = {}
    cm_targets = set([])
    cm_installs = set([])
    cm_install_files = set([])
    cm_install_dirs = set([])
    cm_internal_deps = {}
    declares_messages = False
    has_catkin_stuff = False
    exports_includes = False
    installs_includes = False
    uses_rosbuild_compat = False
    name_fragments = set(util.word_split(manifest.name))
    var = {
      "CMAKE_CURRENT_SOURCE_DIR" : "/pkg-source",
      "CMAKE_CURRENT_BINARY_DIR" : "/pkg-build",
      "CATKIN_PACKAGE_BIN_DESTINATION" : "/catkin-target/lib/%s" % manifest.name,
      "CATKIN_PACKAGE_ETC_DESTINATION" : "/catkin-target/etc/%s" % manifest.name,
      "CATKIN_PACKAGE_INCLUDE_DESTINATION" : "/catkin-target/include/%s" % manifest.name,
      "CATKIN_PACKAGE_LIB_DESTINATION" : "/catkin-target/lib/%s" % manifest.name,
      "CATKIN_PACKAGE_PYTHON_DESTINATION" : "/catkin-target/lib/python/%s" % manifest.name,
      "CATKIN_PACKAGE_SHARE_DESTINATION" : "/catkin-target/share/%s" % manifest.name,
      "CATKIN_GLOBAL_BIN_DESTINATION" : "/catkin-target/bin",
      "CATKIN_GLOBAL_ETC_DESTINATION" : "/catkin-target/etc",
      "CATKIN_GLOBAL_INCLUDE_DESTINATION" : "/catkin-target/include",
      "CATKIN_GLOBAL_LIB_DESTINATION" : "/catkin-target/lib",
      "CATKIN_GLOBAL_LIBEXEC_DESTINATION" : "/catkin-target/lib",
      "CATKIN_GLOBAL_PYTHON_DESTINATION" : "/catkin-target/lib/python",
      "CATKIN_GLOBAL_SHARE_DESTINATION" : "/catkin-target/share",
      "catkin_INCLUDE_DIRS" : "/catkin-includes",
      "catkin_LIBRARIES" : "/catkin-libs/library.so",
    }
    for key in critical_vars:
        var[key] = "@%s@" % key
    for cmd, args in cmake.parse(cmlist.read(), var):
        if cmd in cm_commands & singleton_cmds:
            results.append((manifest.name, ERROR) + msg("DUPLICATE_CMD", cmd=cmd))
        cm_commands.add(cmd)
        if cmd.startswith("fkie_"):
            uses_rosbuild_compat = True
        if in_macro:
            if cmd == "endmacro": in_macro = False
            continue
        elif cmd == "macro":
            in_macro = True
            continue
        if in_function:
            if cmd == "endfunction": in_function = False
            continue
        elif cmd == "function":
            in_function = True
            continue
        if cmd == "project":
            var["PROJECT_NAME"] = args[0]
            if args[0] != manifest.name:
                results.append((manifest.name, ERROR) + msg("PROJECT_NAME", name=args[0]))
        if cmd == "find_package" or cmd == "fkie_find_package":
            if not "project" in cm_commands:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd=cmd, second_cmd="project"))
            if args[0] in cm_finds:
                results.append((manifest.name, ERROR) + msg("DUPLICATE_FIND", pkg=args[0]))
            cm_finds.add(args[0])
            if args[0] == "catkin":
                has_catkin_stuff = True
                if cmd == "fkie_find_package":
                    results.append((manifest.name, WARNING) + msg("DEPRECATED_ROSBUILD", cmd=cmd))
                opts, args = cmake.argparse(args, { "REQUIRED": "-", "COMPONENTS": "*" })
                if not opts["REQUIRED"]:
                    results.append((manifest.name, WARNING) + msg("MISSING_REQUIRED", pkg="catkin"))
                for pkg in opts["COMPONENTS"]:
                    if not is_ros_package(pkg):
                        results.append((manifest.name, ERROR) + msg("NO_CATKIN_COMPONENT", pkg=pkg))
                cm_build_dep |= set(opts["COMPONENTS"])
            else:
                var["%s_INCLUDE_DIRS" % args[0]] = "/find-path/"
                var["%s_INCLUDE_DIRS" % args[0].upper()] = "/find-path/"
                var["%s_LIBRARIES" % args[0]] = "/find-lib/library.so"
                var["%s_LIBRARIES" % args[0].upper()] = "/find-lib/library.so"
            continue
        if cmd == "include":
            opts, args = cmake.argparse(args, { "OPTIONAL" : "-", "RESULT_VARIABLE" : "?", "NO_POLICY_SCOPE" : "-"})
            if args:
                mo = re.match(r"^Find([A-Za-z0-9]+)(\.cmake)?$", args[0])
                if mo:
                    pkg = mo.group(1)
                    if not os.path.isfile(os.path.join(path, args[0])) and not opts["OPTIONAL"]:
                        results.append((manifest.name, ERROR) + msg("FIND_BY_INCLUDE", pkg=pkg))
                    var["%s_INCLUDE_DIRS" % pkg] = "/find-path/"
                    var["%s_INCLUDE_DIRS" % pkg.upper()] = "/find-path/"
                    var["%s_LIBRARIES" % pkg] = "/find-lib/library.so"
                    var["%s_LIBRARIES" % pkg.upper()] = "/find-lib/library.so"
            continue
        if cmd == "find_path":
            var[args[0]] = "/find-path/"
            continue
        if cmd == "find_library":
            var[args[0]] = "/find-lib/library.so"
            continue
        if cmd == "add_message_files" or cmd == "add_service_files" or cmd == "add_action_files":
            declares_messages = True
            has_catkin_stuff = True
            if manifest.is_metapackage():
                results.append((manifest.name, ERROR) + msg("INVALID_META_COMMAND", cmd=cmd))
            if not "catkin" in cm_finds:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd=cmd, second_cmd="find_package"))
            if "generate_messages" in cm_commands:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd="generate_messages", second_cmd=cmd))
            continue
        if cmd == "generate_messages":
            has_catkin_stuff = True
            if manifest.is_metapackage():
                results.append((manifest.name, ERROR) + msg("INVALID_META_COMMAND", cmd=cmd))
            if not "catkin" in cm_finds:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd=cmd, second_cmd="find_package"))
            if "catkin_package" in cm_commands:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd="catkin_package", second_cmd=cmd))
            opts, args = cmake.argparse(args, { "DEPENDENCIES": "*" })
            cm_msg_dep |= set(opts["DEPENDENCIES"])
            continue
        if cmd == "catkin_package":
            has_catkin_stuff = True
            if manifest.is_metapackage():
                results.append((manifest.name, ERROR) + msg("CATKIN_PKG_VS_META"))
            if not "catkin" in cm_finds:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd=cmd, second_cmd="find_package"))
            opts, args = cmake.argparse(args, { "INCLUDE_DIRS": "*", "LIBRARIES": "*", "DEPENDS": "*", "CATKIN_DEPENDS": "*", "CFG_EXTRAS": "*", "EXPORTED_TARGETS": "*" })
            for pkg in opts["CATKIN_DEPENDS"]:
                if not is_ros_package(pkg):
                    results.append((manifest.name, ERROR) + msg("SYSTEM_AS_CATKIN_DEPEND", pkg=pkg))
            for pkg in opts["DEPENDS"]:
                if is_ros_package(pkg):
                    results.append((manifest.name, ERROR) + msg("CATKIN_AS_SYSTEM_DEPEND", pkg=pkg))
                elif not pkg in cm_finds and not ("%s_INCLUDE_DIRS" % pkg in var and "%s_LIBRARIES" % pkg in var) and not ("%s_INCLUDE_DIRS" % pkg.upper() in var and "%s_LIBRARIES" % pkg.upper() in var):
                    results.append((manifest.name, ERROR) + msg("UNCONFIGURED_SYSTEM_DEPEND", pkg=pkg))
            includes = set([ d if os.path.isabs(d) else "/pkg-source/%s" % d for d in opts["INCLUDE_DIRS"] ])
            ext_includes = [ d for d in includes if not d.startswith("/pkg-") ]
            if ext_includes:
                results.append((manifest.name, ERROR) + msg("EXTERNAL_INCLUDE_PATH"))
            if includes:
                exports_includes = True
            cm_run_dep |= set(opts["CATKIN_DEPENDS"])
            cm_export_libs |= set(opts["LIBRARIES"])
            cm_export_targets |= set(opts["EXPORTED_TARGETS"])
            cm_export_includes |= set([os.path.normpath(d) for d in includes if d.startswith("/pkg-source") ])
            continue
        if cmd == "catkin_metapackage":
            has_catkin_stuff = True
            if not manifest.is_metapackage():
                results.append((manifest.name, ERROR) + msg("CATKIN_META_VS_PKG"))
            if not "catkin" in cm_finds:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd=cmd, second_cmd="find_package"))
            continue
        if cmd == "include_directories":
            opts, args = cmake.argparse(args, { "AFTER" : "-", "BEFORE" : "-", "SYSTEM" : "-" })
            cm_build_includes |= set([ os.path.normpath(d) if os.path.isabs(d) else os.path.normpath("/pkg-source/%s" % d) for d in args])
            continue
        if cmd == "link_directories":
            externals = [ p for p in args if os.path.isabs(p) and not p.startswith("/pkg-") ]
            if externals:
                results.append((manifest.name, ERROR) + msg("EXTERNAL_LINK_DIRECTORY"))
            else:
                results.append((manifest.name, WARNING) + msg("LINK_DIRECTORY"))
            continue
        if cmd == "target_link_libraries":
            if not cm_internal_deps.has_key(args[0]): cm_internal_deps[args[0]] = set([])
            cm_internal_deps[args[0]] |= set([ a for a in args[1:] if not a.startswith("/") ])
            continue
        if cmd == "add_library" or cmd == "add_executable":
            cm_targets.add(args[0])
            if cmd == "add_library": cm_build_libs.add(args[0])
            if cmd == "add_executable": cm_build_bins.add(args[0])
            if not cm_target_outputs.has_key(args[0]): cm_target_outputs[args[0]] = args[0]
            if manifest.is_metapackage():
                results.append((manifest.name, ERROR) + msg("INVALID_META_COMMAND", cmd=cmd))
            if not "catkin" in cm_finds:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd=cmd, second_cmd="find_package"))
            if not "catkin_package" in cm_commands:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd=cmd, second_cmd="catkin_package"))
            continue
        if cmd == "set_target_properties":
            opts, args = cmake.argparse(args, { "PROPERTIES" : "p" })
            for target in args:
                if opts["PROPERTIES"].has_key("OUTPUT_NAME"): cm_target_outputs[target] = opts["PROPERTIES"]["OUTPUT_NAME"]
            continue
        if cmd == "add_custom_target":
            cm_targets.add(args[0])
            continue
        if cmd == "set":
            if args[0] in immutable_vars:
                results.append((manifest.name, ERROR) + msg("IMMUTABLE_VAR", var=args[0]))
            elif args[0] in critical_vars:
                value = ';'.join(args[1:])
                if not "@%s@" % args[0] in value:
                    results.append((manifest.name, ERROR) + msg("CRITICAL_VAR_OVERWRITE", var=args[0]))
                else:
                    results.append((manifest.name, WARNING) + msg("CRITICAL_VAR_APPEND", var=args[0]))
            else:
                var[args[0]] = ';'.join(args[1:])
            continue
        if cmd == "unset":
            if args[0] in immutable_vars:
                results.append((manifest.name, ERROR) + msg("IMMUTABLE_VAR", var=args[0]))
            elif args[0] in critical_vars:
                results.append((manifest.name, ERROR) + msg("CRITICAL_VAR_OVERWRITE", var=args[0]))
            else:
                var[args[0]] = ""
            continue
        if cmd == "catkin_python_setup":
            has_catkin_stuff = True
            if not "catkin" in cm_finds:
                results.append((manifest.name, ERROR) + msg("ORDER_VIOLATION", first_cmd=cmd, second_cmd="find_package"))
            if not os.path.exists(os.path.join(path, "setup.py")):
                results.append((manifest.name, ERROR) + msg("MISSING_FILE", cmd=cmd, file="setup.py"))
            continue
        if cmd == "install":
            install_type = ""
            opts, args =  cmake.argparse(args, { "PROGRAMS" : "*", "FILES": "*", "TARGETS": "*", "DIRECTORY" : "?", "DESTINATION" : "?", "ARCHIVE DESTINATION": "?", "LIBRARY DESTINATION": "?", "RUNTIME DESTINATION": "?" })
            if opts["PROGRAMS"]:
                install_type = "PROGRAMS"
            if opts["DIRECTORY"]:
                install_type = "DIRECTORY"
            if opts["TARGETS"]:
                install_type = "TARGETS"
                cm_installs |= set(opts["TARGETS"])
            if opts["FILES"]:
                install_type = "FILES"
                cm_install_files |= set([os.path.normpath(os.path.join(opts["DESTINATION"], f)) for f in opts["FILES"] ])
            for dest in [ "DESTINATION", "ARCHIVE DESTINATION", "LIBRARY DESTINATION", "RUNTIME DESTINATION" ]:
                if not opts[dest]: continue
                if not opts[dest].startswith("/catkin-target/"):
                    results.append((manifest.name, WARNING) + msg("INSTALL_DESTINATION", type=install_type, dest=dest))
                if opts[dest].startswith("/catkin-target/include/"):
                    installs_includes = True
            continue
    if "rosbuild_compat_fkie" in pkg_buildtool_dep | pkg_build_dep and not uses_rosbuild_compat:
        results.append((manifest.name, WARNING) + msg("UNUSED_DEPEND", type="buildtool", pkg="rosbuild_compat_fkie"))
    if uses_rosbuild_compat and not "rosbuild_compat_fkie" in pkg_buildtool_dep:
        if not "rosbuild_compat_fkie" in pkg_build_dep:
            results.append((manifest.name, ERROR) + msg("MISSING_DEPEND", type="buildtool", pkg="rosbuild_compat_fkie"))
        else:
            results.append((manifest.name, WARNING) + msg("WRONG_DEPEND", wrong_type="build", right_type="buildtool", pkg="rosbuild_compat_fkie"))
    if "catkin" in pkg_buildtool_dep:
        if not "catkin" in cm_finds:
            results.append((manifest.name, ERROR) + msg("MISSING_FIND", pkg="catkin"))
        if not "catkin_package" in cm_commands and not manifest.is_metapackage():
            results.append((manifest.name, ERROR) + msg("MISSING_CMD", cmd="catkin_package"))
        if not "catkin_metapackage" in cm_commands and manifest.is_metapackage():
            results.append((manifest.name, ERROR) + msg("MISSING_CMD", cmd="catkin_metapackage"))
    elif has_catkin_stuff:
        results.append((manifest.name, ERROR) + msg("MISSING_DEPEND", type="buildtool", pkg="catkin"))
    if "generate_messages" in cm_commands and not declares_messages:
        results.append((manifest.name, WARNING) + msg("UNUSED_GENERATE_MSG"))
    if declares_messages and not "generate_messages" in cm_commands:
        results.append((manifest.name, ERROR) + msg("MISSING_GENERATE_MSG"))
        cm_commands.add("generate_messages") # Fake it
    if declares_messages and not "message_generation" in cm_build_dep and not manifest.is_metapackage():
        results.append((manifest.name, ERROR) + msg("UNCONFIGURED_BUILD_DEPEND", pkg="message_generation"))
    if declares_messages and not "message_runtime" in cm_run_dep and not manifest.is_metapackage():
        results.append((manifest.name, ERROR) + msg("MISSING_CATKIN_DEPEND", pkg="message_runtime"))
    if cm_targets and cm_build_dep and not "/catkin-includes" in cm_build_includes:
        results.append((manifest.name, WARNING) + msg("MISSING_CATKIN_INCLUDE"))
    if exports_includes and not installs_includes:
        results.append((manifest.name, ERROR if "install" in cm_commands else NOTICE) + msg("MISSING_INSTALL_INCLUDE"))
    if os.path.exists(os.path.join(path, "setup.py")) and not "catkin_python_setup" in cm_commands:
        results.append((manifest.name, ERROR) + msg("MISSING_PYTHON_SETUP"))
    if exports_includes and cm_build_libs and not cm_export_libs:
        results.append((manifest.name, WARNING) + msg("MISSING_EXPORT_LIB"))
    for pkg in cm_msg_dep - cm_build_dep - cm_finds:
        results.append((manifest.name, ERROR) + msg ("UNCONFIGURED_MSG_DEPEND", pkg=pkg))
    for pkg in cm_msg_dep - pkg_build_dep:
        results.append((manifest.name, ERROR) + msg("MISSING_MSG_DEPEND", pkg=pkg, type="build"))
    for pkg in cm_msg_dep - cm_run_dep:
        results.append((manifest.name, ERROR) + msg("MISSING_MSG_CATKIN", pkg=pkg))
    for pkg in cm_msg_dep - pkg_run_dep:
        results.append((manifest.name, ERROR) + msg("MISSING_MSG_DEPEND", pkg=pkg, type="run"))
    for lib in cm_export_libs:
        if not lib in cm_targets: continue
        if cm_target_outputs[lib] != lib:
            results.append((manifest.name, ERROR) + msg("EXPORT_LIB_RENAMED", target=lib))
        if not lib in cm_installs:
            results.append((manifest.name, ERROR if "install" in cm_commands else NOTICE) + msg("UNINSTALLED_EXPORT_LIB", target=lib))
        if lib in cm_build_bins:
            results.append((manifest.name, ERROR) + msg("EXPORT_LIB_NOT_LIB", target=lib))
    for tgt in cm_build_bins - cm_installs - cm_export_libs:
        if "test" in tgt.lower(): continue
        results.append((manifest.name, WARNING if "install" in cm_commands else NOTICE) + msg("MISSING_INSTALL_TARGET", target=tgt))
    for pkg in cm_build_dep - cm_run_dep:
        if re.match(r"_(msg|message)s?(_|$)", pkg) and is_ros_package(pkg):
            results.append((manifest.name, WARNING) + msg("SUGGEST_CATKIN_DEPEND", pkg=pkg))
    for pkg in cm_build_dep - pkg_build_dep:
        if pkg == "rosbuild_compat_fkie" and pkg in pkg_buildtool_dep: continue
        results.append((manifest.name, ERROR) + msg("MISSING_DEPEND", pkg=pkg, type="build"))
    for pkg in pkg_build_dep - cm_build_dep - cm_finds:
        if is_ros_package(pkg):
            results.append((manifest.name, ERROR) + msg("UNCONFIGURED_BUILD_DEPEND", pkg=pkg))
    for pkg in cm_run_dep - pkg_run_dep:
        results.append((manifest.name, ERROR) + msg("MISSING_DEPEND", pkg=pkg, type="run"))
    for pkg in (pkg_build_dep | pkg_run_dep) & pkg_test_dep:
        results.append((manifest.name, ERROR) + msg("REDUNDANT_TEST_DEPEND", pkg=pkg))
    for pkg in pkg_buildtool_dep:
        if not is_ros_package(pkg) and not is_rosdep(pkg):
            results.append((manifest.name, ERROR) + msg("UNKNOWN_DEPEND", pkg=pkg, type="buildtool"))
    for pkg in pkg_build_dep:
        if not is_ros_package(pkg) and not is_rosdep(pkg):
            results.append((manifest.name, ERROR) + msg("UNKNOWN_DEPEND", pkg=pkg, type="build"))
    for pkg in pkg_build_dep:
        if not is_ros_package(pkg) and not is_rosdep(pkg):
            results.append((manifest.name, ERROR) + msg("UNKNOWN_DEPEND", pkg=pkg, type="run"))
    for pkg in pkg_test_dep:
        if not is_ros_package(pkg) and not is_rosdep(pkg):
            results.append((manifest.name, ERROR) + msg("UNKNOWN_DEPEND", pkg=pkg, type="test"))
    for tgt in cm_export_targets - cm_targets:
        results.append((manifest.name, ERROR) + msg("UNDEFINED_TARGET",target=tgt))
    for incl in cm_export_includes:
        if not os.path.isdir(os.path.join(path, incl[12:])):
            results.append((manifest.name, ERROR) + msg("MISSING_EXPORT_INCLUDE_PATH", path=".%s" % incl[12:]))
    if cm_targets:
        for incl in cm_export_includes - cm_build_includes:
            results.append((manifest.name, WARNING) + msg("MISSING_BUILD_INCLUDE", path="./%s" % incl[12:]))
    for incl in cm_build_includes:
        if not incl.startswith("/pkg-source"): continue
        if not os.path.isdir(os.path.join(path, incl[12:])):
            results.append((manifest.name, ERROR) + msg("MISSING_BUILD_INCLUDE_PATH", path="./%s" % incl[12:]))
    for target, output in cm_target_outputs.iteritems():
        if os.sep in output:
            results.append((manifest.name, ERROR) + msg("INVALID_TARGET_OUTPUT", target=target))
        tgl = target.lower()
        tnc = True
        for nf in name_fragments:
          if len(nf) < 3: continue
          if nf in tgl:
            tnc = False
            break
        if tnc and not target in cm_export_libs:
            results.append((manifest.name, NOTICE) + msg("TARGET_NAME_COLLISION", target=target))
        if target in cm_build_libs:
            if output.startswith("lib"):
                results.append((manifest.name, NOTICE) + msg("REDUNDANT_LIB_PREFIX", output=output))
    for target, depends in cm_internal_deps.iteritems():
        if not target in cm_installs: continue
        for lib in depends:
            if not lib in cm_targets: continue
            if not lib in cm_installs:
                results.append((manifest.name, ERROR) + msg("UNINSTALLED_DEPEND", export_target=target, target=lib))
    if manifest.is_metapackage() and (len(cm_build_dep) > 0 or len(pkg_build_dep) > 0):
        results.append((manifest.name, ERROR) + msg("INVALID_META_DEPEND", type="build"))
    cm_plugin_dep = set([])
    for export in manifest.exports:
        if "plugin" in export.attributes.keys():
            plugin = export.attributes["plugin"]
            cm_plugin_dep.add(export.tagname)
            if not plugin.startswith("${prefix}/"):
                results.append((manifest.name, ERROR) + msg("PLUGIN_EXPORT_PREFIX", export=export.tagname))
            else:
                if not os.path.exists(os.path.join(path, plugin[10:])):
                    results.append((manifest.name, ERROR) + msg("PLUGIN_MISSING_FILE", export=export.tagname, file=plugin))
                if not os.path.normpath("/catkin-target/share/%s/%s" % (manifest.name, plugin[10:])) in cm_install_files:
                    results.append((manifest.name, ERROR if "install" in cm_commands else NOTICE) + msg("PLUGIN_MISSING_INSTALL", export=export.tagname, file=plugin[10:]))
    for dep in cm_plugin_dep - pkg_run_dep:
        results.append((manifest.name, WARNING) + msg("PLUGIN_DEPEND", export=dep, type="run", pkg=dep))
    chatter = re.match(r"((\s|[.,!?;()/])*\b(%s|%s)\b)+" % (manifest.name, r"|".join(buzzwords)), manifest.description, re.IGNORECASE)
    if chatter is not None:
        s = chatter.group(0).replace("\n", " ").strip()
        if manifest.description[chatter.end(0):].strip():
            if len(s.split()) > 1:
                results.append((manifest.name, NOTICE) + msg("DESCRIPTION_BOILERPLATE", text=s))
        else:
            results.append((manifest.name, NOTICE) + msg("DESCRIPTION_MEANINGLESS", text=s))

if __name__ == "__main__":
    try:
        import sys
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument("--version", action="version", version=catkin_lint_version)
        parser.add_argument("path", nargs="*", default=[], help="path to catkin packages")
        parser.add_argument("-W", metavar="LEVEL", type=int, default=0, help="set warning level (0-2)")
        parser.add_argument("--strict", action="store_true", help="treat warnings as errors")
        parser.add_argument("--explain", action="store_true", help="show additional explanations")
        parser.add_argument("--pkg", action="append", help="specify catkin package by name")
        args = parser.parse_args()
        results = []
        pkgs = {}
        local_pkg_names = set([])
        other_pkg_names = set([])
        pkgs_to_check = []
        nothing_to_do = 0
        if "ROS_PACKAGE_PATH" in os.environ:
            for path in os.environ["ROS_PACKAGE_PATH"].split(os.pathsep):
                pkgs = find_packages(path)
                learn_packages(pkgs, local_pkg_names, other_pkg_names)
                if args.pkg:
                    for p, m in pkgs.iteritems():
                        if m.name in args.pkg:
                            args.pkg.remove(m.name)
                            args.path.append(os.path.join(path, p))
                h, t = os.path.split(path)
                if t == "src":
                    repodir = os.path.join(h, "repos")
                    if os.path.isdir(repodir):
                        pkgs = find_packages(repodir)
                        learn_packages(pkgs, local_pkg_names, other_pkg_names)
                        if args.pkg:
                            for p, m in pkgs.iteritems():
                                if m.name in args.pkg:
                                    args.pkg.remove(m.name)
                                    args.path.append(os.path.join(repodir, p))
        if args.pkg:
            for p in args.pkg:
                sys.stderr.write ("catkin_lint: no such package: %s\n" % p)
        if not args.path:
            if os.path.exists("package.xml"):
                args.path += [ "." ]
            else:
                sys.stderr.write("catkin_lint: no path given and no package.xml in current directory\n")
                sys.exit(1)
        for path in args.path:
            path = os.path.normpath(path)
            if not os.path.isdir(path):
                sys.stderr.write ("catkin_lint: %s is not a directory\n" % path)
                nothing_to_do = 1
                continue
            pkgs = find_packages(path)
            learn_packages(pkgs, local_pkg_names, other_pkg_names)
            pkgs_to_check += [ (os.path.join(path, p), m) for p,m in pkgs.iteritems() ]
        if not pkgs_to_check:
            sys.stderr.write ("catkin_lint: no packages to check\n")
            sys.exit(nothing_to_do)
        view = {}
        try:
            from rosdep2.lookup import RosdepLookup
            from rosdep2.rospkg_loader import DEFAULT_VIEW_KEY
            from rosdep2.sources_list import SourcesListLoader
            sources_loader = SourcesListLoader.create_default()
            lookup = RosdepLookup.create_from_rospkg(sources_loader=sources_loader)
            view = lookup.get_rosdep_view(DEFAULT_VIEW_KEY)
        except Exception as err:
            sys.stderr.write("catkin_lint: cannot load rosdep database: %s\n" % str(err))
        for path, manifest in pkgs_to_check:
            try:
                check_catkin_pkg(path, manifest, results, lambda pkg: pkg in local_pkg_names, lambda key: key in other_pkg_names or not view.keys() or key in view.keys())
            except Exception as e:
                results.append((manifest.name, ERROR, "EXCEPTION", str(e), "catkin_lint failed to parse the package contents properly"))
        explained = set([])
        suppressed = { ERROR: 0, WARNING: 0, NOTICE: 0 }
        problems = 0
        exit_code = 0
        for pkg, level, msg_id, text, explanation in sorted(results):
            if args.W < level:
                suppressed[level] += 1
                continue
            if args.strict or level == ERROR: exit_code = 1
            problems += 1
            sys.stdout.write("%s: %s: %s\n" % (pkg, diagnostic_label[ERROR] if args.strict else diagnostic_label[level], text))
            if args.explain and not msg_id in explained:
                explained.add(msg_id)
                sys.stdout.write("%s\n" % textwrap.fill(explanation, initial_indent="     * ", subsequent_indent="     * "))
        sys.stderr.write ("catkin_lint: checked %d packages and found %d problems\n" % (len(pkgs_to_check), problems))
        for level in [ ERROR, WARNING, NOTICE ]:
          if suppressed[level] > 0:
              sys.stderr.write ("catkin_lint: %d %ss have been ignored. Use -W%d to see them\n" % (suppressed[level], diagnostic_label[level], level))
        sys.exit(exit_code)
    except Exception as err:
        sys.stderr.write("catkin_lint: %s\n\n" % str(err))
        sys.exit(2)

