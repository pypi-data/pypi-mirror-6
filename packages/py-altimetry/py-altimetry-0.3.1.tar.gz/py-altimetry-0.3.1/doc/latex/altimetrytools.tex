% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{altimetry tools Documentation}
\date{January 08, 2014}
\release{0}
\author{Renaud Dussurget}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Description}
\label{index:description}\label{index:welcome-to-altimetry-tools-s-documentation}
py-altimetry is a python module made to easily handle and process altimetry data.
It can furthermore handle a wider variety of data (in-situ or imagery data), and also has a number of tools, eg. spectral analysis, filtering data, interpolating, plotting maps, handle date vectors, handle positional data ...

This is module can be used as is, and is not aimed (nor designed) for operationnal constraints.


\chapter{Contents}
\label{index:contents}

\section{Description of the modules}
\label{Modules:description-of-the-modules}\label{Modules::doc}
You can find here the documentation about all modules.


\subsection{Contents:}
\label{Modules:contents}

\subsubsection{altimetry.data Module}
\label{altimetry.data:altimetry-data-module}\label{altimetry.data::doc}
This module contains special classes and tools to handle oceanographic data.
\begin{itemize}\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
\item {} \begin{description}
\item[{{\hyperref[altimetry.data:class]{\emph{Data objects:}}}}] \leavevmode\item {} 
{\hyperref[altimetry.data:alti-data]{\emph{alti\_data class - handles altimetry data:}}}

\item {} 
{\hyperref[altimetry.data:hydro-data]{\emph{hydro\_data class - handles oceanographic (in-situ or remotely sensed) data:}}}


\end{description}

\end{itemize}


\paragraph{Data objects:}
\label{altimetry.data:data-objects}\label{altimetry.data:class}

\subparagraph{alti\_data class - handles altimetry data:}
\label{altimetry.data:alti-data-class-handles-altimetry-data}\label{altimetry.data:alti-data}\index{alti\_data (class in altimetry.data)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data}\pysiglinewithargsret{\strong{class }\code{altimetry.data.}\bfcode{alti\_data}}{\emph{file\_pattern}, \emph{time\_range=None}, \emph{output\_is\_dict=True}, \emph{**kwargs}}{}
An {\hyperref[altimetry.data:altimetry.data.hydro_data]{\code{altimetry.data.hydro\_data}}} object dedicated to handling along-track altimetry data.
\begin{quote}\begin{description}
\item[{Example }] \leavevmode
To load different sets of data, try these :
\begin{itemize}
\item {} 
Concatenate a set of \textbf{AVISO's MFSTEP NRT along-track data} and plot a 2D hovmoller matrix:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}Define parameters }
\PYG{n}{trange\PYGZus{}str} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{24/09/2012}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{05/09/2013}\PYG{l+s}{'}\PYG{p}{]}
\PYG{n}{trange}\PYG{p}{,}\PYG{n}{tdatetime}\PYG{o}{=}\PYG{n}{AT}\PYG{o}{.}\PYG{n}{cnes\PYGZus{}convert}\PYG{p}{(}\PYG{n}{trange\PYGZus{}str}\PYG{p}{)} \PYG{c}{\PYGZsh{}convert time range}
\PYG{n}{alti\PYGZus{}pattern} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{/path/to/nrt/mfstep/nrt\PYGZus{}mfstep\PYGZus{}j2\PYGZus{}sla\PYGZus{}vfec\PYGZus{}*.nc}\PYG{l+s}{'}

\PYG{c}{\PYGZsh{}Load data}
\PYG{n}{alti}\PYG{o}{=}\PYG{n}{alti\PYGZus{}data}\PYG{p}{(}\PYG{n}{alti\PYGZus{}pattern}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n}{verbose}\PYG{p}{,}\PYG{n}{datatype}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{DT}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{time\PYGZus{}range}\PYG{o}{=}\PYG{n}{trange}\PYG{p}{,}\PYG{n}{slaext}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)} \PYG{c}{\PYGZsh{}Load data}

\PYG{c}{\PYGZsh{}2D reordering of the data}
\PYG{n}{alti}\PYG{o}{.}\PYG{n}{reorder}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{}Plot results}
\PYG{n}{pcolormesh}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{lat}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{cycle}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{sla}\PYG{p}{)}\PYG{p}{;} \PYG{n}{show}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{}plot the hovmoller}
\end{Verbatim}
\begin{itemize}
\item {} 
Loads a set of \textbf{PISTACH L3 5Hz} files and create a new SLA variable and slice the object using a given time range :

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}Load data}
\PYG{n}{alti\PYGZus{}pattern} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{/path/to/data/PISTACH\PYGZus{}L3\PYGZus{}Product\PYGZus{}NWMED\PYGZus{}MLE4\PYGZus{}tr*\PYGZus{}5hz.nc}\PYG{l+s}{'}
\PYG{n}{alti}\PYG{o}{=}\PYG{n}{alti\PYGZus{}data}\PYG{p}{(}\PYG{n}{alti\PYGZus{}pattern}\PYG{p}{,}\PYG{n}{limit}\PYG{o}{=}\PYG{n}{limit}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n}{verbose}\PYG{p}{)}
 
\PYG{n}{alti}\PYG{o}{.}\PYG{n}{create\PYGZus{}Variable}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{sla}\PYG{l+s}{'}\PYG{p}{,}                             \PYG{c}{\PYGZsh{}new variable name}
                     \PYG{n}{alti}\PYG{o}{.}\PYG{n}{ssh\PYGZus{}mss\PYGZus{}filtree\PYGZus{}21pts}\PYG{p}{,}        \PYG{c}{\PYGZsh{}data}
                     \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{time}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{alti}\PYG{o}{.}\PYG{n}{\PYGZus{}dimensions}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{time}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{c}{\PYGZsh{}set dimensions}
                     \PYG{n}{extend}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}                      \PYG{c}{\PYGZsh{}extend option}

\PYG{c}{\PYGZsh{}get daily updates of the object}
\PYG{k}{for} \PYG{n}{date} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{21300}\PYG{p}{,}\PYG{l+m+mi}{21320}\PYG{p}{)}\PYG{p}{:}
   
    \PYG{c}{\PYGZsh{}get a deep copy of the object, not to erase the whole dataset}
    \PYG{n}{subset}\PYG{o}{=}\PYG{n}{alti}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{deep}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
       
    \PYG{c}{\PYGZsh{}update the object with the proper slice}
    \PYG{n}{fg}\PYG{o}{=}\PYG{n}{subset}\PYG{o}{.}\PYG{n}{slice}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{date}\PYG{l+s}{'}\PYG{p}{,} \PYG{p}{[}\PYG{n}{date}\PYG{p}{,}\PYG{n}{date}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{subset}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{fg}\PYG{p}{)}
    
    \PYG{n}{do\PYGZus{}something}\PYG{p}{(}\PYG{n}{subset}\PYG{p}{)}
\end{Verbatim}
\begin{itemize}
\item {} 
Loads a set of \textbf{PISTACH hydro} files :

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{o}{=}\PYG{n}{AD}\PYG{o}{.}\PYG{n}{alti\PYGZus{}data}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{/*\PYGZus{}2PTP*\PYGZus{}*.nc}\PYG{l+s}{'} \PYG{o}{\PYGZpc{}} \PYG{n}{RepData}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n}{opts}\PYG{o}{.}\PYG{n}{verbose}\PYG{p}{,}\PYG{n}{datatype}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{RAW}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{remove\PYGZus{}existing}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}
\begin{itemize}
\item {} 
Load any \textbf{NetCDF file} using {\hyperref[altimetry.tools.nctools:altimetry.tools.nctools.nc]{\code{altimetry.tools.nctools.nc}}} :

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{o}{=}\PYG{n}{AD}\PYG{o}{.}\PYG{n}{alti\PYGZus{}data}\PYG{p}{(}\PYG{n}{fout}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n}{opts}\PYG{o}{.}\PYG{n}{verbose}\PYG{p}{,}\PYG{n}{datatype}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{RAW}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{transpose}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\end{description}\end{quote}
\index{\_\_init\_\_() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{file\_pattern}, \emph{time\_range=None}, \emph{output\_is\_dict=True}, \emph{**kwargs}}{}
returns a dataset from a single file or multiple concatenated files. cf. {\hyperref[altimetry.data:altimetry.data.hydro_data]{\code{altimetry.data.hydro\_data}}} for further informations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{time\_range} -- get start dates from file names (cf. notes on file names when using this option)

\item {} 
\textbf{kwargs} -- additionnal keywords to be passed to {\hyperref[altimetry.data:altimetry.data.hydro_data.__init__]{\code{altimetry.data.hydro\_data.\_\_init\_\_()}}}

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Naming convetion should respect AVISO formatting
\begin{itemize}
\item {} 
start dates should be the 3rd field from the end

\item {} 
satellite name should be the 3rd from the start

\item {} 
eg. my\_file\_sat\_20010101\_20010108\_20010109.nc

\end{itemize}
\end{notice}

\end{fulllineitems}

\index{cycle\_list() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.cycle_list}\pysiglinewithargsret{\bfcode{cycle\_list}}{\emph{*args}}{}
return the list of cycles contained if the dataset

\end{fulllineitems}

\index{pass\_time() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.pass_time}\pysiglinewithargsret{\bfcode{pass\_time}}{}{}
Compute the central time for each passes.

\begin{notice}{note}{Note:}
this must be called AFTER having called {\hyperref[altimetry.data:altimetry.data.alti_data.reorder]{\code{altimetry.data.alti\_data.reorder()}}} as it looks for the CYCLE and RECORD dimensions.
\end{notice}

\begin{notice}{note}{Note:}
The methodology to compute the central time is to interpolate the time along the track at missing points, and then reading the value at point N/2.
\end{notice}

\end{fulllineitems}

\index{read() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.read}\pysiglinewithargsret{\bfcode{read}}{\emph{filename}, \emph{datatype=None}, \emph{slaext=False}, \emph{**kwargs}}{}
reader method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} -- name of the file to load.

\item {} 
\textbf{datatype} -- 
choose between DT/NRT/PISTACH/CTOH or other formats to call the corresponding reader. If datatype is :
\begin{itemize}
\item {} 
DT or NRT or PISTACH : calls {\hyperref[altimetry.data:altimetry.data.alti_data.read_sla]{\code{altimetry.data.alti\_data.read\_sla()}}} or {\hyperref[altimetry.data:altimetry.data.alti_data.read_slaext]{\code{altimetry.data.alti\_data.read\_slaext()}}}

\item {} 
CTOH : calls {\hyperref[altimetry.data:altimetry.data.alti_data.read_CTOH]{\code{altimetry.data.alti\_data.read\_CTOH()}}}

\item {} 
else : calls {\hyperref[altimetry.data:altimetry.data.alti_data.read_nc]{\code{altimetry.data.alti\_data.read\_nc()}}}, based on {\hyperref[altimetry.tools.nctools:altimetry.tools.nctools.nc]{\code{altimetry.tools.nctools.nc}}} object.

\end{itemize}


\item {} 
\textbf{slaext} -- force using {\hyperref[altimetry.data:altimetry.data.alti_data.read_slaext]{\code{altimetry.data.alti\_data.read\_slaext()}}}

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This method is call from {\hyperref[altimetry.data:altimetry.data.hydro_data.__init__]{\code{altimetry.data.hydro\_data.\_\_init\_\_()}}} and returns a data structure to be handled by {\hyperref[altimetry.data:altimetry.data.hydro_data.update_dataset]{\code{altimetry.data.hydro\_data.update\_dataset()}}}
\end{notice}

\end{fulllineitems}

\index{read\_CTOH() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.read_CTOH}\pysiglinewithargsret{\bfcode{read\_CTOH}}{\emph{filename}, \emph{params=None}, \emph{force=False}, \emph{timerange=None}, \emph{datatype=None}, \emph{**kwargs}}{}
Read AVISO Along-Track SLA regional products
\begin{quote}\begin{description}
\item[{Return outStr}] \leavevmode
Output data structure containing all recorded parameters as specificied by NetCDF file PARAMETER list.

\item[{Author }] \leavevmode
Renaud Dussurget

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_nc() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.read_nc}\pysiglinewithargsret{\bfcode{read\_nc}}{\emph{filename}, \emph{**kwargs}}{}
data reader based on {\hyperref[altimetry.tools.nctools:altimetry.tools.nctools.nc]{\code{altimetry.tools.nctools.nc}}} object.

\begin{notice}{note}{Note:}
THIS can be VERY powerful!
\end{notice}

\end{fulllineitems}

\index{read\_sla() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.read_sla}\pysiglinewithargsret{\bfcode{read\_sla}}{\emph{filename}, \emph{params=None}, \emph{force=False}, \emph{timerange=None}, \emph{datatype=None}, \emph{**kwargs}}{}
Read AVISO Along-Track products
\begin{quote}\begin{description}
\item[{Return outStr}] \leavevmode
Output data structure containing all recorded parameters as specificied by NetCDF file PARAMETER list.

\item[{Author }] \leavevmode
Renaud Dussurget

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_slaext() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.read_slaext}\pysiglinewithargsret{\bfcode{read\_slaext}}{\emph{filename}, \emph{params=None}, \emph{force=False}, \emph{timerange=None}, \emph{datatype=None}, \emph{**kwargs}}{}
Read AVISO Along-Track SLAEXT regional products
\begin{quote}\begin{description}
\item[{Return outStr}] \leavevmode
Output data structure containing all recorded parameters as specificied by NetCDF file PARAMETER list.

\item[{Author }] \leavevmode
Renaud Dussurget

\end{description}\end{quote}

\end{fulllineitems}

\index{reorder() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.reorder}\pysiglinewithargsret{\bfcode{reorder}}{\emph{*args}, \emph{**kwargs}}{}
Reorders data vectors in 2D (ie. with dimensions (CYCLE,RECORD)). This is useful to get a hovmoller-type matrix of each variable.
\begin{quote}\begin{description}
\item[{Example }] \leavevmode
To plot a hovmoller for a given variable, do

\begin{Verbatim}[commandchars=\\\{\}]
.. code-block:: pyhton
\end{Verbatim}
\begin{quote}

data=alti\_data(`/my/dir/my\_files\_pattern*.nc') \#concatenate the files
data.reorder() \#reorder data
pcolormesh(data.lat,data.cycle,data.sla); show() \#plot the hovmoller
\end{quote}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This only works for data reprojected along a nominal track.
\end{notice}

\end{fulllineitems}

\index{set\_sats() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.set_sats}\pysiglinewithargsret{\bfcode{set\_sats}}{}{}
set satellite name using (cf. notes on file names in \emph{altimetry.data.alti\_data.\_\_init\_\_})

\end{fulllineitems}

\index{track\_list() (altimetry.data.alti\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.alti_data.track_list}\pysiglinewithargsret{\bfcode{track\_list}}{\emph{*args}}{}
return the list of tracks contained if the dataset

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{hydro\_data class - handles oceanographic (in-situ or remotely sensed) data:}
\label{altimetry.data:hydro-data-class-handles-oceanographic-in-situ-or-remotely-sensed-data}\label{altimetry.data:hydro-data}\index{hydro\_data (class in altimetry.data)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data}\pysiglinewithargsret{\strong{class }\code{altimetry.data.}\bfcode{hydro\_data}}{\emph{file\_pattern}, \emph{limit=None}, \emph{verbose=1}, \emph{round=True}, \emph{zero\_2pi=True}, \emph{output\_is\_dict=True}, \emph{flatten=False}, \emph{**kwargs}}{}
A base object dedicated to handle oceanographic data (in-situ or remote sensing) with upper level processing methods.

\begin{notice}{note}{Note:}
This object SHOULD NOT be called directly but through a subclass heritating of it (eg. {\hyperref[altimetry.data:altimetry.data.alti_data]{\code{altimetry.data.alti\_data}}})
\end{notice}
\index{Error() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.Error}\pysiglinewithargsret{\bfcode{Error}}{\emph{ErrorMsg}}{}
raises an exception

\end{fulllineitems}

\index{\_\_init\_\_() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{file\_pattern}, \emph{limit=None}, \emph{verbose=1}, \emph{round=True}, \emph{zero\_2pi=True}, \emph{output\_is\_dict=True}, \emph{flatten=False}, \emph{**kwargs}}{}
Returns the object filled with the data loaded from a single file or a concatenated set of files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{file\_pattern} -- a pattern of files to be globbed (\href{http://docs.python.org/library/glob.html\#glob.glob}{\code{glob.glob()}}) or a list of file names.

\item {} 
\textbf{limit} -- the limits of the domain to handle ({[}latmin,lonmin,latmax,lonmax{]}).

\item {} 
\textbf{verbose} -- verbosity level on a scale of 0 (silent) to 4 (max verobsity)

\item {} 
\textbf{round} -- round limits (cf. \code{altimetry.tools.in\_limits()})

\item {} 
\textbf{zero\_2pi} -- limits goes from 0 to 360 degrees (not -180/180).

\item {} 
\textbf{output\_is\_dict} -- data structures are dictionnaries (eg. my\_hydro\_data.variable{[}'data'{]}). If false uses an object with attributes (eg. my\_hydro\_data.variable.data).

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This methodes init all the attributes, then loads the data from files (\code{altimetry.data.hydro\_data.read()}) and appends it to the object ({\hyperref[altimetry.data:altimetry.data.hydro_data.update_dataset]{\code{altimetry.data.hydro\_data.update\_dataset()}}}) before checking its content ({\hyperref[altimetry.data:altimetry.data.hydro_data.check_variables]{\code{altimetry.data.hydro\_data.check\_variables()}}}).
\end{notice}

\begin{notice}{note}{Note:}
The method \code{altimetry.data.hydro\_data.read()} MUST be defined (typically by overloading it). This method must return a data structure.
\end{notice}

\end{fulllineitems}

\index{\_\_weakref\_\_ (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.__weakref__}\pysigline{\bfcode{\_\_weakref\_\_}}
list of weak references to the object (if defined)

\end{fulllineitems}

\index{check\_variables() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.check_variables}\pysiglinewithargsret{\bfcode{check\_variables}}{}{}
Forces variables to respect dimensions

\end{fulllineitems}

\index{contour\_transect() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.contour_transect}\pysiglinewithargsret{\bfcode{contour\_transect}}{\emph{x}, \emph{z}, \emph{var}, \emph{xrange=None}, \emph{zrange=None}, \emph{xstep=1}, \emph{zstep=10}, \emph{vmin=None}, \emph{vmax=None}, \emph{marker='.k'}, \emph{**kwargs}}{}
shows a 2d space-depth section by interpolating the data along the section.

\begin{notice}{note}{Note:}
This method interpolates using \code{scipy.interpolate.griddata()} and plots using \code{matplotlib.pyplot.meshcolorgrid()}
\end{notice}

\end{fulllineitems}

\index{copy() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.copy}\pysiglinewithargsret{\bfcode{copy}}{\emph{*args}, \emph{**kwargs}}{}
Returns a copy of the current data object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{flag} -- if an argument is provided, this returns an updated copy of current object (ie. equivalent to obj.copy();obj.update(flag)), optimising the memory (

\item {} 
\textbf{deep} (\href{http://docs.python.org/library/constants.html\#True}{\emph{True}}) -- deep copies the object (object data will be copied as well).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{count (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.count}\pysigline{\bfcode{count}\strong{ = None}}
number of files loaded

\end{fulllineitems}

\index{create\_Dim() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.create_Dim}\pysiglinewithargsret{\bfcode{create\_Dim}}{\emph{name}, \emph{value}}{}
Adds a dimension to class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} -- dimension name

\item {} 
\textbf{value} -- dimension value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_Variable() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.create_Variable}\pysiglinewithargsret{\bfcode{create\_Variable}}{\emph{name}, \emph{value}, \emph{dimensions}, \emph{toCreate=None}, \emph{createDim=None}, \emph{extend=True}}{}
create\_Variable : This function adds data to {\hyperref[altimetry.data:altimetry.data.hydro_data]{\code{altimetry.data.hydro\_data}}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} -- name of the parameter to create

\item {} 
\textbf{value} -- values associated to the variable. Must be a numpy masked\_array or a data structure.

\item {} 
\textbf{dimensions} -- dimensional structure (cf. notes).

\end{itemize}

\end{description}\end{quote}
\phantomsection\label{altimetry.data:structures}
\begin{notice}{note}{Note:}
altimetry tools package handles the NetCDF data using specific structures.

NetCDF data is structured this way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{NetCDF\PYGZus{}data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{\PYGZus{}dimensions}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{dimension\PYGZus{}structure}\PYG{p}{,}  \PYG{c}{\PYGZsh{}File dimensions  (COMPULSORY)}
               \PYG{l+s}{'}\PYG{l+s}{\PYGZus{}attributes}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{attribute\PYGZus{}structure}\PYG{p}{,}  \PYG{c}{\PYGZsh{}Global attributes}
               \PYG{l+s}{'}\PYG{l+s}{dimension\PYGZus{}1}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{data\PYGZus{}structure}\PYG{p}{,}       \PYG{c}{\PYGZsh{}Data associated to the dimensions. (COMPULSORY)}
               \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
               \PYG{l+s}{'}\PYG{l+s}{variable\PYGZus{}1}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{data\PYGZus{}structure}\PYG{p}{,}        \PYG{c}{\PYGZsh{}Variables}
               \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
              \PYG{p}{\PYGZcb{}}
\end{Verbatim}

In standard NetCDF files, dimensions are always associated to a variable.
If it is not the case, an array of indices the length of the dimension is generated and a warning is issued.

Moreover, dimensions MUST be defined to be accepted by {\hyperref[altimetry.tools.nctools:altimetry.tools.nctools.nc]{\code{altimetry.tools.nctools.nc}}} (empty NetCDF files would fail).
\begin{itemize}
\item {} 
a dimensional structure should be of the form :

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dimension\PYGZus{}structure} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{\PYGZus{}ndims}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{N}\PYG{p}{,}        \PYG{c}{\PYGZsh{}Attribute setting the number of dimensions.}

                       \PYG{l+s}{'}\PYG{l+s}{dims}\PYG{l+s}{'}\PYG{p}{:}\PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{dim\PYGZus{}A}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{A}\PYG{p}{,} \PYG{c}{\PYGZsh{}Structure containing the name}
                               \PYG{l+s}{'}\PYG{l+s}{dim\PYGZus{}B}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{B}\PYG{p}{,} \PYG{c}{\PYGZsh{}of the dimensions and their size. }
                               \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
                               \PYG{l+s}{'}\PYG{l+s}{dim\PYGZus{}N}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{N}
                              \PYG{p}{\PYGZcb{}}
                      \PYG{p}{\PYGZcb{}}
\end{Verbatim}
\begin{itemize}
\item {} 
an attribute structure is a very simple structure containing the attribute names and values:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data\PYGZus{}structure} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{attribute\PYGZus{}1}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{attribute\PYGZus{}1}\PYG{p}{,}
                  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
                  \PYG{l+s}{'}\PYG{l+s}{attribute\PYGZus{}N}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{attribute\PYGZus{}N}\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\begin{itemize}
\item {} 
a data structure should be of the form :

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data\PYGZus{}structure} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{\PYGZus{}dimensions}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{dimension\PYGZus{}structure}\PYG{p}{,} \PYG{c}{\PYGZsh{}dimensions of hte variable (COMPULSORY)}
                  \PYG{l+s}{'}\PYG{l+s}{data}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{data}\PYG{p}{,}                       \PYG{c}{\PYGZsh{}data associated to the variable (COMPULSORY)}
                  
                  \PYG{l+s}{'}\PYG{l+s}{long\PYGZus{}name}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{long\PYGZus{}name}\PYG{p}{,}             \PYG{c}{\PYGZsh{}Variable attributes}
                  \PYG{l+s}{'}\PYG{l+s}{units}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{units}\PYG{p}{,}
                  \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
                 \PYG{p}{\PYGZcb{}}
\end{Verbatim}

DATA and \_DIMENSIONS fields are compulsory.
Other fields are optional and will be treated as attributes.

Furthermore, code will have a special look at \textbf{scale}, \textbf{scale\_factor} and \textbf{add\_offset} while reading and writing data and to \textbf{\_FillValue} and missing\_value while reading (\_FillValue being automatically filled by \code{NetCDF4.Dataset} when writing)
\end{notice}

\end{fulllineitems}

\index{delete\_Variable() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.delete_Variable}\pysiglinewithargsret{\bfcode{delete\_Variable}}{\emph{name}}{}
pops a variable from class and delete it from parameter list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{name} -- name of the parameter to delete

\end{description}\end{quote}

\end{fulllineitems}

\index{dim\_list (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.dim_list}\pysigline{\bfcode{dim\_list}\strong{ = None}}
array containing the dimensions of each parameter

\end{fulllineitems}

\index{dirname (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.dirname}\pysigline{\bfcode{dirname}\strong{ = None}}
Directory name of the file pattern being globbed (\href{http://docs.python.org/library/glob.html\#glob.glob}{\code{glob.glob()}}). Defaulted to current directory

\end{fulllineitems}

\index{extension() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.extension}\pysiglinewithargsret{\bfcode{extension}}{\emph{flag=None}, \emph{round=True}}{}
returns the limits of the dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{flag} -- an indexation flag array

\item {} 
\textbf{round} -- round the limits to the south-west and north-east.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fileid (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.fileid}\pysigline{\bfcode{fileid}\strong{ = None}}
array of file IDs

\end{fulllineitems}

\index{filelist (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.filelist}\pysigline{\bfcode{filelist}\strong{ = None}}
list of files being loaded

\end{fulllineitems}

\index{filelist\_count (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.filelist_count}\pysigline{\bfcode{filelist\_count}\strong{ = None}}
number of counted values by files

\end{fulllineitems}

\index{get() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.get}\pysiglinewithargsret{\bfcode{get}}{\emph{name}}{}
retunrs a variable

\end{fulllineitems}

\index{get\_currentDim() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.get_currentDim}\pysiglinewithargsret{\bfcode{get\_currentDim}}{}{}
returns the current dimensions of the object

\end{fulllineitems}

\index{get\_file() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.get_file}\pysiglinewithargsret{\bfcode{get\_file}}{\emph{pattern}}{}
returns a flag array of the data loaded from a given file pattern
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{pattern} -- pattern to match in the file list.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_object\_stats() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.get_object_stats}\pysiglinewithargsret{\bfcode{get\_object\_stats}}{}{}
get some statistics about the whole dataset.

\end{fulllineitems}

\index{get\_platform\_stats() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.get_platform_stats}\pysiglinewithargsret{\bfcode{get\_platform\_stats}}{\emph{id}}{}
get statistics based on \emph{altimetry.data.hydro\_data.id}

\end{fulllineitems}

\index{get\_stats() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.get_stats}\pysiglinewithargsret{\bfcode{get\_stats}}{\emph{flag}}{}
get some statistics about a part of the dataset

\end{fulllineitems}

\index{in\_limits() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.in_limits}\pysiglinewithargsret{\bfcode{in\_limits}}{\emph{limit=None}}{}
wrapper to \code{altimetry.tools.in\_limits()} based on dataset limits.

\end{fulllineitems}

\index{limit (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.limit}\pysigline{\bfcode{limit}\strong{ = None}}
limits of the domain : {[}latmin,lonmin,latmax,lonmax{]} (default = {[}-90.,0.,90.,360.{]})/

\begin{notice}{note}{Note:}
limits are automatically reset using \code{altimetry.tools.recale\_limits()}
\end{notice}

\end{fulllineitems}

\index{map() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.map}\pysiglinewithargsret{\bfcode{map}}{\emph{flag=None}, \emph{fname=None}, \emph{zoom=False}, \emph{pmap=None}, \emph{show=True}, \emph{**kwargs}}{}
display (or not) a map based on a \code{altimetry.tools.plot\_map} object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{show} -- set to False not to show (and neither apply \code{altimetry.tools.plot\_map.setup\_map()})

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This function creates a \code{altimetry.tools.plot\_map} instance, plot a partion of the dataset using {\hyperref[altimetry.data:altimetry.data.hydro_data.plot_track]{\code{altimetry.data.hydro\_data.plot\_track()}}} and displays it if asked to.
\end{notice}

\end{fulllineitems}

\index{message() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.message}\pysiglinewithargsret{\bfcode{message}}{\emph{MSG\_LEVEL}, \emph{str}}{}
print function wrapper. Print a message depending on the verbose level
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{MSG\_LEVEL} (\emph{\{in\}\{required\}\{type=int\}}) -- level of the message to be compared with self.verbose

\item[{Example }] \leavevmode
To write a message

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{message}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{This message will be shown for any verbose level}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{ncstruct() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.ncstruct}\pysiglinewithargsret{\bfcode{ncstruct}}{\emph{**kwargs}}{}
returns a data structure (dict) of the dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{params} -- Add this keyword to provide a list of variables to export. Default : all variables contained is self.par\_list

\end{description}\end{quote}

\end{fulllineitems}

\index{par\_list (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.par_list}\pysigline{\bfcode{par\_list}\strong{ = None}}
array of parameters

\end{fulllineitems}

\index{platform\_summary() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.platform_summary}\pysiglinewithargsret{\bfcode{platform\_summary}}{\emph{id}, \emph{col='.k'}}{}
outputs a summary of the statistics for a given platform

\end{fulllineitems}

\index{plot\_track() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.plot_track}\pysiglinewithargsret{\bfcode{plot\_track}}{\emph{pmap}, \emph{flag=None}, \emph{col='.k'}, \emph{endpoint='*r'}, \emph{endpoint\_size=None}, \emph{title=None}, \emph{fontsize=8}, \emph{textcolor='b'}, \emph{ms=5}, \emph{linewidth=1}, \emph{**kwargs}}{}
plot trajectories based on platform IDs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{pmap} -- a \code{altimetry.tools.plot\_map} instance

\item {} 
\textbf{col} -- color to be used along the trajectory. If this is an array of values, calls \code{altimetry.tools.plot\_map.scatter()} instead of \code{altimetry.tools.plot\_map.plot()}

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This method loops on data IDs. Then it calls \code{altimetry.tools.plot\_map.plot()} or \code{altimetry.tools.plot\_map.scatter()} to plot the trajectory and then labels the trajectory using \code{altimetry.tools.plot\_map.text()}
\end{notice}

\end{fulllineitems}

\index{plot\_track\_old() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.plot_track_old}\pysiglinewithargsret{\bfcode{plot\_track\_old}}{\emph{*args}, \emph{**kwargs}}{}
plot a surface map of sampling track

\begin{notice}{warning}{Warning:}
DEPRECATED method!
\end{notice}

\end{fulllineitems}

\index{plot\_transect() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.plot_transect}\pysiglinewithargsret{\bfcode{plot\_transect}}{\emph{x}, \emph{z}, \emph{var}, \emph{xrange=None}, \emph{zrange=None}, \emph{vmin=None}, \emph{vmax=None}, \emph{xstep=1}, \emph{zstep=10}, \emph{s=10}, \emph{edgecolor='none'}, \emph{**kwargs}}{}
shows a 2d space-depth section plotting point (using \code{altimetry.tools.plot\_map.scatter()})
\begin{quote}\begin{description}
\item[{Example }] \leavevmode
plot a temperature section along a glider transect

\end{description}\end{quote}

\end{fulllineitems}

\index{pop() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.pop}\pysiglinewithargsret{\bfcode{pop}}{\emph{*args}, \emph{**kwargs}}{}
This is a wrapper to {\hyperref[altimetry.data:altimetry.data.hydro_data.delete_Variable]{\code{altimetry.data.hydro\_data.delete\_Variable()}}}

\end{fulllineitems}

\index{push\_nc() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.push_nc}\pysiglinewithargsret{\bfcode{push\_nc}}{\emph{*args}, \emph{**kwargs}}{}
append a data structure to an exisiting netcdf file

\end{fulllineitems}

\index{read\_ArgoNC() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.read_ArgoNC}\pysiglinewithargsret{\bfcode{read\_ArgoNC}}{\emph{filename}, \emph{params=None}, \emph{force=False}, \emph{dephrange=None}, \emph{timerange=None}, \emph{**kwargs}}{}
An Argo network NetCDF reader
\begin{quote}\begin{description}
\item[{Return outStr}] \leavevmode
Output data stricture (dict) containing all recorded parameters as specificied by NetCDF file PARAMETER list.

\item[{Author }] \leavevmode
Renaud Dussurget

\end{description}\end{quote}

\end{fulllineitems}

\index{size (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.size}\pysigline{\bfcode{size}\strong{ = None}}
length of the dataset

\end{fulllineitems}

\index{slice() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.slice}\pysiglinewithargsret{\bfcode{slice}}{\emph{param}, \emph{range}, \emph{surf=False}}{}
get a flag for indexing based on values (ange of fixed values).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{param} -- variable name

\item {} 
\textbf{range} -- 
numpy array defining the range of the values. If size(range) == 2 :
\begin{itemize}
\item {} 
flag is computed between min and max values of range

\item {} 
flag is computed based on equality to range value.

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{summary() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.summary}\pysiglinewithargsret{\bfcode{summary}}{\emph{all=False}, \emph{fig=None}, \emph{col='.k'}, \emph{legend=None}, \emph{**kwargs}}{}
outputs a summary of the whole current dataset

\end{fulllineitems}

\index{time\_range() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.time_range}\pysiglinewithargsret{\bfcode{time\_range}}{\emph{flag=None}}{}
time range of the current dataset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{flag} -- use a flag array to know the time range of an indexed slice of the object

\end{description}\end{quote}

\end{fulllineitems}

\index{time\_slice() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.time_slice}\pysiglinewithargsret{\bfcode{time\_slice}}{\emph{timerange}, \emph{surf=False}}{}
slice object given a time range
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{timerange} -- rime range to be used.

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.update}\pysiglinewithargsret{\bfcode{update}}{\emph{*args}, \emph{**kwargs}}{}
Wrapper to {\hyperref[altimetry.data:altimetry.data.hydro_data.update_with_slice]{\code{altimetry.data.hydro\_data.update\_with\_slice()}}}.

\end{fulllineitems}

\index{update\_Dim() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.update_Dim}\pysiglinewithargsret{\bfcode{update\_Dim}}{\emph{name}, \emph{value}}{}
update a dimension by appending the number of added elements to the dimensions

\begin{Verbatim}[commandchars=\\\{\}]
\textless{}upddated dimension\textgreater{} = \textless{}old dimension\textgreater{} + \textless{}number of added elements along this dimension\textgreater{}
\end{Verbatim}

\end{fulllineitems}

\index{update\_dataset() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.update_dataset}\pysiglinewithargsret{\bfcode{update\_dataset}}{\emph{dataStr}, \emph{flatten=False}}{}
update class with a data structure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{flatten} -- use this to automatically flatten variables (squeeze dimensions)

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_fid\_list() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.update_fid_list}\pysiglinewithargsret{\bfcode{update\_fid\_list}}{\emph{filename}, \emph{N}}{}
update file indices attribute \emph{altimetry.data.hydro\_data.fileid}

\end{fulllineitems}

\index{update\_with\_slice() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.update_with_slice}\pysiglinewithargsret{\bfcode{update\_with\_slice}}{\emph{flag}}{}
update object with a given time slice flag
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{array) flag} (\emph{(boolean}) -- a flag for indexing data along the `'time'' dimension

\end{description}\end{quote}

\end{fulllineitems}

\index{updated\_copy() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.updated_copy}\pysiglinewithargsret{\bfcode{updated\_copy}}{\emph{flag}, \emph{deep=True}}{}
Returns a sliced (updated) copy of current data object
\begin{quote}\begin{description}
\item[{Summary }] \leavevmode
This has the same effect as \emph{obj.copy();obj.update(flag)} but is much less memory consumming.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
TypeError could arise if some object attributes are setted outside the \code{\_\_init\_\_()} function (eg. for data objects derived from \code{hydro\_data}). If this is the case, initialise these attributes within their respective \code{\_\_init\_\_()}.
\end{notice}

\end{fulllineitems}

\index{verbose (altimetry.data.hydro\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.verbose}\pysigline{\bfcode{verbose}\strong{ = None}}
verbosity level on a scale of 0 (silent) to 4 (max verbosity)

\end{fulllineitems}

\index{warning() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.warning}\pysiglinewithargsret{\bfcode{warning}}{\emph{MSG\_LEVEL}, \emph{str}}{}
Wrapper to \code{warning.warn()}. Returns a warning when verbose level is not 0.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{MSG\_LEVEL} -- level of the message to be compared with self.verbose

\item[{Example }] \leavevmode
To issued a warning

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{Warning being issued)}
\end{Verbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_nc() (altimetry.data.hydro\_data method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.data:altimetry.data.hydro_data.write_nc}\pysiglinewithargsret{\bfcode{write\_nc}}{\emph{filename}, \emph{clobber=False}, \emph{**kwargs}}{}
write a NetCDF file from current dataset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{kwargs} -- additional arguments are passed to {\hyperref[altimetry.tools.nctools:altimetry.tools.nctools.nc.write]{\code{altimetry.tools.nctools.nc.write()}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{altimetry.tools Module}
\label{altimetry.tools:altimetry-tools-module}\label{altimetry.tools::doc}
This module contain a number of tools for processing the data.

These are :


\paragraph{Spectral analysis}
\label{altimetry.tools.spectrum:spectral-tools}\label{altimetry.tools.spectrum:spectral-analysis}\label{altimetry.tools.spectrum::doc}
The {\hyperref[altimetry.tools.spectrum:module-altimetry.tools.spectrum]{\code{altimetry.tools.spectrum}}} module contains tools dedicated to spectral analysis.


\subparagraph{About spectral analysis}
\label{altimetry.tools.spectrum:about-spectral-analysis}
Spectral analysis of along-track data is a common thing. There are 2 main steps when computing a spectrum:
\begin{itemize}
\item {} 
\textbf{preprocess the data}

It consists in detecting gaps, interpolating over short gaps and rejecting longer gaps, subsampling the data into subsegments of valid data of a given length.

This step is performed using {\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.preprocess]{\code{altimetry.tools.spectrum.preprocess()}}}

\item {} 
\textbf{compute the spectrum}

This step is made through a transform of the signal to the spectral domain (eg. FFT). Then frequency, energy and power spectral densities are computed and averaged. It is also possible to use \textbf{spectral tapers} to lower the noise of the spectrum.
\begin{quote}

This step is performed using {\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.spectral_analysis]{\code{altimetry.tools.spectrum.spectral\_analysis()}}} (and {\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.get_spec]{\code{altimetry.tools.spectrum.get\_spec()}}} at lower level)
\end{quote}

\end{itemize}


\subparagraph{Notes on spectral tapering}
\label{altimetry.tools.spectrum:notes-on-spectral-tapering}
Tapering and padding are mathematical manipulations sometimes performed on the time series before periodogram analysis to improve the statistical properties of the spectral estimates or to speed up the computations.
\begin{description}
\item[{\textbf{Tapering can be applied:}}] \leavevmode\begin{itemize}
\item {} 
to reduce the noise level by oversampling the data in overlapping subsegments (eg. when we don't have enough samples)

\item {} 
to better localise spectral peaks and changes in the spectral slope.

\end{itemize}

\item[{\textbf{However, you should be aware that}:}] \leavevmode\begin{itemize}
\item {} 
tapering may induce a loss of overall energy, resulting the tapered spectrum to be under (though less noisy) the original spectrum.

\item {} 
oversampling the data will result in removing a part of the lower frequencies because of the shorter subsegments.

\end{itemize}

\end{description}

{\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.preprocess]{\code{altimetry.tools.spectrum.preprocess()}}} allows using tapers through its \code{tapering} keyword.

\begin{notice}{warning}{Warning:}
though it is taken into account in {\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.spectral_analysis]{\code{altimetry.tools.spectrum.spectral\_analysis()}}}, energy loss caused by the tapering may not be properly resolved.

It may be therefore necessary to correct this loss by multiplying the tapered spectrum by the ratio of energies of both spectra $\frac{E_{original}}{E_{tapered}}$
\end{notice}


\subparagraph{Notes on AR spectrum (auto-regression methods)}
\label{altimetry.tools.spectrum:notes-on-ar-spectrum-auto-regression-methods}
AR (auto-regressive methods) can be used to model a spectrum from the signal.
\begin{description}
\item[{Such method, as the \textbf{Yule-Walker equations}, can be used to model the spectrum, and therefore:}] \leavevmode\begin{itemize}
\item {} 
clean the spectrum (by having an auto-regression approach)

\item {} 
compute the energy (or power) at any frequency (ie. not being dependant on the length of input array).

\end{itemize}

\end{description}

This approach is made possible through the \code{ARspec} keyword of {\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.spectral_analysis]{\code{altimetry.tools.spectrum.spectral\_analysis()}}} (itself calling {\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.yule_walker_regression]{\code{altimetry.tools.spectrum.yule\_walker\_regression()}}}).


\subparagraph{List of useful functions}
\label{altimetry.tools.spectrum:list-of-useful-functions}\begin{itemize}
\item {} 
{\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.spectral_analysis]{\code{altimetry.tools.spectrum.spectral\_analysis()}}} : Compute the average spectrum over a set of data

\item {} 
{\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.preprocess]{\code{altimetry.tools.spectrum.preprocess()}}} : Preprocess the data to be admissible to spectral analysis

\item {} 
{\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.get_slope]{\code{altimetry.tools.spectrum.get\_slope()}}} : Compute the spectral slope

\item {} 
{\hyperref[altimetry.tools.spectrum:altimetry.tools.spectrum.optimal_AR_spectrum]{\code{altimetry.tools.spectrum.optimal\_AR\_spectrum()}}} : Get the order of the optimal AR spectrum

\end{itemize}


\subparagraph{Functions}
\label{altimetry.tools.spectrum:module-altimetry.tools.spectrum}\label{altimetry.tools.spectrum:functions}\index{altimetry.tools.spectrum (module)}\index{spectral\_analysis() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.spectral_analysis}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{spectral\_analysis}}{\emph{dx}, \emph{Ain}, \emph{tapering=None}, \emph{overlap=None}, \emph{wsize=None}, \emph{alpha=3.0}, \emph{detrend=False}, \emph{normalise=False}, \emph{integration=True}, \emph{average=True}, \emph{ARspec=None}}{}
Spectral\_Analysis :
This function performs a spatial spectral analysis with different options on a time series of SLA profiles.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dx} -- sampling distance

\item {} 
\textbf{Ain} -- 2D table of sla data with time along 2nd axis (NXxNT with NX the spatial length and NT the time length)

\item {} 
\textbf{tapering} -- 
apply tapering to the data
\begin{itemize}
\item {} 
If this keyword is of type bool : apply hamming window.

\item {} 
If this keyword is a string : apply a hamming (`hamm'), hann (`hann'), kaiser-bessel (`kaiser'), kaiser-bessel (`blackman') or no (`none') tapering function.

\item {} 
If this keyword is an \code{numpy.array} object : apply this array as taper.

\end{itemize}


\item {} 
\textbf{overlap} -- overlap coefficient of the windows (0.75 means 75\% overlap).

\item {} 
\textbf{wsize} -- size of the sub-segments.

\item {} 
\textbf{normalise} -- If True, normalise the spectrum by its overall energy content.

\item {} 
\textbf{detrend} -- If True, removes a linear trend to the segmented signal (if tapered) or to the whole signal (if not tapered).

\item {} 
\textbf{integration} -- If True, integrate the spectrum between 2 frequencies.

\item {} 
\textbf{sla} -- data

\end{itemize}

\item[{Returns}] \leavevmode

a spectrum structure

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{esd}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{esd}\PYG{p}{,}       \PYG{c}{\PYGZsh{}Energy Spectral Density}
 \PYG{l+s}{'}\PYG{l+s}{psd}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{psd}\PYG{p}{,}       \PYG{c}{\PYGZsh{}Power Spectral Density}
 \PYG{l+s}{'}\PYG{l+s}{fq}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{fq}\PYG{p}{,}         \PYG{c}{\PYGZsh{}frequency}
 \PYG{l+s}{'}\PYG{l+s}{p}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{p}\PYG{p}{,}           \PYG{c}{\PYGZsh{}wavelength}
 \PYG{l+s}{'}\PYG{l+s}{params}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{params}\PYG{p}{\PYGZcb{}} \PYG{c}{\PYGZsh{}tapering parameters.}
\end{Verbatim}


\item[{Author }] \leavevmode
Renaud DUSSURGET (RD) - LER/PAC, Ifremer

\item[{Change }] \leavevmode
Created by RD, December 2012

\end{description}\end{quote}

\end{fulllineitems}

\index{preprocess() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.preprocess}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{preprocess}}{\emph{lat}, \emph{lon}, \emph{sla}, \emph{N\_min=None}, \emph{per\_min=15.0}, \emph{max\_gap=None}, \emph{leave\_gaps=False}, \emph{remove\_edges=True}, \emph{interp\_over\_continents=False}, \emph{truncate\_if\_continents=True}, \emph{discard\_continental\_gaps=True}, \emph{flag\_interp=False}, \emph{return\_lonlat=False}, \emph{return\_interpolated=False}, \emph{last=True}, \emph{mid=None}, \emph{first=None}, \emph{verbose=1}}{}~\begin{description}
\item[{Preprocessing of the SLA data ::}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{process positions :}] \leavevmode\begin{itemize}
\item {} 
interpolate over gaps

\item {} 
find continents (extend the positions over continents to get the discontinuity)

\item {} 
find track edges

\item {} 
find gap lengths

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{clean SLA data::}] \leavevmode\begin{itemize}
\item {} 
Remove gaps greater than maximum allowed length over which interpolate is OK.

\item {} 
Remove time steps with not enough coverage

\item {} 
get sub-segments of valid data of a given length

\end{itemize}

\end{description}

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{lon} -- longitude

\item {} 
\textbf{lat} -- longitude

\item {} 
\textbf{sla} -- data

\item {} 
\textbf{N\_min} -- Length of subsegments (cf \code{altimetry.tools.spectrum.get\_segments()})

\item {} 
\textbf{per\_min} -- Minimum percentage of valid data to allow.

\item {} 
\textbf{max\_gap} -- Maximum gap length to interpolate over (interpolation is done 1st, THEN long gaps are eliminated)

\item {} 
\textbf{leave\_gaps} -- Leave gaps (equivalent to setting max\_gap to number of points in track).

\item {} 
\textbf{remove\_edges} -- discard data at track edges.

\item {} 
\textbf{truncate\_if\_continents} -- Force truncating data if a continent is found within a segment of data.

\item {} 
\textbf{last} -- Get segments of data sticked to the last point in track (cf \code{altimetry.tools.spectrum.get\_segments()})

\item {} 
\textbf{first} -- Get segments of data sticked to the first point in track (cf \code{altimetry.tools.spectrum.get\_segments()})

\item {} 
\textbf{mid} -- Get segments of data sticked to the middle point in track (cf \code{altimetry.tools.spectrum.get\_segments()})

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_kx() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.get_kx}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{get\_kx}}{\emph{N}, \emph{dx}}{}
GET\_KX
:summary: Returns the frequencies to be used with FFT analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{N} -- number of samples in data

\item {} 
\textbf{dx} -- sampling step

\end{itemize}

\item[{Returns}] \leavevmode
Returns
* k: frequency
* L: length
* imx: index of maximum frequency (for separating positive and negative frequencies)

\item[{Author }] \leavevmode
Renaud DUSSURGET (RD) - LER/PAC, Ifremer

\item[{Change }] \leavevmode
Created by RD, July 2012

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_spec() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.get_spec}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{get\_spec}}{\emph{dx}, \emph{Vin}, \emph{verbose=False}, \emph{gain=1.0}, \emph{integration=True}}{}
GET\_SPEC
:summary: Returns the spectrum of a regularly sampled dataset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{dq} -- sampling interval (1D)

\item {} 
\textbf{V} -- data to analyse (1D).

\end{itemize}

\item[{Note }] \leavevmode
NaN can not be used.

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
psd: Power Spectral Density

\item {} 
esd: Energy Spectral Density

\item {} 
fq: frequency

\item {} 
p: wavelength (period)

\end{itemize}


\item[{Author }] \leavevmode
Renaud DUSSURGET (RD) - LER/PAC, Ifremer

\item[{Change }] \leavevmode
Created by RD, July 2012. Changes
* 29/08/2012 : Changed the computation of frequencies and the spectral integration (spectrum is averaged at mid-width frequencies)
* 30/11/2012 : Outstanding changes : corrected the spectral integration for computing psd and corrected the normalisation

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_segment() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.get_segment}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{get\_segment}}{\emph{sla}, \emph{N}, \emph{last=True}, \emph{mid=None}, \emph{first=None}, \emph{remove\_edges=True}, \emph{truncate\_if\_continents=True}}{}
Intelligent segmentation of data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{remove\_edges} -- discard data at track edges.

\item {} 
\textbf{truncate\_if\_continents} -- Force truncating data if a continent is found within a segment of data.

\item {} 
\textbf{last} -- Get segments of data sticked to the last point in track

\item {} 
\textbf{first} -- Get segments of data sticked to the first point in track

\item {} 
\textbf{mid} -- Get segments of data sticked to the middle point in track

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_slope() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.get_slope}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{get\_slope}}{\emph{fq}, \emph{spec}, \emph{degree=1}, \emph{frange=None}, \emph{threshold=0.0}}{}
GET\_SLOPE
:summary: This function returns the spectral slope of a spectrum using a least-square regression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{fq} -- frequency

\item {} 
\textbf{spec} -- spectrum data

\item {} 
\textbf{degree} -- Degree of the least-square regression model

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
slope : spectral slope (or model coefficients for a higher order model)

\item {} 
intercept : Energy at unit frequency (1 cpkm)

\end{itemize}


\item[{Author }] \leavevmode
Renaud DUSSURGET (RD) - LER/PAC, Ifremer

\item[{Change }] \leavevmode
Created by RD, August 2012

\end{description}\end{quote}

\end{fulllineitems}

\index{yule\_walker() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.yule_walker}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{yule\_walker}}{\emph{acf}, \emph{orden}}{}
Program to solve Yule-Walker equations for AutoRegressive Models
\begin{quote}\begin{description}
\item[{Author }] \leavevmode
XAVI LLORT (llort(at)grahi.upc.edu)

\item[{Created }] \leavevmode
MAY 2007

\item[{Changes }] \leavevmode
adapted to python by R.Dussurget

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{acf} -- AutoCorrelation Function

\item {} 
\textbf{orden} -- Order of the AutoRegressive Model

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
parameters : Parameters

\item {} 
sigma\_e : Standard deviation of the noise term

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{yule\_walker\_regression() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.yule_walker_regression}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{yule\_walker\_regression}}{\emph{dx}, \emph{Y}, \emph{deg}, \emph{res=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{X} -- time vector (disabled)

\item {} 
\textbf{Y} -- stationary time series

\item {} 
\textbf{deg} -- AR model degree

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
a : Yule Walker parameters

\item {} 
sig : Standard deviation of the noise term

\item {} 
aicc : corrected Akaike Information Criterion

\item {} 
gamma : Autocorrelation function

\item {} 
ar : Fitted function

\item {} 
argamma : Fitted autocorrelation function

\item {} 
arspec : Fitted spectral model

\item {} 
F : Relative frequency

\end{itemize}


\end{description}\end{quote}

\begin{notice}{note}{Note:}
To know more about yule-walker and autoregressive methods, see
\begin{itemize}
\item {} 
\href{http://www-ssc.igpp.ucla.edu/personnel/russell/ESS265/Ch9/autoreg/node7.html}{Example of AR(p) model auto-regression using yule-walker equations}

\item {} 
\href{http://www.ee.lamar.edu/gleb/adsp/Lecture\%2009\%20-\%20Parametric\%20SE.pdf}{Other notes on the autoregressive method}

\end{itemize}
\end{notice}
\begin{quote}\begin{description}
\item[{Example }] \leavevmode
IDL example :

\begin{Verbatim}[commandchars=\\\{\}]
\#Define an n-element vector of time-series samples  
X = [6.63, 6.59, 6.46, 6.49, 6.45, 6.41, 6.38, 6.26, 6.09, 5.99, \$  
    5.92, 5.93, 5.83, 5.82, 5.95, 5.91, 5.81, 5.64, 5.51, 5.31, \$  
    5.36, 5.17, 5.07, 4.97, 5.00, 5.01, 4.85, 4.79, 4.73, 4.76]  

\#Compute auto\_correlation function
acorr=A\_CORRELATE(X,INDGEN(30))

\#Solve YW equation to get auto-regression coefficients for AR(2) model
YULE\_WALKER, acorr, 2, a, sig

\#Process auto-regression model
ar=DBLARR(28)
FOR i = 2, 29 DO ar[i-2] = SQRT(a[0]*X[i-1]*X[i] + a[1]*x[i-2]*x[i]+sig*x[i])

\#Compute spectrum
spec=spectrogram(TRANSPOSE(X), INDGEN(N), WSIZE=N, OVERLAY=1.0, DISPLAY\_IMAGE=0)

\#Compute AR(2) model spectrum
ar2=spectrogram(TRANSPOSE(ar), INDGEN(28), WSIZE=28, OVERLAY=1.0, DISPLAY\_IMAGE=0)
\end{Verbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{optimal\_AR\_spectrum() (in module altimetry.tools.spectrum)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.spectrum:altimetry.tools.spectrum.optimal_AR_spectrum}\pysiglinewithargsret{\code{altimetry.tools.spectrum.}\bfcode{optimal\_AR\_spectrum}}{\emph{dx}, \emph{Y}, \emph{ndegrees=None}, \emph{return\_min=True}}{}
Get the optimal order AR spectrum by minimizing the BIC.

\end{fulllineitems}



\paragraph{NetCDF tools}
\label{altimetry.tools.nctools:netcdf-tools}\label{altimetry.tools.nctools::doc}
The {\hyperref[altimetry.tools.nctools:module-altimetry.tools.nctools]{\code{altimetry.tools.nctools}}} module contains tools dedicated to easily handle NetCDF data.
\begin{itemize}\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
\item {} 
{\hyperref[altimetry.tools.nctools:nc]{\emph{An easy to use wrapper to NetCDF4 package - altimetry.tools.nctools.nc}}}

\item {} 
{\hyperref[altimetry.tools.nctools:load-ncvar]{\emph{Addionnal function}}}

\end{itemize}


\subparagraph{An easy to use wrapper to NetCDF4 package - altimetry.tools.nctools.nc}
\label{altimetry.tools.nctools:nc}\label{altimetry.tools.nctools:an-easy-to-use-wrapper-to-netcdf4-package-altimetry-tools-nctools-nc}\index{nc (class in altimetry.tools.nctools)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc}\pysiglinewithargsret{\strong{class }\code{altimetry.tools.nctools.}\bfcode{nc}}{\emph{limit={[}-90.0, 0.0, 90.0, 360.0{]}, verbose=0, zero\_2pi=False, transpose=False, use\_local\_dims=False, **kwargs}}{}
A class for easy-handling of NetCDF data based on \code{NetCDF4} package.
\begin{quote}\begin{description}
\item[{Example }] \leavevmode
To load different sets of data, try these :
\begin{itemize}
\item {} 
Simply load a NetCDF file
\begin{itemize}
\item {} 
The file has standard dimensions (eg. called longitude \& latitude)

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ncr}\PYG{o}{=}\PYG{n}{nc}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{=}\PYG{n}{ncr}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{)}

\PYG{n}{lon}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{lon}
\PYG{n}{lat}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{lat}
\PYG{n}{Z}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{Z}
\end{Verbatim}
\begin{itemize}
\item {} 
We do not want to match for standard dimension names and keep original names

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ncr}\PYG{o}{=}\PYG{n}{nc}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{=}\PYG{n}{ncr}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{,}\PYG{n}{use\PYGZus{}local\PYGZus{}dims}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{n}{lon}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{longitude}
\PYG{n}{lat}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{latitude}
\PYG{n}{Z}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{Z}
\end{Verbatim}
\begin{itemize}
\item {} 
We extract a region and depth range between 2 dates:
\begin{itemize}
\item {} 
We extract between 30-40°N \& 15-20°E (limit).

\item {} 
We extract between 100 \& 200 m deep (depth).

\item {} 
We get data from 2010/01/01 to 2010/01/07 (time).

\item {} 
File has standard dimensions called longitude, latitude, level and time

\end{itemize}

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ncr}\PYG{o}{=}\PYG{n}{nc}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{limit}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{]}
\PYG{n}{depth}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{]}
\PYG{n}{time}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{21915}\PYG{p}{,}\PYG{l+m+mi}{21921}\PYG{p}{]}

\PYG{n}{data}\PYG{o}{=}\PYG{n}{ncr}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{,}
              \PYG{n}{limit}\PYG{o}{=}\PYG{n}{limit}\PYG{p}{,}
              \PYG{n}{timerange}\PYG{o}{=}\PYG{n}{time}\PYG{p}{,}
              \PYG{n}{depthrange}\PYG{o}{=}\PYG{n}{depth}\PYG{p}{)}
  
\PYG{n}{lon}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{lon}
\PYG{n}{lat}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{lat}
\PYG{n}{dep}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{depth}
\PYG{n}{dat}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{time}
\PYG{n}{Z}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{Z}
\end{Verbatim}

\item {} 
More sophisticated example using a file containing bathymetetry data
\begin{itemize}
\item {} 
Load a file and extract a regions and subsample it to a lower resolution
\begin{itemize}
\item {} 
The file has dimensions NbLongitudes \& NbLatitudes.

\item {} 
We extract between 30-40°N \& 15-20°E (limit).

\item {} 
We subsample every 3 points (stride).

\end{itemize}

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{limit}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{]}
\PYG{n}{stride} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{)}
\PYG{n}{ncr}\PYG{o}{=}\PYG{n}{nc}\PYG{p}{(}\PYG{n}{use\PYGZus{}local\PYGZus{}dims}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{bathy}\PYG{o}{=}\PYG{n}{ncr}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{,}
               \PYG{n}{NbLongitudes}\PYG{o}{=}\PYG{p}{(}\PYG{n}{limit}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{limit}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{n}{stride}\PYG{p}{,}
               \PYG{n}{NbLatitudes}\PYG{o}{=}\PYG{p}{(}\PYG{n}{limit}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{limit}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{n}{stride}\PYG{p}{)}
\end{Verbatim}
\begin{itemize}
\item {} 
Then we save the data to another file (output).

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}save data}
\PYG{n}{bathy}\PYG{o}{.}\PYG{n}{write\PYGZus{}nc}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}
\end{Verbatim}
\begin{itemize}
\item {} 
We update the \textbf{history} global attribute of data structure

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}Get attribute structure}
\PYG{n}{attrStr}\PYG{o}{=}\PYG{n}{bathy}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{\PYGZus{}attributes}\PYG{l+s}{'}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
 
\PYG{c}{\PYGZsh{}Get arguments called from the shell}
\PYG{n}{cmd}\PYG{o}{=}\PYG{p}{[}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{basename}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{argv} \PYG{p}{:} \PYG{n}{cmd}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
 
\PYG{c}{\PYGZsh{}update attribute stucture (pop history and concatenate with current commands=.}
\PYG{n}{attrStr}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{history}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{attrStr}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{history}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{'}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{'}\PYG{l+s}{ }\PYG{l+s}{'}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{'}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{'}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
 
\PYG{c}{\PYGZsh{}update NetCDF data structure}
\PYG{n}{bathy}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{\PYGZus{}attributes}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{attrStr}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{}save data}
\PYG{n}{bathy}\PYG{o}{.}\PYG{n}{write\PYGZus{}nc}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}
\end{Verbatim}
\begin{itemize}
\item {} 
We now want to flag all values from variable Z above 0 by setting them to fill\_value and append this modified variable to the output file

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}load variable}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{bathy}\PYG{o}{.}\PYG{n}{Z}

\PYG{c}{\PYGZsh{}flag variable}
\PYG{n}{Z}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{[}\PYG{n}{Z} \PYG{o}{\textgreater{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{False}

\PYG{c}{\PYGZsh{}update attributes}
\PYG{n}{Z}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{\PYGZus{}attributes}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{long\PYGZus{}name}\PYG{l+s}{'}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{flagged bathymetry}\PYG{l+s}{'}

\PYG{c}{\PYGZsh{}append modified bathymetry to a variable named Z\PYGZus{}2 in output file.}
\PYG{n}{bathy}\PYG{o}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{output}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{Z2}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{Z}\PYG{p}{)}
\end{Verbatim}

\end{itemize}

\end{description}\end{quote}
\index{attributes() (altimetry.tools.nctools.nc method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.attributes}\pysiglinewithargsret{\bfcode{attributes}}{\emph{filename}, \emph{**kwargs}}{}
Get attributes of a NetCDF file

:return \{type:dict\} outStr: Attribute structure.
:author: Renaud Dussurget

\end{fulllineitems}

\index{count (altimetry.tools.nctools.nc attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.count}\pysigline{\bfcode{count}\strong{ = None}}
number of files loaded

\end{fulllineitems}

\index{fileid (altimetry.tools.nctools.nc attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.fileid}\pysigline{\bfcode{fileid}\strong{ = None}}
array of file IDs

\end{fulllineitems}

\index{limit (altimetry.tools.nctools.nc attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.limit}\pysigline{\bfcode{limit}\strong{ = None}}
limits of the domain : {[}latmin,lonmin,latmax,lonmax{]} (default = {[}-90.,0.,90.,360.{]})

\begin{notice}{note}{Note:}
limits are automatically reset using \code{altimetry.tools.recale\_limits()}
\end{notice}

\end{fulllineitems}

\index{load() (altimetry.tools.nctools.nc method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.load}\pysiglinewithargsret{\bfcode{load}}{\emph{filename}, \emph{params=None}, \emph{force=False}, \emph{depthrange=None}, \emph{timerange=None}, \emph{output\_is\_dict=True}, \emph{**kwargs}}{}
NetCDF data loader
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{filename} -- file name

\item {} 
\textbf{params} -- a list of variables to load (default : load ALL variables).

\item {} 
\textbf{depthrange} -- if a depth dimension is found, subset along this dimension.

\item {} 
\textbf{timerange} -- if a time dimension is found, subset along this dimension.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
using \code{altimetry.tools.nctools.limit} allows subsetting to a given region.
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{kwargs} -- additional arguments for subsetting along given dimensions.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
You can index along any dimension by providing the name of the dimensions to subsample along. Values associated to the provided keywords should be a length 2 or 3 tuple (min,max,\textless{}step\textgreater{}) (cf. \code{altimetry.data.nctools.load\_ncVar()}).
\end{notice}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{output\_is\_dict} -- data structures are dictionnaries (eg. my\_hydro\_data.variable{[}'data'{]}). If false uses an object with attributes (eg. my\_hydro\_data.variable.data).

\end{description}\end{quote}

:return  \{type:dict\} outStr: Output data structure containing all recorded parameters as specificied by NetCDF file PARAMETER list.
\begin{quote}\begin{description}
\item[{Author }] \leavevmode
Renaud Dussurget

\end{description}\end{quote}

\end{fulllineitems}

\index{message() (altimetry.tools.nctools.nc method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.message}\pysiglinewithargsret{\bfcode{message}}{\emph{MSG\_LEVEL}, \emph{str}}{}
print function wrapper. Print a message depending on the verbose level
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{MSG\_LEVEL} (\emph{\{in\}\{required\}\{type=int\}}) -- level of the message to be compared with self.verbose

\item[{Example }] \leavevmode
display a message

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{This message will be shown for any verbose level}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\item[{Author }] \leavevmode
Renaud DUSSURGET (RD), LER PAC/IFREMER

\item[{Change }] \leavevmode
Added a case for variables with missing dimensions

\end{description}\end{quote}

\end{fulllineitems}

\index{push() (altimetry.tools.nctools.nc method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.push}\pysiglinewithargsret{\bfcode{push}}{\emph{*args}, \emph{**kwargs}}{}
append a variable from a given data structure to the existing dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{file} (\emph{optional}) -- 

\item {} 
\textbf{name} -- variable name

\item {} 
\textbf{value} -- data

\item {} 
\textbf{start} -- broadcast the data to a portion of the dataset. starting index.

\item {} 
\textbf{counts} -- broadcast the data to a portion of the dataset. number of counts.

\item {} 
\textbf{stride} -- broadcast the data to a portion of the dataset. stepping along dimension.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{read() (altimetry.tools.nctools.nc method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.read}\pysiglinewithargsret{\bfcode{read}}{\emph{file\_pattern}, \emph{**kwargs}}{}
Read data from a NetCDF file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{file\_pattern} -- a file pattern to be globbed (\href{http://docs.python.org/library/glob.html\#glob.glob}{\code{glob.glob()}}) or a file list.

\item {} 
\textbf{kwargs} -- additional keywords to be passed to {\hyperref[altimetry.tools.nctools:altimetry.tools.nctools.nc.load]{\code{altimetry.tools.nctools.nc.load()}}} (eg. extracting a subset of the file)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{size (altimetry.tools.nctools.nc attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.size}\pysigline{\bfcode{size}\strong{ = None}}
length of the dataset

\end{fulllineitems}

\index{use\_local\_dims (altimetry.tools.nctools.nc attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.use_local_dims}\pysigline{\bfcode{use\_local\_dims}\strong{ = None}}
this option prevent from trying to detect standard CF dimensions such longitude, latitude, time in the file and keep the original dimensions of the file

\begin{notice}{note}{Note:}
Set this option to True when file is not standard (eg. not following CF conventions).
\end{notice}

\begin{notice}{note}{Note:}
Normal behaviour is to match dimensions (ie. a dimension and the associated variable of the same name) with specific names. Resulting variables associated with these dimensions will be called :
* lon (longitudes) : matches dimensions starting with `lon'
* lat (latitudes) : matches dimensions starting with `lat'
* time (time) : matches dimensions starting with `date' or `time'
* depth (date) : matches dimensions starting with `dep' or `lev'
\end{notice}

\end{fulllineitems}

\index{verbose (altimetry.tools.nctools.nc attribute)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.verbose}\pysigline{\bfcode{verbose}\strong{ = None}}
verbosity level on a scale of 0 (silent) to 4 (max verbosity)

\end{fulllineitems}

\index{write() (altimetry.tools.nctools.nc method)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.nc.write}\pysiglinewithargsret{\bfcode{write}}{\emph{data}, \emph{outfile}, \emph{clobber=False}, \emph{format='NETCDF4'}}{}
Write a netCDF file using a data structure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} -- data structure

\item {} 
\textbf{outfile} -- output file

\item {} 
\textbf{clobber} -- erase file if it already exists

\item {} 
\textbf{format} -- NetCDF file format.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
the data structure requires a ``\_dimensions'' field (dimension structure)
\end{notice}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{Addionnal function}
\label{altimetry.tools.nctools:addionnal-function}\label{altimetry.tools.nctools:load-ncvar}\label{altimetry.tools.nctools:module-altimetry.tools.nctools}\index{altimetry.tools.nctools (module)}\index{load\_ncVar() (in module altimetry.tools.nctools)}

\begin{fulllineitems}
\phantomsection\label{altimetry.tools.nctools:altimetry.tools.nctools.load_ncVar}\pysiglinewithargsret{\code{altimetry.tools.nctools.}\bfcode{load\_ncVar}}{\emph{varName}, \emph{nc=None}, \emph{**kwargs}}{}
Loads a variable from the NetCDF file and saves it as a data structure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{varName} -- variable name

\item[{Keywords kwargs}] \leavevmode
additional keyword arguments for slicing the dataset. Keywords should be named the name of the dimensions to subsample along and associated value should be a length 2 or 3 tuple (min,max,\textless{}step\textgreater{}).

\end{description}\end{quote}

\end{fulllineitems}



\section{Some examples to illustrate py-altimetry functionalities}
\label{Examples:some-examples-to-illustrate-py-altimetry-functionalities}\label{Examples::doc}\begin{itemize}\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
\item {} 
{\hyperref[Examples:data]{\emph{Handle data}}}

\item {} 
{\hyperref[Examples:others]{\emph{Others}}}

\end{itemize}


\subsection{Handle data}
\label{Examples:handle-data}\label{Examples:data}
altimetry tools have a number of classes and function to handle data, mainly based on :mod:NetCDF4 package.

You can find examples of :
\begin{itemize}
\item {} 
{\hyperref[altimetry.tools.nctools:nc]{\emph{Loading NetCDF files}}}

\item {} 
{\hyperref[altimetry.data:alti-data]{\emph{Handle altimetry data using altimetry.data.alti\_data object}}}

\end{itemize}

\begin{notice}{note}{Note:}
Handling data may require knowlegde about how the NetCDF data is structured. You should therefore have a look at:
\begin{itemize}
\item {} 
{\hyperref[altimetry.data:structures]{\emph{informations about data structures}}}

\end{itemize}
\end{notice}


\subsection{Others}
\label{Examples:id1}\label{Examples:others}\begin{itemize}
\item {} 
{\hyperref[altimetry.tools.spectrum:spectral-tools]{\emph{Spectral analysis tools for altimetry data}}}

\end{itemize}


\section{Install, configure \& modify}
\label{Install:install-configure-modify}\label{Install::doc}
Not available yet!


\subsection{Contents:}
\label{Install:contents}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{altimetry.tools.nctools}}, \pageref{altimetry.tools.nctools:module-altimetry.tools.nctools}
\item {\texttt{altimetry.tools.spectrum}}, \pageref{altimetry.tools.spectrum:module-altimetry.tools.spectrum}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
