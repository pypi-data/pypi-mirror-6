# -*- python -*-
#     Copyright 2013, Kay Hayen, mailto:kay.hayen@gmail.com
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#

# The Nuitka scons file. If you have Scons or platform knowledge, please be
# especially invited and contribute improvements.
#
# This file is used to build an executable or shared library. Nuitka needs no
# build process for itself, although it can be compiled using the same method.

import os, subprocess, sys, re, platform

# The directory containing the C++ files generated by Nuitka to be built using
# scons. They are referred to as sources from here on. The ARGUMENTS is what
# Scons provides to us.
source_name = ARGUMENTS[ "name" ]
source_dir = ARGUMENTS[ "source_dir" ]

# The directory containing Nuitka provided C++ files to be built and where it
# should be used.
nuitka_src = ARGUMENTS[ "nuitka_src" ]
static_src = os.path.join( source_dir, "static" )

# We tell Scons that it is a variant to be built, so object files don't end up
# inside that directory which need not be writable.
VariantDir( static_src, os.path.join( nuitka_src, "static_src" ), 0 )

# The name of executable or loadable module that we produce.
result_basepath = ARGUMENTS[ "result_name" ]

def getBoolOption( option_name, default ):
    """ Small helper for boolean mode flags."""
    value = ARGUMENTS.get( option_name, "True" if default else "False" )

    return value.lower() in ( "yes", "true", "1" )

# The directory to use for cache directory.
cache_mode = getBoolOption( "cache_mode", False )

# Module mode: Create a Python extension module, create an executable otherwise.
module_mode = getBoolOption( "module_mode", False )

# Debug mode: Less optimizations, debug information in the resulting binary.
debug_mode = getBoolOption( "debug_mode", False )

# Python version to target.
python_version = ARGUMENTS[ "python_version" ]

# Python debug mode: refcount checking, assertions in CPython core.
python_debug = getBoolOption( "python_debug", False )

# Optimization mode: Optimize as much as currently possible.
optimize_mode = getBoolOption( "optimize_mode", True )

# Full compatibility, even where it's stupid, i.e. do not provide information,
# even if available, in order to assert maximum compatibility. Intended to
# control level of compatability to absurd.
full_compat_mode = getBoolOption( "full_compat", False )

# Experimental mode. Do things that are not yet safe to do.
experimental_mode = getBoolOption( "experimental", False )

# LTO mode: Use link time optimizations of g++ compiler if available and known
# good with the compiler in question. The 4.5 one didn't have good enough
# support, the compiled result would not run correctly.
lto_mode = getBoolOption( "lto_mode", False )

# Windows target mode: Cross compile for Windows or compiling on windows.
win_target = getBoolOption( "win_target", os.name == "nt" )

# Windows subsystem mode: Disable console for windows builds.
win_disable_console = getBoolOption( "win_disable_console", False )

# Unstriped mode: Do not remove debug symbols.
unstriped_mode = getBoolOption( "unstriped_mode", False )

# Clang compiler mode, default on MacOS X and FreeBSD, optional on Linux.
clang_mode = getBoolOption( "clang_mode", False )
if sys.platform == "darwin" or "freebsd" in sys.platform:
    clang_mode = True

# MinGW compiler mode, optional and interesting to Windows only.
mingw_mode = getBoolOption( "mingw_mode", False )

# Frozen modules count
frozen_modules = int( ARGUMENTS.get( "frozen_modules", 0 ) )

# Shared library and compiled modules count
module_count = int( ARGUMENTS.get( "module_count", 0 ) )

# Standalone mode
standalone_mode = getBoolOption( "standalone_mode", False )

# Show scons mode, output information about Scons operation
show_scons_mode = getBoolOption( "show_scons", False )

# Home of Python to be compiled against
python_prefix = ARGUMENTS.get( "python_prefix", None )

# Target arch, should be specified for MSVC to work.
target_arch = ARGUMENTS.get( "target_arch", "x86" )

# Icon for executable (windows-only)
icon_path = ARGUMENTS.get( "icon_path", None )

def createEnvironment( compiler_tools ):
    args = {}

    if os.name == "nt" and \
       not mingw_mode and \
       getExecutablePath( "cl", initial = True ) is not None:
        args[ "MSVC_USE_SCRIPT" ] = False

    return Environment(
        # We want the outside environment to be passed through.
        ENV         = os.environ,

        # Extra tools configuration for scons.
        tools       = compiler_tools,

        # The shared libraries should not be named "lib...", because CPython
        # requires the filename "module_name.so" to load it.
        SHLIBPREFIX = "",

        # Under windows, specify the target architecture is needed for Scons
        # to pick up MSVC.
        TARGET_ARCH = target_arch,

        # If we are on Windows, and MinGW is not enforced, lets see if we can
        # find "cl.exe", and if we do, disable automatic scan.
        **args
    )

def getExecutablePath( filename, initial ):
    # Variable substitution from environment is needed, because this can contain
    # "$CC" which should be looked up too.
    if filename.startswith( "$" ):
        filename = env[ filename[1:] ]

    # Append ".exe" suffix  on Windows if not already present.
    if os.name == "nt" and not filename.lower().endswith( ".exe" ):
        filename += ".exe"

    # Search in "PATH" environment for a file named like it.
    if os.name == "nt":
        separator = ";"
    else:
        separator = ":"

    # Either look at the initial "PATH" as given from the outside or look at the
    # current environment.
    if initial:
        search_path = os.environ[ "PATH" ]
    else:
        search_path = env._dict[ "ENV" ][ "PATH" ]

    # Now check in each path element, much like the shell will.
    path_elements = search_path.split( separator )

    for path_element in path_elements:
        full = os.path.join( path_element, filename )

        if os.path.exists( full ):
            return full
    else:
        return None


if ( os.name != "nt" and win_target ) or mingw_mode:
    # Cross compilation to Windows uses MinGW or you can force it.
    compiler_tools = [ "mingw" ]
else:
    # Everything else should use default.
    compiler_tools = [ "default" ]

# Create Scons environment, the main control tool. Don't include "mingw" on
# Windows immediately, we will default to MSVC if available.
env = createEnvironment(
    compiler_tools = compiler_tools
)

# On Windows, in case MSVC was not found and not previously forced, retry with
# it and use that instead then as a fallback. Using both tools in one call
# seems to not work in terms of fallback when both exist.
if os.name == "nt" and \
   compiler_tools == [ "default" ] and \
   getExecutablePath( env[ "CXX" ], initial = False ) is None:
    env = createEnvironment(
        compiler_tools = [ "mingw" ]
    )

if clang_mode:
    # If requested by the user, use the clang compiler, overriding what was
    # said in environment.
    env[ "CXX" ] = "clang"
elif "CXX" in os.environ:
    # If the environment variable CXX is set, use that.
    env[ "CXX" ] = os.environ[ "CXX" ]

# To work around Windows not supporting command lines of greater than 10K by
# default:
def setupSpawn( env ):
    def spawn( sh, escape, cmd, args, env ):
        # For quoted arguments that end in a backslash, things don't work well
        # this is a workaround for it.
        def removeTrailingSlashQuote( arg ):
            if arg.endswith( r'\"' ):
                return arg[:-1] + '\\"'
            else:
                return arg

        newargs = ' '.join(
            removeTrailingSlashQuote( arg )
            for arg in
            args[1:]
        )
        cmdline = cmd + " " + newargs
        startupinfo = subprocess.STARTUPINFO()

        # CPython2.6 compatibility
        try:
            from subprocess import STARTF_USESHOWWINDOW
        except ImportError:
            from _subprocess import STARTF_USESHOWWINDOW

        startupinfo.dwFlags |= STARTF_USESHOWWINDOW

        proc = subprocess.Popen(
            cmdline,
            stdin       = subprocess.PIPE,
            stdout      = subprocess.PIPE,
            stderr      = subprocess.PIPE,
            startupinfo = startupinfo,
            shell       = False,
            env         = env
        )

        data, err = proc.communicate()
        rv = proc.wait()

        if cmd == "cl":
            data = data[ data.find( "\r\n" ) + 2 : ]

            source_basenames = [
                os.path.basename( source_file )
                for source_file in
                source_files
            ]

            def check( line ):
                return line in ( "",  "Generating Code..." ) or \
                       line in source_basenames

            data = "\r\n".join(
                line
                for line in
                data.split( "\r\n" )
                if not check( line )
            )

        elif cmd == "rc":
            data = data[ data.find( "reserved.\r" ) + 13 : ]

            data = "\n".join(
                line
                for line in
                data.split( "\n")
                if not "identifier truncated to"
            )
        elif cmd == "link" and module_mode:
            data = "\r\n".join(
                line
                for line in
                data.split( "\r\n" )
                if "   Creating library" not in line
            )

        if data.rstrip():
            if not show_scons_mode:
                print cmdline
            print data,

        return rv

    env[ "SPAWN" ] = spawn

def getGccVersion():
    # Update CXXVERSION in env, after we changed it.
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin  = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'[0-9]+(\.[0-9]+){2}', line )

    if match:
        return match.group(0)
    else:
        return None

def getClangVersion():
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin  = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'LLVM ([0-9]+(\.[0-9]+){1})', line )

    if match:
        return match.group(1)

    match = re.search( r'([0-9]+(\.[0-9]+){1})', line )

    if match:
        return match.group(1)
    else:
        return None


# To support cross-compiling under Linux for a windows target, a cross compiler
# linked or installed to /opt/mingw will win over a system installed one.
if win_target and "linux" in sys.platform:
    if os.path.exists( "/opt/mingw/usr/bin/i686-pc-mingw32-g++" ):
        env[ "CXX" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-g++"
        env[ "RC" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-windres"
    else:
        env[ "CXX" ] = "i586-mingw32msvc-g++"
        env[ "RC" ] = "i586-mingw32msvc-windres"

    # Update CXXVERSION in env, after we changed it.
    env[ "CXXVERSION" ] = getGccVersion()

orig_cxx = env[ "CXX" ]
orig_cxx_version = env.get( "CXXVERSION", None )

# Remove "g++" as the compiler, if it's not really existing or not good enough.
if "g++" in env[ "CXX" ]:
    gpp_version = getGccVersion()

    if gpp_version is None or int( getGccVersion().replace( ".", "" ) ) < 440:
        del env[ "CXX" ]

# Detect compiler to be used from supported ones, if there is no usable g++
# link.
if os.name != "nt" and "CXX" not in env:
    for candidate in ( "g++-4.8", "g++-4.7", "g++-4.6", "g++-4.5", "g++-4.4",
                       "clang" ):
        if os.path.exists( os.path.join( "/usr/bin", candidate ) ):
            env[ "CXX" ] = candidate

            if "clang" not in candidate:
                # Update CXXVERSION in env, after we changed it.
                env[ "CXXVERSION" ] = getGccVersion()

            break
    else:
        sys.exit( """\
The g++ compiler '%s' (version %s) doesn't have the sufficient \
version (>= 4.4).""" % ( orig_cxx, orig_cxx_version ) )

if show_scons_mode:
    print "Scons compiler: Using",
    print getExecutablePath( env[ "CXX" ], initial = False )

if "CXX" not in env and \
   getExecutablePath( env[ "CXX" ], initial = False ) is None:
    if os.name == "nt":
        sys.exit( """\
Error, cannot locate suitable C++ compiler. You have the following options:

a) If a suitable Visual Studio version is installed, it not located,
   automatically unless you install pywin32 for the Python installation
   below "%s".

b) To make it find Visual Studio execute from Start Menu the 'Visual Studio
   Command Prompt' or "vcvarsall.bat". That will add Visual Studio to the
   PATH.

b) Install MinGW to 'C:\\MinGW' then it is automatically picked up.
""" % sys.exec_prefix )
    else:
        sys.exit( "Error, cannot locate suitable C++ compiler." )

gcc_mode = "g++" in env[ "CXX" ] or "clang" in env[ "CXX" ]
msvc_mode = win_target and not gcc_mode

if os.name == "nt" and msvc_mode:
    setupSpawn( env )

if os.name == "nt" and gcc_mode and target_arch == "x86_64":
    sys.exit( """\
Error, MinGW does not support 64 bit Python. Use MSVC or 32 bit Python instead.""" )


env[ "BUILD_DIR" ] = source_dir

# Store the file signatures database with the rest of the source files
sconsign_dir = os.path.abspath( os.path.join( source_dir, '.sconsign' ) )

if not os.path.exists( sconsign_dir ):
    os.makedirs( sconsign_dir )

env.SConsignFile( sconsign_dir )

# Support for clang.
if "clang" in env[ "CXX" ]:
    env.Append( CCFLAGS = [ "-w" ] )
    env.Append( CPPDEFINES = [ "_XOPEN_SOURCE" ] )
    env.Append( LINKFLAGS = [ "-lstdc++" ])

    # Don't export anything by default, this should create smaller executables.
    env.Append(
        CCFLAGS = [
            "-fvisibility=hidden",
            "-fvisibility-inlines-hidden"
        ]
    )

    if debug_mode:
        env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    clang_version = getClangVersion()
    clang_version = int( clang_version.replace( ".", "" ) + "0" )

# Support for g++.
if "g++" in env[ "CXX" ]:
    # Don't export anything by default, this should create smaller executables.
    if not win_target:
        env.Append( CCFLAGS = [
            "-fvisibility=hidden",
            "-fvisibility-inlines-hidden"
            ]
        )

    env[ "CXXVERSION" ] = getGccVersion()

    # Version dependent options.
    gpp_version = int( env[ "CXXVERSION" ].replace( ".", "" ) )

    # Enforce the minimum version, selecting a potentially existing g++-4.5
    # binary if it's not high enough. This is esp. useful under Debian which
    # allows all compiler to exist next to each other and where g++ might not be
    # good enough, but g++-4.5 would be.
    if gpp_version < 440:
        sys.exit( """\
The g++ compiler %s (version %s) doesn't have the sufficient \
version (>= 4.5).""" % ( env[ "CXX" ], env[ "CXXVERSION" ] ) )

    # Older g++ complains about aliasing with Py_True and Py_False, but we don't
    # care.
    if gpp_version < 450:
        env.Append( CCFLAGS = [ "-fno-strict-aliasing" ] )

    # For LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gpp_version < 460 and not win_target and \
       os.path.exists( "/usr/bin/g++-4.6" ):
        env[ "CXX" ] = "g++-4.6"
        gpp_version = 460

    # For g++ 4.6 there are some new interesting functions.
    if gpp_version >= 460:
        env.Append( CCFLAGS = [ "-fpartial-inlining" ] )

        if debug_mode:
            env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    # Use link time optimizations so that gcc can help with optimization across
    # files, but unfortunately at this time it seriously slows down the compiled
    # code. This may be because it needs -O3 option to be effective.

    if gpp_version >= 460 and lto_mode:
        env.Append( CCFLAGS = [ "-flto" ] )
        env.Append( LINKFLAGS = [ "-flto=%d" % GetOption( "num_jobs" ) ] )

        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=noreturn" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=pure" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=const" ] )
        # env.Append( CCFLAGS = [ "-Wnoexcept" ] )

        if debug_mode:
            env.Append( LINKFLAGS = [ "-O2" ] )

        if optimize_mode:
            env.Append( LINKFLAGS = [
                "-O3",
                "-fpartial-inlining",
                "-freorder-functions",
            ]
        )

    # Give a warning if LTO mode was specified, but won't be used.
    if lto_mode and gpp_version < 460:
        print >> sys.stderr, "Warning, LTO mode specified, but not available."

    # The var-tracking does not scale, disable it. Should we really need it, we
    # can enable it.
    env.Append( CCFLAGS = [ "-fno-var-tracking" ] )

if msvc_mode:
    env.Append( CCFLAGS = [ "/EHsc", "/J", "/Gd" ] )
    env.Append( LINKFLAGS = [ "/INCREMENTAL:NO" ] )

if debug_mode:

    if gcc_mode:
        # Allow g++/clang to point out all kinds of inconsistency to us by
        # raising an error.
        env.Append( CCFLAGS = [ "-Wall", "-Werror" ] )

        if os.name == "nt":
           env.Append( CCFLAGS = [ "-Wno-error=format", "-Wno-format" ] )
    elif msvc_mode:
        # Disable warnings that system headers already show.
        env.Append( CCFLAGS = [
            "/W4", "/wd4505", "/wd4127", "/wd4100", "/wd4702", "/wd4189",
            "/wd4211"
            ]
        )


    # As for sequence points, we are abusing it, so we have to allow it.
    if "g++" in env[ "CXX" ]:
        env.Append( CCFLAGS = [ "-Wno-sequence-point" ] )

    # Benefit from clang checking memory accesses.
    if "clang" in env[ "CXX" ] and clang_version >= 330:
        env.Append( CCFLAGS = [ "-fsanatize=address,bounds,return" ] )

if full_compat_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_FULL_COMPAT" ] )

if experimental_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_EXPERIMENTAL" ] )

if standalone_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_STANDALONE" ] )

    if win_target:
        if msvc_mode:
            # This is used for "PathRemoveFileSpec" used in standalone mode
            # Windows code.
            env.Append( LIBS = [ "Shlwapi.lib" ] )
    else:
        env.Append( LIBS = [ "dl" ] )

if win_target:
    # For MinGW and cross compilation, we need to tell the subsystem
    # to target as well as to automatically import everything used.
    if gcc_mode:
        env.Append( LINKFLAGS = [ "-Wl,--enable-auto-import" ] )

        if win_disable_console:
            env.Append( LINKFLAGS = [ "-Wl,--subsystem,windows" ] )

    if win_disable_console:
        env.Append( CPPDEFINES = [ "_NUITKA_WINMAIN_ENTRY_POINT" ] )


if python_debug:
    env.Append( CPPDEFINES = [ "Py_DEBUG" ] )

def detectHostMultiarch():
    import commands

    for line in commands.getoutput( "dpkg-architecture" ).split("\n"):
        if line.startswith( "DEB_HOST_MULTIARCH=" ):
            return line.split( "=", 1 )[1]
    else:
        return None

if gcc_mode and "linux" in sys.platform:
    if python_version.startswith( "3.3" ):
        host_multiarch = detectHostMultiarch()

        if host_multiarch is not None:
            env.Append( CCFLAGS = [
                "-I/usr/include/" + host_multiarch + "/python" + python_version
                ]
            )

if os.name == "nt":
    # On Windows, the installation layout is relatively fixed.
    python_header_path = os.path.join( python_prefix, "include" )
else:
    # The python header path is a combination of python version and debug
    # indication, make sure the headers are found by adding it to the C++
    # include path.

    python_header_path = os.path.join(
        python_prefix,
        "include",
        "python" + python_version
    )

if not os.path.exists( os.path.join( python_header_path, "Python.h" ) ):
    # Not, for --python-debug other headers are used than for normal
    # compilation.
    sys.exit(
        """\
Error, no 'Python.h' %s headers can be found at '%s', dependency \
not satisfied!""" % (
            "debug" if python_debug else "development",
            python_header_path
        )
    )

env.Append( CPPPATH  = [ python_header_path ] )

if win_target:
    env.Append( LIBPATH = [ os.path.join( python_prefix, "libs" ) ] )
    env.Append( LIBS = [ "python" + python_version.replace( ".", "" ) ] )
else:
    # Debian and Ubuntu distinguish the system libraries like this.
    if python_debug and \
       python_prefix == "/usr" and \
       not python_version.startswith( "3" ) and \
       platform.dist()[0].lower() in ( "debian", "ubuntu" ):
        env.Append( LIBS = [ "python" + python_version + "_d" ] )
    else:
        env.Append( LIBS = [ "python" + python_version ] )

    if python_prefix != "/usr":
        env.Append( LIBS = [ "dl", "pthread", "util", "m" ] )

        if gcc_mode:
            env.Append( LINKFLAGS = [ "-export-dynamic" ] )


    # Add the python library path to the library path
    python_lib_path = os.path.join( python_prefix, "lib" )
    env.Append( LIBPATH = [ python_lib_path ] )

    # For NetBSD the rpath is required, on FreeBSD it's warned as unused.
    if "netbsd" in sys.platform:
        env.Append( LINKFLAGS = [ "-rpath=" + python_lib_path ] )

nuitka_include = os.path.join( nuitka_src, "include" )
env.Append( CPPPATH = [ source_dir, nuitka_include ] )

if debug_mode or unstriped_mode:
    # On crosscompile, use debug format that wine understands, so we get good
    # tracebacks from it.
    if gcc_mode:
        if win_target and "linux" in sys.platform:
            env.Append( CCFLAGS = [ "-gstabs" ] )
            env.Append( ASFLAGS = [ "-gstabs" ] )
        else:
            env.Append( CCFLAGS = [ "-g" ] )
            env.Append( ASFLAGS = [ "-g" ] )

            if "g++" in env[ "CXX" ]:
                env.Append( CCFLAGS = [ "-feliminate-unused-debug-types" ] )
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/Zi" ] )
        env.Append( LINKFLAGS = [ "/DEBUG" ] )

# When debugging, optimize less than when optimizing, when not remove
# assertions.
if debug_mode:
    if not optimize_mode:
        if gcc_mode or msvc_mode:
            env.Append( CCFLAGS = [ "-O2" ] )
else:
    env.Append( CPPDEFINES = [ "__NUITKA_NO_ASSERT__" ] )

if optimize_mode:
    if gcc_mode:
        env.Append( CCFLAGS = [ "-O3" ] )

        # Check inlining of calls, except in debug mode, where it will all be
        # wrong due to additional code.
        # if not debug_mode:
        #     env.Append( CCFLAGS = [ "-Winline" ] )
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/Ox" ] )


# Set load libpython from binary directory default
if standalone_mode and gcc_mode:
    env.Append( LINKFLAGS = [ "-Wl,-R,'$$ORIGIN'" ] )

env.Append( CPPDEFINES = [ "_NUITKA_FROZEN=%d" % frozen_modules ] )

# Tell compiler to create a shared library or program.
if module_mode:
    if "g++" in env[ "CXX" ]:
        env.Append( CCFLAGS = [ "-shared" ] )
    elif "clang" in env[ "CXX" ]:
        pass
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/LD" ] )
    else:
        assert False
else:
    if msvc_mode:
        env.Append( CCFLAGS = [ "/MT" ])

if module_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_MODULE" ] )
else:
    env.Append( CPPDEFINES = [ "_NUITKA_EXE" ] )

def discoverSourceFiles():
    result = []

    def getStatic( sub_path ):
       return os.path.join( static_src, sub_path.replace( "/", os.path.sep ) )

    result.append( getStatic( "CompiledFunctionType.cpp" ) )
    result.append( getStatic( "CompiledGeneratorType.cpp" ) )
    result.append( getStatic( "CompiledMethodType.cpp" ) )
    result.append( getStatic( "CompiledFrameType.cpp" ) )
    result.append( getStatic( "CompiledCodeHelpers.cpp" ) )
    result.append( getStatic( "InspectPatcher.cpp" ) )

    if win_target:
        result.append( getStatic( "win32_ucontext_src/fibers_win32.cpp" ) )
    elif target_arch == "x86_64":
        result.append( getStatic( "x64_ucontext_src/fibers_x64.cpp" ) )
        result.append( getStatic( "x64_ucontext_src/swapfiber.S" ) )
    elif "arm" in target_arch:
        result.append( getStatic( "arm_ucontext_src/fibers_arm.cpp" ) )
        result.append( getStatic( "arm_ucontext_src/ucontext.cpp" ) )
        result.append( getStatic( "arm_ucontext_src/getcontext.asm"  ) )
    else:
        # Variant based on getcontext/setcontext/swapcontext/makecontext
        result.append( getStatic(  "gen_ucontext_src/fibers_gen.cpp" ) )

    for filename in os.listdir( source_dir ):
        if filename.endswith( ".cpp" ):
            result.append( os.path.join( source_dir, filename ) )

    # If more than one module is included, we need the unfreezer.
    if module_count > 1:
        result.append( getStatic( "MetaPathBasedLoader.cpp" ) )

    return result

source_targets = []

# Prepare the use of a custom specs file for windows targets. We change the used
# specs for linking to avoid the use of the wrong (for CPython) run time
# library.
if msvc_mode and not module_mode:
    rc_content = []

    if python_version < "3.0":
        manifest_filename = os.path.join( source_dir, "resources.manifest" )

        assert 0 == subprocess.call(
            (
                "mt",
                "-inputresource:%s;#1" % os.path.join(
                    python_prefix,
                    "python.exe"
                ),
                "-out:%s" % manifest_filename
            ),
            stdout = subprocess.PIPE
        )

        rc_content.append( "1 RT_MANIFEST resources.manifest" )

    if icon_path:
        rc_content.append(
            '2 ICON MOVEABLE PURE LOADONCALL DISCARDABLE "%s"' % (
                icon_path.replace( "\\", "/" )
            )
        )

    if rc_content:
        rc_filename = os.path.join( source_dir, "resources.rc" )

        rc_file = open( rc_filename, "w" )

        rc_content.insert( 0, '#include "winuser.h"' )
        rc_file.write( "\n".join( rc_content ) )

        rc_file.close()

        source_targets.append(
            env.RES( rc_filename )
        )

source_files = discoverSourceFiles()

if module_mode:
    if win_target:
        module_suffix = ".pyd"
    else:
        module_suffix = ".so"

    env[ "SHLIBSUFFIX" ] = module_suffix

    target = env.SharedLibrary(
        result_basepath,
        source_files  + source_targets
    )
else:
    # Avoid dependency on MinGW libraries.
    if win_target and gcc_mode:
        env.Append( LINKFLAGS = [ "-static-libgcc",  "-static-libstdc++" ] )

    target = env.Program(
        result_basepath + ".exe",
        source_files + source_targets
    )

# Avoid IO for compilation as far as possible.
if gcc_mode:
    env.Append( CCFLAGS = "-pipe" )

if "CCFLAGS" in os.environ:
    env.Append( CCFLAGS = os.environ[ "CCFLAGS" ].split() )

if "LDFLAGS" in os.environ:
    env.Append( LINKFLAGS = os.environ[ "LDFLAGS" ].split() )

# Remove the target file to avoid cases where it falsely didn't get rebuilt.
if os.path.exists( target[0].abspath ):
    os.unlink( target[0].abspath )

if show_scons_mode:
    print "scons: Told to run compilation on %d CPUs." % GetOption( 'num_jobs' )

if cache_mode:
    CacheDir( os.path.join( source_dir, "cache" ) )
    Decider( "MD5" )

Default( target )
