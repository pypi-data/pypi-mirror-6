// Generated by CoffeeScript 1.6.3
(function() {
  var mainApp;

  mainApp = angular.module("MainApp");

  mainApp.controller('ConsoleCtlr', [
    '$scope', '$location', '$route', '$q', '$filter', '$templateCache', 'Configuration', 'AppData', 'AppPref', 'Item', 'Itemizer', 'Minioner', 'Resulter', 'Jobber', 'ArgInfo', 'Runner', 'Wheeler', 'Commander', 'Pagerage', 'SaltApiSrvc', 'SaltApiEvtSrvc', 'SessionStore', '$filter', function($scope, $location, $route, $q, $filter, $templateCache, Configuration, AppData, AppPref, Item, Itemizer, Minioner, Resulter, Jobber, ArgInfo, Runner, Wheeler, Commander, Pagerage, SaltApiSrvc, SaltApiEvtSrvc, SessionStore) {
      $scope.location = $location;
      $scope.route = $route;
      $scope.winLoc = window.location;
      $scope.errorMsg = "";
      $scope.closeAlert = function() {
        return $scope.errorMsg = "";
      };
      $scope.monitorMode = null;
      $scope.graining = false;
      $scope.pinging = false;
      $scope.statusing = false;
      $scope.eventing = false;
      $scope.commanding = false;
      $scope.docSearch = false;
      if (AppData.get('commands') == null) {
        AppData.set('commands', new Itemizer());
      }
      $scope.commands = AppData.get('commands');
      if (AppData.get('jobs') == null) {
        AppData.set('jobs', new Itemizer());
      }
      $scope.jobs = AppData.get('jobs');
      if (AppData.get('minions') == null) {
        AppData.set('minions', new Itemizer());
      }
      $scope.minions = AppData.get('minions');
      if (AppData.get('events') == null) {
        AppData.set('events', new Itemizer());
      }
      $scope.events = AppData.get('events');
      $scope.snagCommand = function(name, cmds) {
        if ($scope.commands.get(name) == null) {
          $scope.commands.set(name, new Commander(name, cmds));
        }
        return $scope.commands.get(name);
      };
      $scope.snagJob = function(jid, cmd) {
        var job;
        if ($scope.jobs.get(jid) == null) {
          job = new Jobber(jid, cmd);
          $scope.jobs.set(jid, job);
        }
        return $scope.jobs.get(jid);
      };
      $scope.snagRunner = function(jid, cmd) {
        var job;
        if ($scope.jobs.get(jid) == null) {
          job = new Runner(jid, cmd);
          $scope.jobs.set(jid, job);
        }
        return $scope.jobs.get(jid);
      };
      $scope.snagWheel = function(jid, cmd) {
        var job;
        if ($scope.jobs.get(jid) == null) {
          job = new Wheeler(jid, cmd);
          $scope.jobs.set(jid, job);
        }
        return $scope.jobs.get(jid);
      };
      $scope.snagMinion = function(mid) {
        if ($scope.minions.get(mid) == null) {
          $scope.minions.set(mid, new Minioner(mid));
        }
        return $scope.minions.get(mid);
      };
      $scope.newPagerage = function(itemCount) {
        return new Pagerage(itemCount);
      };
      $scope.filterage = {
        grains: ["any", "id", "host", "domain", "server_id"],
        grain: "any",
        target: "",
        express: ""
      };
      $scope.setFilterGrain = function(index) {
        $scope.filterage.grain = $scope.filterage.grains[index];
        $scope.setFilterExpress();
        return true;
      };
      $scope.setFilterTarget = function(target) {
        $scope.filterage.target = target;
        $scope.setFilterExpress();
        return true;
      };
      $scope.setFilterExpress = function() {
        var name, regex;
        if ($scope.filterage.grain === "any") {
          regex = RegExp($scope.filterage.target, "i");
          $scope.filterage.express = function(minion) {
            var grain, _i, _len, _ref;
            _ref = minion.grains.values();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              grain = _ref[_i];
              if (angular.isString(grain) && grain.match(regex)) {
                return true;
              }
            }
            return false;
          };
        } else {
          regex = RegExp($scope.filterage.target, "i");
          name = $scope.filterage.grain;
          $scope.filterage.express = function(minion) {
            return minion.grains.get(name).toString().match(regex);
          };
        }
        return true;
      };
      $scope.eventReverse = true;
      $scope.jobReverse = true;
      $scope.commandReverse = false;
      $scope.sortage = {
        targets: ["id", "grains", "ping", "active"],
        target: "id",
        reverse: false
      };
      $scope.setSortTarget = function(index) {
        $scope.sortage.target = $scope.sortage.targets[index];
        return true;
      };
      $scope.sortMinions = function(minion) {
        var result;
        if ($scope.sortage.target === "id") {
          result = minion.grains.get("id");
        } else if ($scope.sortage.target === "grains") {
          result = minion.grains.get($scope.sortage.target) != null;
        } else {
          result = minion[$scope.sortage.target];
        }
        result = result != null ? result : false;
        return result;
      };
      $scope.sortJobs = function(job) {
        var result;
        result = job.jid;
        result = result != null ? result : false;
        return result;
      };
      $scope.sortEvents = function(event) {
        var result;
        result = event.utag;
        result = result != null ? result : false;
        return result;
      };
      $scope.sortCommands = function(command) {
        var result;
        result = command.name;
        result = result != null ? result : false;
        return result;
      };
      $scope.resultKeys = ["retcode", "fail", "success", "done"];
      $scope.expandMode = function(ensual) {
        var x, _i, _len;
        if (angular.isArray(ensual)) {
          for (_i = 0, _len = ensual.length; _i < _len; _i++) {
            x = ensual[_i];
            if (angular.isObject(x)) {
              return 'list';
            }
          }
          return 'vect';
        } else if (angular.isObject(ensual)) {
          return 'dict';
        }
        return 'lone';
      };
      $scope.ensuals = function(ensual) {
        return [ensual];
      };
      $scope.actions = {
        State: {
          highstate: {
            mode: 'async',
            tgt: '*',
            fun: 'state.highstate'
          },
          show_highstate: {
            mode: 'async',
            tgt: '*',
            fun: 'state.show_highstate'
          },
          show_lowstate: {
            mode: 'async',
            tgt: '*',
            fun: 'state.running'
          },
          running: {
            mode: 'async',
            tgt: '*',
            fun: 'state.running'
          }
        },
        Test: {
          ping: {
            mode: 'async',
            tgt: '*',
            fun: 'test.ping'
          },
          echo: {
            mode: 'async',
            tgt: '*',
            fun: 'test.echo',
            arg: ['Hello World']
          },
          conf_test: {
            mode: 'async',
            tgt: '*',
            fun: 'test.conf_test'
          },
          fib: {
            mode: 'async',
            tgt: '*',
            fun: 'test.fib',
            arg: [8]
          },
          collatz: {
            mode: 'async',
            tgt: '*',
            fun: 'test.collatz',
            arg: [8]
          },
          sleep: {
            mode: 'async',
            tgt: '*',
            fun: 'test.sleep',
            arg: ['5']
          },
          rand_sleep: {
            mode: 'async',
            tgt: '*',
            fun: 'test.rand_sleep',
            arg: ['max=10']
          },
          get_opts: {
            mode: 'async',
            tgt: '*',
            fun: 'test.get_opts'
          },
          providers: {
            mode: 'async',
            tgt: '*',
            fun: 'test.providers'
          },
          version: {
            mode: 'async',
            tgt: '*',
            fun: 'test.version'
          },
          versions_information: {
            mode: 'async',
            tgt: '*'
          }
        }
      };
      $scope.ply = function(cmds) {
        var cmd, target, _i, _len;
        target = $scope.command.cmd.tgt !== "" ? $scope.command.cmd.tgt : "*";
        if (!angular.isArray(cmds)) {
          cmds = [cmds];
        }
        for (_i = 0, _len = cmds.length; _i < _len; _i++) {
          cmd = cmds[_i];
          cmd.tgt = target;
        }
        return $scope.action(cmds);
      };
      $scope.command = {
        result: {},
        history: {},
        lastCmds: null,
        parameters: null,
        cmd: {
          mode: 'async',
          fun: '',
          tgt: '*',
          arg: [""],
          expr_form: 'glob'
        },
        size: function(obj) {
          return _.size(obj);
        },
        addArg: function() {
          var _ref;
          this.cmd.arg.push('');
          return (_ref = this.parameters) != null ? _ref.push('Enter Input') : void 0;
        },
        delArg: function() {
          var _ref;
          if (this.cmd.arg.length > 1) {
            this.cmd.arg = this.cmd.arg.slice(0, -1);
          }
          if (((_ref = this.parameters) != null ? _ref.length : void 0) > 0) {
            return this.parameters.pop();
          }
        },
        getArgs: function() {
          var arg;
          return (function() {
            var _i, _len, _ref, _results;
            _ref = this.cmd.arg;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              arg = _ref[_i];
              if (arg !== '') {
                _results.push(arg);
              }
            }
            return _results;
          }).call(this);
        },
        getCmds: function() {
          var cmds;
          if (this.cmd.fun.split(".").length === 3) {
            cmds = [
              {
                fun: this.cmd.fun,
                mode: this.cmd.mode,
                arg: this.getArgs()
              }
            ];
          } else {
            cmds = [
              {
                fun: this.cmd.fun,
                mode: this.cmd.mode,
                tgt: this.cmd.tgt !== "" ? this.cmd.tgt : "",
                arg: this.getArgs(),
                expr_form: this.cmd.expr_form
              }
            ];
          }
          return cmds;
        },
        humanize: function(cmds) {
          var cmd, part;
          if (!cmds) {
            cmds = this.getCmds();
          }
          return ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = cmds.length; _i < _len; _i++) {
              cmd = cmds[_i];
              _results.push(((function() {
                var _j, _len1, _ref, _results1;
                _ref = [cmd.fun, cmd.tgt].concat(cmd.arg);
                _results1 = [];
                for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                  part = _ref[_j];
                  if ((part != null) && part !== '') {
                    _results1.push(part);
                  }
                }
                return _results1;
              })()).join(' '));
            }
            return _results;
          })()).join(',').trim();
        }
      };
      $scope.command.cmd.tgt = "";
      $scope.expressionFormats = {
        Glob: 'glob',
        'Perl Regex': 'pcre',
        List: 'list',
        Grain: 'grain',
        'Grain Perl Regex': 'grain_pcre',
        Pillar: 'pillar',
        'Node Group': 'nodegroup',
        Range: 'range',
        Compound: 'compound'
      };
      $scope.$watch("command.cmd.expr_form", function(newVal, oldVal, scope) {
        if (newVal === oldVal) {
          return;
        }
        if (newVal === 'glob') {
          return $scope.command.cmd.tgt = "*";
        } else {
          return $scope.command.cmd.tgt = "";
        }
      });
      $scope.fixTarget = function() {
        if (($scope.command.cmd.tgt != null) && $scope.command.cmd.expr_form === 'list') {
          return $scope.command.cmd.tgt = $scope.command.cmd.tgt.replace(/,\s+/g, ',');
        }
      };
      $scope.humanize = function(cmds) {
        var cmd, part;
        if (!angular.isArray(cmds)) {
          cmds = [cmds];
        }
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = cmds.length; _i < _len; _i++) {
            cmd = cmds[_i];
            _results.push(((function() {
              var _j, _len1, _ref, _results1;
              _ref = [cmd.fun, cmd.tgt].concat(cmd.arg);
              _results1 = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                part = _ref[_j];
                if ((part != null) && part !== '') {
                  _results1.push(part);
                }
              }
              return _results1;
            })()).join(' '));
          }
          return _results;
        })()).join(',').trim();
      };
      $scope.action = function(cmds) {
        var command;
        $scope.commanding = true;
        if (!cmds) {
          cmds = $scope.command.getCmds();
        }
        command = $scope.snagCommand($scope.humanize(cmds), cmds);
        return SaltApiSrvc.action($scope, cmds).success(function(data, status, headers, config) {
          var index, job, parts, result, results, _i, _len;
          results = data["return"];
          for (index = _i = 0, _len = results.length; _i < _len; index = ++_i) {
            result = results[index];
            if (!_.isEmpty(result)) {
              parts = cmds[index].fun.split(".");
              if (parts.length === 3) {
                if (parts[0] === 'runner') {
                  job = $scope.startRun(result, cmds[index]);
                  command.jobs.set(job.jid, job);
                } else if (parts[0] === 'wheel') {
                  job = $scope.startWheel(result, cmds[index]);
                  command.jobs.set(job.jid, job);
                }
              } else {
                job = $scope.startJob(result, cmds[index]);
                command.jobs.set(job.jid, job);
              }
            }
            $scope.commanding = false;
          }
          return true;
        }).error(function(data, status, headers, config) {
          return $scope.commanding = false;
        });
      };
      $scope.fetchPings = function(target) {
        var cmd;
        target = target ? target : "*";
        cmd = {
          mode: "async",
          fun: "test.ping",
          tgt: target
        };
        $scope.pinging = true;
        SaltApiSrvc.run($scope, [cmd]).success(function(data, status, headers, config) {
          var job, result, _ref;
          result = (_ref = data["return"]) != null ? _ref[0] : void 0;
          if (result) {
            job = $scope.startJob(result, cmd);
          }
          $scope.pinging = false;
          return true;
        }).error(function(data, status, headers, config) {
          return $scope.pinging = false;
        });
        return true;
      };
      $scope.fetchActives = function() {
        var cmd;
        cmd = {
          mode: "async",
          fun: "runner.manage.present"
        };
        $scope.statusing = true;
        SaltApiSrvc.run($scope, [cmd]).success(function(data, status, headers, config) {
          var job, result, _ref;
          result = (_ref = data["return"]) != null ? _ref[0] : void 0;
          if (result) {
            job = $scope.startRun(result, cmd);
            job.commit($q).then(function(donejob) {
              $scope.assignActives(donejob);
              return $scope.$emit("Marshall");
            });
          }
          return true;
        }).error(function(data, status, headers, config) {
          return $scope.statusing = false;
        });
        return true;
      };
      $scope.assignActives = function(job) {
        var activeMinions, inactiveMinions, mid, minion, result, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        _ref = job.results.items();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], mid = _ref1.key, result = _ref1.val;
          if (!result.fail) {
            activeMinions = result["return"];
            inactiveMinions = _.difference($scope.minions.keys(), activeMinions);
            for (_j = 0, _len1 = activeMinions.length; _j < _len1; _j++) {
              mid = activeMinions[_j];
              minion = $scope.snagMinion(mid);
              minion.activize();
            }
            for (_k = 0, _len2 = inactiveMinions.length; _k < _len2; _k++) {
              mid = inactiveMinions[_k];
              minion = $scope.snagMinion(mid);
              minion.unlinkJobs();
              minion.deactivize();
            }
          }
        }
        $scope.statusing = false;
        return job;
      };
      $scope.tagMap = {};
      $scope.lookupJID = function(job_id) {
        var command;
        command = {
          fun: 'runner.jobs.lookup_jid',
          kwarg: {
            jid: job_id
          }
        };
        SaltApiSrvc.run($scope, command).success(function(data, status, headers, config) {
          var result;
          result = data["return"][0];
          return $scope.tagMap[result.tag.split('/')[2]] = job_id;
        });
        return true;
      };
      $scope.cachedJIDs = [];
      $scope.failedCachedJIDs = [];
      $scope.$on("CacheFetch", function(event, edata) {
        if (edata != null) {
          $scope.cachedJIDs = _.difference($scope.cachedJIDs, [edata.jid]);
          if (!edata.success) {
            $scope.failedCachedJIDs.push(edata.jid);
          }
        }
        if ($scope.cachedJIDs.length !== 0) {
          $scope.lookupJID($scope.cachedJIDs[0]);
        }
      });
      $scope.preloadJobCache = function() {
        var command;
        command = {
          fun: 'runner.jobs.list_jobs',
          tgt: []
        };
        SaltApiSrvc.run($scope, command).success(function(data, status, headers, config) {
          var job, result;
          result = data["return"][0];
          job = $scope.startRun(result, command);
          job.commit($q).then(function(donejob) {
            var cmd, jid, val, _ref;
            _ref = donejob.results.items()[0].val.results()[0];
            for (jid in _ref) {
              val = _ref[jid];
              cmd = {
                fun: val.Function
              };
              if (val.Target != null) {
                cmd.tgt = val.Target;
              }
              if (!$scope.jobs.get(jid)) {
                $scope.jobs.set(jid, new Runner(jid, cmd));
                $scope.cachedJIDs.push(jid);
              }
            }
            return $scope.$emit("CacheFetch");
          }, function() {
            $scope.errorMsg = "List All Jobs Failed! Please retry.";
            return true;
          });
          return true;
        });
        return true;
      };
      $scope.fetchGrains = function(target) {
        var cmd, minion, minions;
        cmd = {
          mode: "async",
          fun: "grains.items",
          tgt: target,
          expr_form: 'glob'
        };
        if (target == null) {
          minions = (function() {
            var _i, _len, _ref, _results;
            _ref = $scope.minions.values();
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              minion = _ref[_i];
              if (minion.active === true) {
                _results.push(minion.id);
              }
            }
            return _results;
          })();
          target = minions.join(',');
          cmd.tgt = target;
          cmd.expr_form = 'list';
        }
        $scope.graining = true;
        SaltApiSrvc.run($scope, [cmd]).success(function(data, status, headers, config) {
          var job, result, _ref;
          result = (_ref = data["return"]) != null ? _ref[0] : void 0;
          if (result) {
            job = $scope.startJob(result, cmd);
            job.commit($q).then(function(donejob) {
              return $scope.assignGrains(donejob);
            });
          }
          return true;
        }).error(function(data, status, headers, config) {
          return $scope.graining = false;
        });
        return true;
      };
      $scope.assignGrains = function(job) {
        var grains, mid, minion, result, _i, _len, _ref, _ref1;
        _ref = job.results.items();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], mid = _ref1.key, result = _ref1.val;
          if (!result.fail) {
            grains = result["return"];
            minion = $scope.snagMinion(mid);
            minion.grains.reload(grains, false);
          }
        }
        $scope.graining = false;
        return job;
      };
      $scope.docsLoaded = false;
      $scope.docKeys = [];
      $scope.docSearchResults = '';
      $scope.docs = {};
      $scope.searchDocs = function() {
        var key, matching, matchingDocs;
        if (($scope.command.cmd.fun == null) || !$scope.docSearch || $scope.command.cmd.fun === '') {
          $scope.docSearchResults = '';
          return true;
        }
        matching = _.filter($scope.docKeys, function(key) {
          return key.indexOf($scope.command.cmd.fun.toLowerCase()) !== -1;
        });
        matchingDocs = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = matching.length; _i < _len; _i++) {
            key = matching[_i];
            _results.push(key + "\n" + $scope.docs[key] + "\n");
          }
          return _results;
        })();
        $scope.docSearchResults = matchingDocs.join('');
        return true;
      };
      $scope.isSearchable = function() {
        return $scope.docsLoaded;
      };
      $scope.fetchDocsDone = function(donejob) {
        var key, minion_with_result, minions, results, value;
        results = donejob.results;
        minions = results._data;
        minion_with_result = _.find(minions, function(minion) {
          return minion.val.retcode === 0;
        });
        if (minion_with_result != null) {
          $scope.docs = minion_with_result.val["return"];
          $scope.docKeys = (function() {
            var _ref, _results;
            _ref = $scope.docs;
            _results = [];
            for (key in _ref) {
              value = _ref[key];
              _results.push("" + (key.toLowerCase()));
            }
            return _results;
          })();
          $scope.docsLoaded = true;
        } else {
          $scope.errorMsg = 'Docs not loaded since all minions returned invalid data. Please Check Minions And Retry.';
        }
      };
      $scope.fetchDocsFailed = function() {
        return $scope.errorMsg = 'Failed to fetch Docs. Please check system and retry';
      };
      $scope.fetchDocs = function() {
        var command;
        command = {
          fun: 'sys.doc',
          mode: 'async',
          tgt: '*',
          expr_form: 'glob'
        };
        SaltApiSrvc.run($scope, command).success(function(data, status, headers, config) {
          var job, result, _ref;
          result = (_ref = data["return"]) != null ? _ref[0] : void 0;
          if (result) {
            job = $scope.startJob(result, command);
            job.resolveOnAnyPass = true;
            job.commit($q).then($scope.fetchDocsDone, $scope.fetchDocsFailed);
            return true;
          }
        }).error(function(data, status, headers, config) {
          return false;
        });
        return true;
      };
      $scope.startWheel = function(data, cmd) {
        var jid, job, parts;
        parts = data.tag.split("/");
        jid = parts[2];
        job = $scope.snagWheel(jid, cmd);
        return job;
      };
      $scope.startRun = function(data, cmd) {
        var jid, job, parts;
        parts = data.tag.split("/");
        jid = parts[2];
        job = $scope.snagRunner(jid, cmd);
        return job;
      };
      $scope.startJob = function(result, cmd) {
        var jid, job;
        jid = result.jid;
        job = $scope.snagJob(jid, cmd);
        job.initResults(result.minions);
        return job;
      };
      $scope.processJobEvent = function(jid, kind, edata) {
        var data, job, minion;
        job = $scope.jobs.get(jid);
        job.processEvent(edata);
        data = edata.data;
        if (kind === 'new') {
          job.processNewEvent(data);
        } else if (kind === 'ret') {
          minion = $scope.snagMinion(data.id);
          minion.activize();
          job.linkMinion(minion);
          job.processRetEvent(data);
          job.checkDone();
        } else if (kind === 'prog') {
          minion = $scope.snagMinion(data.id);
          job.linkMinion(minion);
          job.processProgEvent(edata);
        }
        return job;
      };
      $scope.processLookupJID = function(data) {
        var key, result, results, val, _ref, _ref1;
        results = new Itemizer();
        _ref = data["return"];
        for (key in _ref) {
          val = _ref[key];
          result = new Resulter();
          result["return"] = val;
          result.id = key;
          results.set(key, result);
          if (data.success) {
            result.done = true;
            result.success = true;
            result.fail = false;
          }
          if ((_ref1 = $scope.jobs.get($scope.tagMap[data.jid])) != null) {
            _ref1.results = results;
          }
        }
        if (data.success) {
          $scope.jobs.get($scope.tagMap[data.jid]).done = true;
          $scope.jobs.get($scope.tagMap[data.jid]).fail = false;
          $scope.$emit("CacheFetch", {
            succes: true,
            jid: $scope.tagMap[data.jid]
          });
        }
        if (!data.success) {
          $scope.jobs.get($scope.tagMap[data.jid]).done = false;
          $scope.jobs.get($scope.tagMap[data.jid]).fail = true;
          return $scope.$emit("CacheFetch", {
            succes: false,
            jid: $scope.tagMap[data.jid]
          });
        }
      };
      $scope.processRunEvent = function(jid, kind, edata) {
        var data, job;
        job = $scope.jobs.get(jid);
        job.processEvent(edata);
        data = edata.data;
        if (kind === 'new') {
          job.processNewEvent(data);
        } else if (kind === 'ret') {
          if (data.fun === 'runner.jobs.lookup_jid') {
            $scope.processLookupJID(data);
          }
          job.processRetEvent(data);
        }
        return job;
      };
      $scope.processWheelEvent = function(jid, kind, edata) {
        var data, job;
        job = $scope.jobs.get(jid);
        job.processEvent(edata);
        data = edata.data;
        if (kind === 'new') {
          job.processNewEvent(data);
        } else if (kind === 'ret') {
          job.processRetEvent(data);
        }
        return job;
      };
      $scope.processMinionEvent = function(mid, edata) {
        var minion;
        minion = $scope.snagMinion(mid);
        minion.processEvent(edata);
        minion.activize();
        $scope.fetchGrains(mid);
        return minion;
      };
      $scope.processKeyEvent = function(edata) {
        var data, mid, minion;
        data = edata.data;
        mid = data.id;
        minion = $scope.snagMinion(mid);
        if (data.result === true) {
          if (data.act === 'delete') {
            minion.unlinkJobs();
            $scope.minions.del(mid);
          }
        }
        return minion;
      };
      $scope.stamp = function() {
        var date, stamp;
        date = new Date();
        stamp = ["/" + (date.getUTCFullYear()), "-" + (('00' + date.getUTCMonth()).slice(-2)), "-" + (('00' + date.getUTCDate()).slice(-2)), "_" + (('00' + date.getUTCHours()).slice(-2)), ":" + (('00' + date.getUTCMinutes()).slice(-2)), ":" + (('00' + date.getUTCSeconds()).slice(-2)), "." + (('000' + date.getUTCMilliseconds()).slice(-3))].join("");
        return stamp;
      };
      $scope.processSaltEvent = function(edata) {
        var jid, kind, mid, parts;
        if (edata.data._stamp == null) {
          edata.data._stamp = $scope.stamp();
        }
        edata.utag = [edata.tag, edata.data._stamp].join("/");
        edata.data.stamp = edata.data._stamp;
        $scope.events.set(edata.utag, edata);
        parts = edata.tag.split("/");
        if (parts[0] === 'salt') {
          if (parts[1] === 'job') {
            jid = parts[2];
            if (jid !== edata.data.jid) {
              console.log("Bad job event");
              $scope.errorMsg = "Bad job event: JID " + jid + " not match " + edata.data.jid;
              return false;
            }
            $scope.snagJob(jid, edata.data);
            kind = parts[3];
            $scope.processJobEvent(jid, kind, edata);
          } else if (parts[1] === 'run') {
            jid = parts[2];
            if (jid !== edata.data.jid) {
              console.log("Bad run event");
              $scope.errorMsg = "Bad run event: JID " + jid + " not match " + edata.data.jid;
              return false;
            }
            $scope.snagRunner(jid, edata.data);
            kind = parts[3];
            $scope.processRunEvent(jid, kind, edata);
          } else if (parts[1] === 'wheel') {
            jid = parts[2];
            if (jid !== edata.data.jid) {
              console.log("Bad wheel event");
              $scope.errorMsg = "Bad wheel event: JID " + jid + " not match " + edata.data.jid;
              return false;
            }
            $scope.snagWheel(jid, edata.data);
            kind = parts[3];
            $scope.processWheelEvent(jid, kind, edata);
          } else if (parts[1] === 'minion' || parts[1] === 'syndic') {
            mid = parts[2];
            if (mid !== edata.data.id) {
              console.log("Bad minion event");
              $scope.errorMsg = "Bad minion event: MID " + mid + " not match " + edata.data.id;
              return false;
            }
            $scope.processMinionEvent(mid, edata);
          } else if (parts[1] === 'key') {
            $scope.processKeyEvent(edata);
          }
        }
        return edata;
      };
      $scope.openEventStream = function() {
        $scope.eventing = true;
        $scope.eventPromise = SaltApiEvtSrvc.events($scope, $scope.processSaltEvent, "salt/").then(function(data) {
          $scope.$emit('Activate');
          return $scope.eventing = false;
        }, function(data) {
          console.log("Error Opening Event Stream");
          if (SessionStore.get('loggedIn') === false) {
            $scope.errorMsg = "Cannot open event stream! Must login first!";
          } else {
            $scope.errorMsg = "Cannot open event stream!";
          }
          $scope.eventing = false;
          return data;
        });
        return true;
      };
      $scope.closeEventStream = function() {
        SaltApiEvtSrvc.close();
        return true;
      };
      $scope.clearSaltData = function() {
        AppData.set('commands', new Itemizer());
        $scope.commands = AppData.get('commands');
        AppData.set('jobs', new Itemizer());
        $scope.jobs = AppData.get('jobs');
        AppData.set('minions', new Itemizer());
        $scope.minions = AppData.get('minions');
        AppData.set('events', new Itemizer());
        return $scope.events = AppData.get('events');
      };
      $scope.authListener = function(event, loggedIn) {
        if (loggedIn) {
          $scope.openEventStream();
        } else {
          $scope.closeEventStream();
          $scope.clearSaltData();
        }
        return true;
      };
      $scope.activateListener = function(event) {
        $scope.fetchActives();
        $scope.fetchDocs();
        return $scope.preloadJobCache();
      };
      $scope.marshallListener = function(event) {
        return $scope.fetchGrains();
      };
      $scope.$on('ToggleAuth', $scope.authListener);
      $scope.$on('Activate', $scope.activateListener);
      $scope.$on('Marshall', $scope.marshallListener);
      if (!SaltApiEvtSrvc.active && SessionStore.get('loggedIn') === true) {
        $scope.openEventStream();
      }
      $scope.testClick = function(name) {
        return console.log("click " + name);
      };
      $scope.testFocus = function(name) {
        return console.log("focus " + name);
      };
      $scope.removeLookupJidJobs = function(job) {
        return job.name !== 'runner.jobs.lookup_jid';
      };
      $scope.removeArgspecJobs = function(job) {
        return job.name.toLowerCase().indexOf('sys.argspec') !== 0;
      };
      $scope.jobPresentationFilter = function(job) {
        return $scope.removeArgspecJobs(job) && $scope.removeLookupJidJobs(job);
      };
      $scope.setParameters = function(requiredArgs, optionalArgs) {
        $scope.command.requiredArgs = requiredArgs;
        $scope.command.optionalArgs = optionalArgs;
        $scope.fillCommandArgs();
        return true;
      };
      $scope.commandArgs = [];
      $scope.fillCommandArgs = function() {
        $scope.commandArgs = [];
        _.each($scope.command.requiredArgs, function(arg) {
          return $scope.commandArgs.push(new ArgInfo(arg, true));
        });
        _.each($scope.command.optionalArgs, function(arg) {
          return $scope.commandArgs.push(new ArgInfo(arg, false));
        });
        return true;
      };
      $scope.argSpec = function() {
        var cmd;
        cmd = {
          module: $scope.command.cmd.fun,
          client: 'minion',
          mode: 'sync',
          tgt: '*'
        };
        SaltApiSrvc.signature($scope, cmd).success(function(data, status, headers, config) {
          var argspec, cmdData, fun, info, keyData, minions, _ref;
          minions = (_ref = data["return"]) != null ? _ref[0] : void 0;
          argspec = null;
          cmdData = $scope.command.cmd.fun.split('.');
          fun = $scope.command.cmd.fun;
          if (cmdData.length > 2) {
            keyData = [cmdData[1], cmdData[2]];
            fun = keyData.join('.');
            argspec = _.find(minions, function(commandKey) {
              return commandKey[fun] != null;
            });
          } else {
            argspec = _.find(minions, function(minion) {
              return minion[fun] != null;
            });
          }
          if (argspec != null) {
            info = argspec[fun];
            if (info.args != null) {
              if (info.defaults != null) {
                info.args.slice(0, +(info.args.length - info.defaults.length) + 1 || 9e9);
                $scope.setParameters(_.values(info.args.slice(0, +(info.args.length - info.defaults.length) + 1 || 9e9)), _.values(info.args.slice(info.args.length - info.defaults.length + 1)));
              }
            } else {
              $scope.setParameters([], null);
            }
          } else {
            $scope.setParameters(null, null);
          }
          return true;
        }).error(function(data, status, headers, config) {
          $scope.setParameters(null, null);
          return true;
        });
        return true;
      };
      $scope.handleCommandChange = function() {
        $scope.searchDocs();
        return $scope.argSpec();
      };
      $scope.canExecuteCommands = function() {
        return !$scope.commandForm.$invalid && ($scope.command.requiredArgs != null);
      };
      return true;
    }
  ]);

}).call(this);
