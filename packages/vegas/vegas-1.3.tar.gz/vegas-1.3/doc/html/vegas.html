
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>vegas Module &mdash; vegas 1.3 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="vegas 1.3 documentation" href="index.html" />
    <link rel="prev" title="How vegas Works" href="background.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="background.html" title="How vegas Works"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">vegas 1.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="vegas-module">
<h1><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> Module<a class="headerlink" href="#vegas-module" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-vegas"></span><div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The key Python objects supported by the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> module are:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a> &#8212; an object describing a multidimensional integration
operator. These contain information about the integration volume,
but also about optimal remappings of the integration variables based
upon the last integral evaluated using the object.</li>
<li><a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><tt class="xref py py-class docutils literal"><span class="pre">vegas.AdaptiveMap</span></tt></a> &#8212; an object describing the remappings used by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>.</li>
<li><a class="reference internal" href="#vegas.RunningWAvg" title="vegas.RunningWAvg"><tt class="xref py py-class docutils literal"><span class="pre">vegas.RunningWAvg</span></tt></a> &#8212; an object describing the result of a <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> integration.
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> returns the weighted average of the integral estimates
from each <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> iteration as an object of class <a class="reference internal" href="#vegas.RunningWAvg" title="vegas.RunningWAvg"><tt class="xref py py-class docutils literal"><span class="pre">vegas.RunningWAvg</span></tt></a>. These are
Gaussian random variables &#8212; that is, they have a
mean and a standard deviation &#8212; but also contain information about the
iterations <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> used in generating the result.</li>
</ul>
</div></blockquote>
<p>These are described in detail below.</p>
</div>
<div class="section" id="integrator-objects">
<h2>Integrator Objects<a class="headerlink" href="#integrator-objects" title="Permalink to this headline">¶</a></h2>
<p>The central component of the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> package is the integrator class:</p>
<dl class="class">
<dt id="vegas.Integrator">
<em class="property">class </em><tt class="descclassname">vegas.</tt><tt class="descname">Integrator</tt><a class="headerlink" href="#vegas.Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive multidimensional Monte Carlo integration.</p>
<p><a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a> objects make Monte Carlo 
estimates of multidimensional functions <tt class="docutils literal"><span class="pre">f(x)</span></tt>
where <tt class="docutils literal"><span class="pre">x[d]</span></tt> is a point in the integration volume:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="n">integration_region</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>The integator makes <tt class="docutils literal"><span class="pre">nitn</span></tt> estimates of the integral,  each
using at most <tt class="docutils literal"><span class="pre">neval</span></tt> samples of the integrand, as it adapts to
the specific features of the integrand. Successive estimates
typically improve in accuracy until the integrator has fully
adapted. The integrator returns the weighted average of all
<tt class="docutils literal"><span class="pre">nitn</span></tt> estimates, together with an estimate of the statistical
(Monte Carlo) uncertainty in that estimate of the integral. The
result is an object of type <a class="reference internal" href="#vegas.RunningWAvg" title="vegas.RunningWAvg"><tt class="xref py py-class docutils literal"><span class="pre">RunningWAvg</span></tt></a> (which is derived
from <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>).</p>
<p><a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a>s have a large number of parameters but the 
only ones that most people will care about are: the
number <tt class="docutils literal"><span class="pre">nitn</span></tt> of iterations of the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> algorithm;
the maximum number <tt class="docutils literal"><span class="pre">neval</span></tt> of integrand evaluations per
iteration; and the damping parameter <tt class="docutils literal"><span class="pre">alpha</span></tt>, which is used
to slow down the adaptive algorithms when they would otherwise
be unstable (e.g., very peaky integrands). Setting parameter
<tt class="docutils literal"><span class="pre">analyzer=vegas.reporter()</span></tt> is sometimes useful, as well,
since it causes <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> to print (on <tt class="docutils literal"><span class="pre">sys.stdout</span></tt>) 
intermediate results from each iteration, as they are 
produced. This helps when each iteration takes a long time 
to complete (e.g., an hour) because it allows you to 
monitor progress as it is being made (or not).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map</strong> (array or <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><tt class="xref py py-class docutils literal"><span class="pre">vegas.AdaptiveMap</span></tt></a> 
or <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a>) &#8211; <p>The integration region as specified by 
an array <tt class="docutils literal"><span class="pre">map[d,</span> <span class="pre">i]</span></tt> where <tt class="docutils literal"><span class="pre">d</span></tt> is the 
direction and <tt class="docutils literal"><span class="pre">i=0,1</span></tt> specify the lower
and upper limits of integration in direction <tt class="docutils literal"><span class="pre">d</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">map</span></tt> could also be the integration map from 
another <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a>, or that <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a>
itself. In this case the grid is copied from the 
existing integrator.</p>
</li>
<li><strong>nitn</strong> (<em>positive int</em>) &#8211; The maximum number of iterations used to 
adapt to the integrand and estimate its value. The
default value is 10; typical values range from 10
to 20.</li>
<li><strong>neval</strong> (<em>positive int</em>) &#8211; The maximum number of integrand evaluations
in each iteration of the <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> algorithm. Increasing
<tt class="docutils literal"><span class="pre">neval</span></tt> increases the precision: statistical errors should
fall at least as fast as <tt class="docutils literal"><span class="pre">sqrt(1./neval)</span></tt> and often
fall much faster. The default value is 1000; real
problems often require 10&#8211;100 times more evaluations
than this.</li>
<li><strong>alpha</strong> (<em>float</em>) &#8211; Damping parameter controlling the remapping
of the integration variables as <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> adapts to the
integrand. Smaller values slow adaptation, which may be
desirable for difficult integrands. Small or zero <tt class="docutils literal"><span class="pre">alpha</span></tt>s 
are also sometimes useful after the grid has adapted,
to minimize fluctuations away from the optimal grid.
The default value is 0.5.</li>
<li><strong>beta</strong> (<em>float</em>) &#8211; Damping parameter controlling the redistribution
of integrand evaluations across hypercubes in the 
stratified sampling of the integrand (over transformed
variables). Smaller values limit the amount of 
redistribution. The theoretically optimal value is 1;
setting <tt class="docutils literal"><span class="pre">beta=0</span></tt> prevents any redistribution of 
evaluations. The default value is 0.75.</li>
<li><strong>nhcube_vec</strong> (<em>positive int</em>) &#8211; The number of hypercubes (in y space)
whose integration points are combined into a single
vector to be passed to the integrand, all together,
when using <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> in vector mode (see <tt class="docutils literal"><span class="pre">fcntype='vector'</span></tt>
below). The default value is 100. Larger values may be
lead to faster evaluations, but at the cost of 
more memory for internal work arrays.</li>
<li><strong>minimize_mem</strong> (<em>bool</em>) &#8211; When <tt class="docutils literal"><span class="pre">True</span></tt>, <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> minimizes 
internal workspace at the cost of extra evaluations of
the integrand. This can increase execution time by 
50&#8211;100% but might be desirable when the number of 
evaluations is very large (e.g., <tt class="docutils literal"><span class="pre">neval=1e9</span></tt>). Normally
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> uses internal work space that grows in 
proportion to <tt class="docutils literal"><span class="pre">neval</span></tt>. If that work space exceeds
the size of the RAM available to the processor,
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> runs much more slowly. Setting <tt class="docutils literal"><span class="pre">minimize_mem=True</span></tt>
greatly reduces the internal storage used by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>; in 
particular memory becomes independent of <tt class="docutils literal"><span class="pre">neval</span></tt>. The default
setting (<tt class="docutils literal"><span class="pre">minimize_mem=False</span></tt>), however, is much superior 
unless memory becomes a problem. (The large memory is needed 
for adaptive stratified sampling, so memory is not 
an issue if <tt class="docutils literal"><span class="pre">beta=0</span></tt>.)</li>
<li><strong>adapt_to_errors</strong> (<em>bool</em>) &#8211; <p><tt class="docutils literal"><span class="pre">adapt_to_errors=False</span></tt> causes 
<a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> to remap the integration variables to emphasize
regions where <tt class="docutils literal"><span class="pre">|f(x)|</span></tt> is largest. This is 
the default mode.</p>
<p><tt class="docutils literal"><span class="pre">adapt_to_errors=True</span></tt> causes <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> to remap 
variables to emphasize regions where the Monte Carlo
error is largest. This might be superior when 
the number of the number of stratifications in 
the y grid is large (&gt; 50?). It is typically 
useful only in one or two dimensions.</p>
</li>
<li><strong>maxinc_axis</strong> (<em>positive int</em>) &#8211; The maximum number of increments
per axis allowed for the x-space grid. The default 
value is 1000; there is probably little need to use
other values.</li>
<li><strong>max_nhcube</strong> (<em>positive int</em>) &#8211; Maximum number of y-space hypercubes 
used for stratified sampling. Setting <tt class="docutils literal"><span class="pre">max_nhcube=1</span></tt>
turns stratified sampling off, which is probably never 
a good idea. The default setting (5e8) was chosen to 
correspond to the point where internal work arrays 
become comparable in size to the typical amount of RAM 
available to a processor (in a laptop in 2014). 
Internal memory usage is large only when <tt class="docutils literal"><span class="pre">beta&gt;0</span></tt>
and <tt class="docutils literal"><span class="pre">minimize_mem=False</span></tt>; therefore <tt class="docutils literal"><span class="pre">max_nhcube</span></tt> is 
ignored if <tt class="docutils literal"><span class="pre">beta=0</span></tt> or <tt class="docutils literal"><span class="pre">minimize_mem=True</span></tt>.</li>
<li><strong>max_neval_hcube</strong> (<em>positive int</em>) &#8211; Maximum number of integrand evaluations 
per hypercube in the stratification. The default value 
is 1e7. Larger values might allow for more adaptation
(when <tt class="docutils literal"><span class="pre">neval</span></tt> is larger than <tt class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">max_neval_hcube</span></tt>),
but also can result in very large internal work arrays.</li>
<li><strong>fcntype</strong> (<em>str</em>) &#8211; <p>Specifies the default type of integrand.</p>
<p><tt class="docutils literal"><span class="pre">fcntype='scalar'</span></tt> imples that the integrand
is a function <tt class="docutils literal"><span class="pre">f(x)</span></tt> of a single integration
point <tt class="docutils literal"><span class="pre">x[d]</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">fcntype='vector'</span></tt> implies that 
the integrand function takes three arguments:
a list of integration points <tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt>,
where <tt class="docutils literal"><span class="pre">i=0...nx-1</span></tt> labels the integration point
and <tt class="docutils literal"><span class="pre">d</span></tt> labels the direction; a buffer
<tt class="docutils literal"><span class="pre">f[i]</span></tt> into which the corresponding 
integrand values are written; and the number
<tt class="docutils literal"><span class="pre">nx</span></tt> of integration points provided.</p>
<p>The default is <tt class="docutils literal"><span class="pre">fcntype=scalar</span></tt>, but this is 
overridden if the integrand has a <tt class="docutils literal"><span class="pre">fcntype</span></tt> 
attribute. It is also overridden for classes
derived from <a class="reference internal" href="#vegas.VecIntegrand" title="vegas.VecIntegrand"><tt class="xref py py-class docutils literal"><span class="pre">vegas.VecIntegrand</span></tt></a>, which are
treated as <tt class="docutils literal"><span class="pre">fcntype='vector'</span></tt> integrands.</p>
</li>
<li><strong>rtol</strong> (<em>float less than 1</em>) &#8211; Relative error in the integral estimate 
at which point the integrator can stop. The default
value is 0.0 which means that the integrator will
complete all iterations specified by <tt class="docutils literal"><span class="pre">nitn</span></tt>.</li>
<li><strong>atol</strong> (<em>float</em>) &#8211; Absolute error in the integral estimate 
at which point the integrator can stop. The default
value is 0.0 which means that the integrator will
complete all iterations specified by <tt class="docutils literal"><span class="pre">nitn</span></tt>.</li>
<li><strong>analyzer</strong> &#8211; <p>An object with methods</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">analyzer.begin(itn,</span> <span class="pre">integrator)</span></tt><p><tt class="docutils literal"><span class="pre">analyzer.end(itn_result,</span> <span class="pre">result)</span></tt></p>
</div></blockquote>
<p>where: <tt class="docutils literal"><span class="pre">begin(itn,</span> <span class="pre">integrator)</span></tt> is called at the start
of each <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> iteration with <tt class="docutils literal"><span class="pre">itn</span></tt> equal to the 
iteration number and <tt class="docutils literal"><span class="pre">integrator</span></tt> equal to the 
integrator itself; and <tt class="docutils literal"><span class="pre">end(itn_result,</span> <span class="pre">result)</span></tt>
is called at the end of each iteration with 
<tt class="docutils literal"><span class="pre">itn_result</span></tt> equal to the result for that 
iteration and <tt class="docutils literal"><span class="pre">result</span></tt> equal to the cummulative
result of all iterations so far. 
Setting <tt class="docutils literal"><span class="pre">analyzer=vegas.reporter()</span></tt>, for 
example, causes vegas to print out a running report
of its results as they are produced. The default 
is <tt class="docutils literal"><span class="pre">analyzer=None</span></tt>.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a> objects have attributes for each of these parameters.
In addition they have the following methods:</p>
<dl class="method">
<dt id="vegas.Integrator.set">
<tt class="descname">set</tt><big>(</big><em>ka={}</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#vegas.Integrator.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset default parameters in integrator.</p>
<p>Usage is analogous to the constructor
for <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a>: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">old_defaults</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">neval</span><span class="o">=</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>resets the default values for <tt class="docutils literal"><span class="pre">neval</span></tt> and <tt class="docutils literal"><span class="pre">nitn</span></tt>
in <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a> <tt class="docutils literal"><span class="pre">integ</span></tt>. A dictionary, here
<tt class="docutils literal"><span class="pre">old_defaults</span></tt>, is returned. It can be used 
to restore the old defaults using, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integ</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">old_defaults</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vegas.Integrator.settings">
<tt class="descname">settings</tt><big>(</big><em>ngrid=0</em><big>)</big><a class="headerlink" href="#vegas.Integrator.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble summary of integrator settings into string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ngrid</strong> (<em>int</em>) &#8211; Number of grid nodes in each direction 
to include in summary.
The default is 0.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">String containing the settings.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vegas.Integrator.multi">
<tt class="descname">multi</tt><big>(</big><em>fcn</em>, <em>nitn=10</em><big>)</big><a class="headerlink" href="#vegas.Integrator.multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate multiple integrals simultaneously.</p>
<p>This method estimates integrals for arrays (with any shape) of 
integrands using the same integration points for every 
integral. A typical application might look something
like the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">some</span> <span class="n">function</span> <span class="n">of</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">pp</span><span class="p">,</span> <span class="n">pp</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pp</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">Integrator</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="c"># train the integrator on p(x)</span>
<span class="n">training</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>

<span class="c"># compute multiple integrals</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="o">.</span><span class="n">multi</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="o">...</span> <span class="n">use</span> <span class="n">integral</span> <span class="n">estimates</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">...</span>
</pre></div>
</div>
<p>Here the integrator is first trained on function <tt class="docutils literal"><span class="pre">p(x)</span></tt> in 
a normal integration step. The trained integrator is then
applied to function <tt class="docutils literal"><span class="pre">f(x)</span></tt> which returns values for 
three different integrands, arranged in an array.</p>
<p>The number of integration points used and the adaptations 
are carried over from the training step. <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>
does <em>not</em> adapt to <tt class="docutils literal"><span class="pre">f(x)</span></tt> in <tt class="docutils literal"><span class="pre">multi</span></tt>, 
which is why there is a training step.</p>
<p><a class="reference internal" href="#vegas.Integrator.multi" title="vegas.Integrator.multi"><tt class="xref py py-meth docutils literal"><span class="pre">vegas.Integrator.multi()</span></tt></a> also works for vectorized
integrands from classes of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">fvec</span><span class="p">(</span><span class="n">vegas</span><span class="o">.</span><span class="n">VecIntegrand</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="n">are</span> <span class="n">integration</span> <span class="n">points</span> <span class="o">...</span>
        <span class="o">...</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="n">are</span> <span class="n">integrand</span> <span class="n">values</span> <span class="o">...</span>
        <span class="k">return</span> <span class="n">f</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">fvec()</span></tt> creates an integrand that accepts multiple
integration points <tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt> and returns multiple integrand 
values <tt class="docutils literal"><span class="pre">f[i,</span> <span class="pre">s1,</span> <span class="pre">s2,</span> <span class="pre">...]</span></tt> where <tt class="docutils literal"><span class="pre">i</span></tt> labels the integration 
point, <tt class="docutils literal"><span class="pre">d</span></tt> labels the direction, and <tt class="docutils literal"><span class="pre">s1,</span> <span class="pre">s2,</span> <span class="pre">...</span></tt> label the
different integrands.</p>
<p>The covariance matrix for the integral estimates is determined
from fluctuations between the <tt class="docutils literal"><span class="pre">nitn</span></tt> iterations. Taking 
<tt class="docutils literal"><span class="pre">nitn=10</span></tt> or <tt class="docutils literal"><span class="pre">20</span></tt> usually results in error estimates 
that are accurate to within 15&#8211;20%.</p>
<p>This method requires the <tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt> module from <tt class="docutils literal"><span class="pre">lsqfit</span></tt>
(install using <tt class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">lsqfit</span></tt>, for example).</p>
</dd></dl>

<dl class="method">
<dt id="vegas.Integrator.random">
<tt class="descname">random</tt><big>(</big><big>)</big><a class="headerlink" href="#vegas.Integrator.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator over integration points and weights.</p>
<p>This method creates an iterator that returns integration
points from <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>, and their corresponding weights in an 
integral. Each point <tt class="docutils literal"><span class="pre">x[d]</span></tt> is accompanied by the weight
assigned to that point by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> when estimating an integral.</p>
<p>Given an <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a> <tt class="docutils literal"><span class="pre">integ</span></tt>, presumably trained on some
integrand, the following code would create a Monte Carlo
estimate of the integral of a possibly different integrand <tt class="docutils literal"><span class="pre">f(x)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random</span><span class="p">():</span>
    <span class="n">integral</span> <span class="o">+=</span> <span class="n">wgt</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">f(x)</span></tt> returns an array <tt class="docutils literal"><span class="pre">f_array[i]</span></tt> corresponding
to the integrand values for points <tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="vegas.Integrator.random_vec">
<tt class="descname">random_vec</tt><big>(</big><big>)</big><a class="headerlink" href="#vegas.Integrator.random_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator over integration points and weights.</p>
<p>This method creates an iterator that returns integration
points from <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>, and their corresponding weights in an 
integral. The points are provided in arrays <tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt> where 
<tt class="docutils literal"><span class="pre">i=0...</span></tt> labels the integration points in a batch 
(or vector) and <tt class="docutils literal"><span class="pre">d=0...</span></tt> labels direction. The corresponding
weights assigned by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> to each point are provided
in an array <tt class="docutils literal"><span class="pre">wgt[i]</span></tt>.</p>
<p>Given an <a class="reference internal" href="#vegas.Integrator" title="vegas.Integrator"><tt class="xref py py-class docutils literal"><span class="pre">vegas.Integrator</span></tt></a> <tt class="docutils literal"><span class="pre">integ</span></tt>, presumably trained on some
integrand, the following code would create a Monte Carlo
estimate of the integral of a possibly different 
(vector) integrand <tt class="docutils literal"><span class="pre">f(x)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">wgt</span> <span class="ow">in</span> <span class="n">integ</span><span class="o">.</span><span class="n">random_vec</span><span class="p">():</span>
    <span class="n">f_array</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">integral</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wgt</span><span class="p">,</span> <span class="n">f_array</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">f(x)</span></tt> returns an array <tt class="docutils literal"><span class="pre">f_array[i]</span></tt> corresponding
to the integrand values for points <tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt>. The points and
weights yielded by the iterator are memoryview objects which
can be converted to <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> arrays, if needed, using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">wgt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wgt</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="adaptivemap-objects">
<h2>AdaptiveMap Objects<a class="headerlink" href="#adaptivemap-objects" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a>’s remapping of the integration variables is handled
by a <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><tt class="xref py py-class docutils literal"><span class="pre">vegas.AdaptiveMap</span></tt></a> object, which maps the original
integration variables x into new variables y in a unit hypercube.
Each direction has its own map specified by a grid in x space:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/077fc49276c2b66f7e124f08dc65028b373fd263.png" alt="x_0 &amp;= a \\
x_1 &amp;= x_0 + \Delta x_0 \\
x_2 &amp;= x_1 + \Delta x_1 \\
\cdots \\
x_N &amp;= x_{N-1} + \Delta x_{N-1} = b"/></p>
</div></div></blockquote>
<p>where <img class="math" src="_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a" style="vertical-align: -1px"/> and <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/> are the limits of integration.
The grid specifies the transformation function at the points
<img class="math" src="_images/math/389b75c77cae997103a92c2f87b4df54980ef6cb.png" alt="y=i/N" style="vertical-align: -3px"/> for <img class="math" src="_images/math/ea2bda8abaf30faa60fe32cd8a1ba7700492c05a.png" alt="i=0,1\ldots N" style="vertical-align: -2px"/>:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/6b9509edd258585c850b9800d6765072ac0f8d90.png" alt="x(y\!=\!i/N) = x_i"/></p>
</div></div></blockquote>
<p>Linear interpolation is used between those points. The Jacobian
for this transformation is:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/f41a2bac182dbef90d7938db505cd4348a3ae642.png" alt="J(y) = J_i = N \Delta x_i"/></p>
</div></div></blockquote>
<p><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> adjusts the increments sizes to optimize its Monte Carlo
estimates of the integral. This involves training the grid. To
illustrate how this is done with <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><tt class="xref py py-class docutils literal"><span class="pre">vegas.AdaptiveMap</span></tt></a>s consider a simple
two dimensional integral over a unit hypercube with integrand:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
<p>We want to create a grid that optimizes uniform Monte Carlo estimates
of the integral in y space. We do this by sampling the integrand
at a large number <tt class="docutils literal"><span class="pre">ny</span></tt> of random points <tt class="docutils literal"><span class="pre">y[j,</span> <span class="pre">d]</span></tt>, where <tt class="docutils literal"><span class="pre">j=0...ny-1</span></tt>
and <tt class="docutils literal"><span class="pre">d=0,1</span></tt>, uniformly distributed throughout the integration
volume in y space. These samples be used to train the grid
using the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">AdaptiveMap</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">ninc</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">ny</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c"># 1000 random y&#39;s</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>            <span class="c"># work space</span>
<span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;intial grid:&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">settings</span><span class="p">())</span>

<span class="k">for</span> <span class="n">itn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>                    <span class="c"># 5 iterations to adapt</span>
   <span class="n">m</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">jac</span><span class="p">)</span>                     <span class="c"># compute x&#39;s and jac</span>

   <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>                  <span class="c"># compute training data</span>
      <span class="n">f2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">jac</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="o">**</span> <span class="mi">2</span>

   <span class="n">m</span><span class="o">.</span><span class="n">add_training_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>           <span class="c"># adapt</span>
   <span class="n">m</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

   <span class="k">print</span><span class="p">(</span><span class="s">&#39;iteration </span><span class="si">%d</span><span class="s">:&#39;</span> <span class="o">%</span> <span class="n">itn</span><span class="p">)</span>
   <span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">settings</span><span class="p">())</span>
</pre></div>
</div>
<p>In each of the 5 iterations, the <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><tt class="xref py py-class docutils literal"><span class="pre">vegas.AdaptiveMap</span></tt></a> adjusts the
map, making increments smaller where <tt class="docutils literal"><span class="pre">f2</span></tt> is larger and
larger where <tt class="docutils literal"><span class="pre">f2</span></tt> is smaller.
The map converges after only 2 or 3 iterations, as
is clear from the output:</p>
<div class="highlight-python"><pre>initial grid:
    grid[ 0] = [ 0.   0.2  0.4  0.6  0.8  1. ]
    grid[ 1] = [ 0.   0.2  0.4  0.6  0.8  1. ]

iteration 0:
    grid[ 0] = [ 0.     0.411  0.618  0.772  0.89   1.   ]
    grid[ 1] = [ 0.     0.508  0.694  0.822  0.911  1.   ]

iteration 1:
    grid[ 0] = [ 0.     0.408  0.611  0.76   0.887  1.   ]
    grid[ 1] = [ 0.     0.542  0.718  0.835  0.922  1.   ]

iteration 2:
    grid[ 0] = [ 0.     0.411  0.612  0.76   0.887  1.   ]
    grid[ 1] = [ 0.     0.551  0.721  0.835  0.924  1.   ]

iteration 3:
    grid[ 0] = [ 0.     0.411  0.612  0.76   0.887  1.   ]
    grid[ 1] = [ 0.     0.554  0.721  0.836  0.924  1.   ]

iteration 4:
    grid[ 0] = [ 0.     0.411  0.612  0.76   0.887  1.   ]
    grid[ 1] = [ 0.     0.555  0.722  0.836  0.925  1.   ]

</pre>
</div>
<p>The grid increments along direction 0 shrink at larger
values <tt class="docutils literal"><span class="pre">x[0]</span></tt>, varying as <tt class="docutils literal"><span class="pre">1/x[0]</span></tt>. Along direction 1
the increments shrink more quickly varying like <tt class="docutils literal"><span class="pre">1/x[1]**2</span></tt>.</p>
<p><a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> samples the integrand in order to estimate the integral.
It uses those same samples to train its <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><tt class="xref py py-class docutils literal"><span class="pre">vegas.AdaptiveMap</span></tt></a> in this
fashion, for use in subsequent iterations of the algorithm.</p>
<dl class="class">
<dt id="vegas.AdaptiveMap">
<em class="property">class </em><tt class="descclassname">vegas.</tt><tt class="descname">AdaptiveMap</tt><a class="headerlink" href="#vegas.AdaptiveMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive map <tt class="docutils literal"><span class="pre">y-&gt;x(y)</span></tt> for multidimensional <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>An <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><tt class="xref py py-class docutils literal"><span class="pre">AdaptiveMap</span></tt></a> defines a multidimensional map <tt class="docutils literal"><span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x(y)</span></tt> 
from the unit hypercube, with <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">y[d]</span> <span class="pre">&lt;=</span> <span class="pre">1</span></tt>, to an arbitrary
hypercube in <tt class="docutils literal"><span class="pre">x</span></tt> space. Each direction is mapped independently 
with a Jacobian that is tunable (i.e., &#8220;adaptive&#8221;).</p>
<p>The map is specified by a grid in <tt class="docutils literal"><span class="pre">x</span></tt>-space that, by definition, 
maps into a uniformly spaced grid in <tt class="docutils literal"><span class="pre">y</span></tt>-space. The nodes of 
the grid are specified by <tt class="docutils literal"><span class="pre">grid[d,</span> <span class="pre">i]</span></tt> where d is the 
direction (<tt class="docutils literal"><span class="pre">d=0,1...dim-1</span></tt>) and <tt class="docutils literal"><span class="pre">i</span></tt> labels the grid point
(<tt class="docutils literal"><span class="pre">i=0,1...N</span></tt>). The mapping for a specific point <tt class="docutils literal"><span class="pre">y</span></tt> into
<tt class="docutils literal"><span class="pre">x</span></tt> space is:</p>
<div class="highlight-python"><pre>y[d] -&gt; x[d] = grid[d, i(y[d])] + inc[d, i(y[d])] * delta(y[d])</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">i(y)=floor(y*N</span></tt>), <tt class="docutils literal"><span class="pre">delta(y)=y*N</span> <span class="pre">-</span> <span class="pre">i(y)</span></tt>, and
<tt class="docutils literal"><span class="pre">inc[d,</span> <span class="pre">i]</span> <span class="pre">=</span> <span class="pre">grid[d,</span> <span class="pre">i+1]</span> <span class="pre">-</span> <span class="pre">grid[d,</span> <span class="pre">i]</span></tt>. The Jacobian for this map,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dx</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">/</span><span class="n">dy</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">inc</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">d</span><span class="p">])]</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span>
</pre></div>
</div>
<p>is piece-wise constant and proportional to the <tt class="docutils literal"><span class="pre">x</span></tt>-space grid 
spacing. Each increment in the <tt class="docutils literal"><span class="pre">x</span></tt>-space grid maps into an increment of 
size <tt class="docutils literal"><span class="pre">1/N</span></tt> in the corresponding <tt class="docutils literal"><span class="pre">y</span></tt> space. So regions in 
<tt class="docutils literal"><span class="pre">x</span></tt> space where <tt class="docutils literal"><span class="pre">inc[d,</span> <span class="pre">i]</span></tt> is small are stretched out
in <tt class="docutils literal"><span class="pre">y</span></tt> space, while larger increments are compressed.</p>
<p>The <tt class="docutils literal"><span class="pre">x</span></tt> grid for an <a class="reference internal" href="#vegas.AdaptiveMap" title="vegas.AdaptiveMap"><tt class="xref py py-class docutils literal"><span class="pre">AdaptiveMap</span></tt></a> can be specified explicitly
when the map is created: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">AdaptiveMap</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>creates a two-dimensional map where the <tt class="docutils literal"><span class="pre">x[0]</span></tt> interval <tt class="docutils literal"><span class="pre">(0,0.1)</span></tt>
and <tt class="docutils literal"><span class="pre">(0.1,1)</span></tt> map into the <tt class="docutils literal"><span class="pre">y[0]</span></tt> intervals <tt class="docutils literal"><span class="pre">(0,0.5)</span></tt> and 
<tt class="docutils literal"><span class="pre">(0.5,1)</span></tt> respectively, while <tt class="docutils literal"><span class="pre">x[1]</span></tt> intervals <tt class="docutils literal"><span class="pre">(-1,0)</span></tt> 
and <tt class="docutils literal"><span class="pre">(0,1)</span></tt> map into <tt class="docutils literal"><span class="pre">y[1]</span></tt> intervals <tt class="docutils literal"><span class="pre">(0,0.5)</span></tt> and  <tt class="docutils literal"><span class="pre">(0.5,1)</span></tt>.</p>
<p>More typically an initially uniform map is trained with data 
<tt class="docutils literal"><span class="pre">f[j]</span></tt> corresponding to <tt class="docutils literal"><span class="pre">ny</span></tt> points <tt class="docutils literal"><span class="pre">y[j,</span> <span class="pre">d]</span></tt>,
with <tt class="docutils literal"><span class="pre">j=0...ny-1</span></tt>, uniformly distributed in y space: 
for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span><span class="o">.</span><span class="n">add_training_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">m.adapt(alpha=1.5)</span></tt> shrinks grid increments where <tt class="docutils literal"><span class="pre">f[j]</span></tt>
is large, and expands them where <tt class="docutils literal"><span class="pre">f[j]</span></tt> is small. Typically 
one has to iterate over several sets of <tt class="docutils literal"><span class="pre">y</span></tt>s and <tt class="docutils literal"><span class="pre">f</span></tt>s 
before the grid has fully adapted.</p>
<p>The speed with which the grid adapts is determined by parameter <tt class="docutils literal"><span class="pre">alpha</span></tt>.
Large (positive) values imply rapid adaptation, while small values (much
less than one) imply slow adaptation. As in any iterative process, it is
usually a good idea to slow adaptation down in order to avoid
instabilities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grid</strong> &#8211; Initial <tt class="docutils literal"><span class="pre">x</span></tt> grid, where <tt class="docutils literal"><span class="pre">grid[d,</span> <span class="pre">i]</span></tt> is the <tt class="docutils literal"><span class="pre">i</span></tt>-th 
node in direction <tt class="docutils literal"><span class="pre">d</span></tt>.</li>
<li><strong>ninc</strong> (<tt class="docutils literal"><span class="pre">int</span></tt> or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Number of increments along each axis of the <tt class="docutils literal"><span class="pre">x</span></tt> grid. 
A new grid is generated if <tt class="docutils literal"><span class="pre">ninc</span></tt> differs from <tt class="docutils literal"><span class="pre">grid.shape[1]</span></tt>.
The new grid is designed to give the same Jacobian <tt class="docutils literal"><span class="pre">dx(y)/dy</span></tt>
as the original grid. The default value, <tt class="docutils literal"><span class="pre">ninc=None</span></tt>,  leaves 
the grid unchanged.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="vegas.AdaptiveMap.dim">
<tt class="descname">dim</tt><a class="headerlink" href="#vegas.AdaptiveMap.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of dimensions.</p>
</dd></dl>

<dl class="attribute">
<dt id="vegas.AdaptiveMap.ninc">
<tt class="descname">ninc</tt><a class="headerlink" href="#vegas.AdaptiveMap.ninc" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of increments along each grid axis.</p>
</dd></dl>

<dl class="attribute">
<dt id="vegas.AdaptiveMap.grid">
<tt class="descname">grid</tt><a class="headerlink" href="#vegas.AdaptiveMap.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>The nodes of the grid defining the maps are <tt class="docutils literal"><span class="pre">self.grid[d,</span> <span class="pre">i]</span></tt>
where <tt class="docutils literal"><span class="pre">d=0...</span></tt> specifies the direction and <tt class="docutils literal"><span class="pre">i=0...self.ninc</span></tt>
the node.</p>
</dd></dl>

<dl class="attribute">
<dt id="vegas.AdaptiveMap.inc">
<tt class="descname">inc</tt><a class="headerlink" href="#vegas.AdaptiveMap.inc" title="Permalink to this definition">¶</a></dt>
<dd><p>The increment widths of the grid:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">inc</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vegas.AdaptiveMap.adapt">
<tt class="descname">adapt</tt><big>(</big><em>alpha=0.0</em>, <em>ninc=None</em><big>)</big><a class="headerlink" href="#vegas.AdaptiveMap.adapt" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapt grid to accumulated training data.</p>
<p><tt class="docutils literal"><span class="pre">self.adapt(...)</span></tt> projects the training data onto
each axis independently and maps it into <tt class="docutils literal"><span class="pre">x</span></tt> space.
It shrinks <tt class="docutils literal"><span class="pre">x</span></tt>-grid increments in regions where the
projected training data is large, and grows increments
where the projected data is small. The grid along 
any direction is unchanged if the training data 
is constant along that direction.</p>
<p>The number of increments along a direction can be 
changed by setting parameter <tt class="docutils literal"><span class="pre">ninc</span></tt>.</p>
<p>The grid does not change if no training data has 
been accumulated, unless <tt class="docutils literal"><span class="pre">ninc</span></tt> is specified, in 
which case the number of increments is adjusted 
while preserving the relative density of increments 
at different values of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>alpha</strong> (<em>double or None</em>) &#8211; Determines the speed with which the grid adapts to 
training data. Large (postive) values imply rapid evolution; 
small values (much less than one) imply slow evolution. Typical 
values are of order one. Choosing <tt class="docutils literal"><span class="pre">alpha&lt;0</span></tt> causes adaptation
to the unmodified training data (usually not a good idea).</li>
<li><strong>ninc</strong> (<em>int or None</em>) &#8211; Number of increments along each direction in the 
new grid. The number is unchanged from the old grid if <tt class="docutils literal"><span class="pre">ninc</span></tt>
is omitted (or equals <tt class="docutils literal"><span class="pre">None</span></tt>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vegas.AdaptiveMap.add_training_data">
<tt class="descname">add_training_data</tt><big>(</big><em>y</em>, <em>f</em>, <em>ny=-1</em><big>)</big><a class="headerlink" href="#vegas.AdaptiveMap.add_training_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Add training data <tt class="docutils literal"><span class="pre">f</span></tt> for <tt class="docutils literal"><span class="pre">y</span></tt>-space points <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
<p>Accumulates training data for later use by <tt class="docutils literal"><span class="pre">self.adapt()</span></tt>.
Grid increments will be made smaller in regions where
<tt class="docutils literal"><span class="pre">f</span></tt> is larger than average, and larger where <tt class="docutils literal"><span class="pre">f</span></tt> 
is smaller than average. The grid is unchanged (converged?)
when <tt class="docutils literal"><span class="pre">f</span></tt> is constant across the grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>y</strong> (<em>contiguous 2-d array of floats</em>) &#8211; <tt class="docutils literal"><span class="pre">y</span></tt> values corresponding to the training data. 
<tt class="docutils literal"><span class="pre">y</span></tt> is a contiguous 2-d array, where <tt class="docutils literal"><span class="pre">y[j,</span> <span class="pre">d]</span></tt> 
is for points along direction <tt class="docutils literal"><span class="pre">d</span></tt>.</li>
<li><strong>f</strong> (<em>contiguous 2-d array of floats</em>) &#8211; Training function values. <tt class="docutils literal"><span class="pre">f[j]</span></tt> corresponds to 
point <tt class="docutils literal"><span class="pre">y[j,</span> <span class="pre">d]</span></tt> in <tt class="docutils literal"><span class="pre">y</span></tt>-space.</li>
<li><strong>ny</strong> (<em>int</em>) &#8211; Number of <tt class="docutils literal"><span class="pre">y</span></tt> points: <tt class="docutils literal"><span class="pre">y[j,</span> <span class="pre">d]</span></tt> for <tt class="docutils literal"><span class="pre">d=0...dim-1</span></tt>
and <tt class="docutils literal"><span class="pre">j=0...ny-1</span></tt>. <tt class="docutils literal"><span class="pre">ny</span></tt> is set to <tt class="docutils literal"><span class="pre">y.shape[0]</span></tt> if it is
omitted (or negative).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vegas.AdaptiveMap.__call__">
<tt class="descname">__call__</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#vegas.AdaptiveMap.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">x</span></tt> values corresponding to <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">y</span></tt> can be a single <tt class="docutils literal"><span class="pre">dim</span></tt>-dimensional point, or it 
can be an array <tt class="docutils literal"><span class="pre">y[i,j,</span> <span class="pre">...,</span> <span class="pre">d]</span></tt> of such points (<tt class="docutils literal"><span class="pre">d=0..dim-1</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="vegas.AdaptiveMap.jac">
<tt class="descname">jac</tt><big>(</big><em>y</em><big>)</big><a class="headerlink" href="#vegas.AdaptiveMap.jac" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the map&#8217;s Jacobian at <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">y</span></tt> can be a single <tt class="docutils literal"><span class="pre">dim</span></tt>-dimensional point, or it 
can be an array <tt class="docutils literal"><span class="pre">y[d,i,j,...]</span></tt> of such points (<tt class="docutils literal"><span class="pre">d=0..dim-1</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="vegas.AdaptiveMap.make_uniform">
<tt class="descname">make_uniform</tt><big>(</big><em>ninc=None</em><big>)</big><a class="headerlink" href="#vegas.AdaptiveMap.make_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the grid with a uniform grid.</p>
<p>The new grid has <tt class="docutils literal"><span class="pre">ninc</span></tt> increments along each direction if 
<tt class="docutils literal"><span class="pre">ninc</span></tt> is specified. Otherwise it has the same number of 
increments as the old grid.</p>
</dd></dl>

<dl class="method">
<dt id="vegas.AdaptiveMap.map">
<tt class="descname">map</tt><big>(</big><em>y</em>, <em>x</em>, <em>jac</em>, <em>ny=-1</em><big>)</big><a class="headerlink" href="#vegas.AdaptiveMap.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map y to x, where jac is the Jacobian.</p>
<p><tt class="docutils literal"><span class="pre">y[j,</span> <span class="pre">d]</span></tt> is an array of <tt class="docutils literal"><span class="pre">ny</span></tt> <tt class="docutils literal"><span class="pre">y</span></tt>-values for direction <tt class="docutils literal"><span class="pre">d</span></tt>.
<tt class="docutils literal"><span class="pre">x[j,</span> <span class="pre">d]</span></tt> is filled with the corresponding <tt class="docutils literal"><span class="pre">x</span></tt> values,
and <tt class="docutils literal"><span class="pre">jac[j]</span></tt> is filled with the corresponding Jacobian 
values. <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">jac</span></tt> must be preallocated: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
<span class="n">jac</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>y</strong> (<em>contiguous 2-d array of floats</em>) &#8211; <tt class="docutils literal"><span class="pre">y</span></tt> values to be mapped. <tt class="docutils literal"><span class="pre">y</span></tt> is a contiguous 2-d array,
where <tt class="docutils literal"><span class="pre">y[j,</span> <span class="pre">d]</span></tt> contains values for points along direction <tt class="docutils literal"><span class="pre">d</span></tt>.</li>
<li><strong>x</strong> (<em>contiguous 2-d array of floats</em>) &#8211; Container for <tt class="docutils literal"><span class="pre">x</span></tt> values corresponding to <tt class="docutils literal"><span class="pre">y</span></tt>.</li>
<li><strong>jac</strong> (<em>contiguous 1-d array of floats</em>) &#8211; Container for Jacobian values corresponding to <tt class="docutils literal"><span class="pre">y</span></tt>.</li>
<li><strong>ny</strong> (<em>int</em>) &#8211; Number of <tt class="docutils literal"><span class="pre">y</span></tt> points: <tt class="docutils literal"><span class="pre">y[j,</span> <span class="pre">d]</span></tt> for <tt class="docutils literal"><span class="pre">d=0...dim-1</span></tt>
and <tt class="docutils literal"><span class="pre">j=0...ny-1</span></tt>. <tt class="docutils literal"><span class="pre">ny</span></tt> is set to <tt class="docutils literal"><span class="pre">y.shape[0]</span></tt> if it is
omitted (or negative).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vegas.AdaptiveMap.show_grid">
<tt class="descname">show_grid</tt><big>(</big><em>ngrid=40</em>, <em>shrink=False</em><big>)</big><a class="headerlink" href="#vegas.AdaptiveMap.show_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Display plots showing the current grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ngrid</strong> (<em>int</em>) &#8211; The number of grid nodes in each 
direction to include in the plot. The default is 40.</li>
<li><strong>shrink</strong> &#8211; Display entire range of each axis
if <tt class="docutils literal"><span class="pre">False</span></tt>; otherwise shrink range to include
just the nodes being displayed. The default is
<tt class="docutils literal"><span class="pre">False</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Nparam axes:</th><td class="field-body"><p class="first last">List of pairs of directions to use in 
different views of the grid. Using <tt class="docutils literal"><span class="pre">None</span></tt> in 
place of a direction plots the grid for only one
direction. Omitting <tt class="docutils literal"><span class="pre">axes</span></tt> causes a default 
set of pairings to be used.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="vegas.AdaptiveMap.settings">
<tt class="descname">settings</tt><big>(</big><em>ngrid=5</em><big>)</big><a class="headerlink" href="#vegas.AdaptiveMap.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Create string with information about grid nodes.</p>
<p>Creates a string containing the locations of the nodes
in the map grid for each direction. Parameter 
<tt class="docutils literal"><span class="pre">ngrid</span></tt> specifies the maximum number of nodes to print
(spread evenly over the grid).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="other-objects">
<h2>Other Objects<a class="headerlink" href="#other-objects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="vegas.RunningWAvg">
<em class="property">class </em><tt class="descclassname">vegas.</tt><tt class="descname">RunningWAvg</tt><a class="headerlink" href="#vegas.RunningWAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Running weighted average of Monte Carlo estimates.</p>
<p>This class accumulates independent Monte Carlo 
estimates (e.g., of an integral) and combines 
them into a single weighted average. It 
is derived from <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt> (from 
the <tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt> module if it is present) and 
represents a Gaussian random variable.</p>
<dl class="attribute">
<dt id="vegas.RunningWAvg.mean">
<tt class="descname">mean</tt><a class="headerlink" href="#vegas.RunningWAvg.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>The mean value of the weighted average.</p>
</dd></dl>

<dl class="attribute">
<dt id="vegas.RunningWAvg.sdev">
<tt class="descname">sdev</tt><a class="headerlink" href="#vegas.RunningWAvg.sdev" title="Permalink to this definition">¶</a></dt>
<dd><p>The standard deviation of the weighted average.</p>
</dd></dl>

<dl class="attribute">
<dt id="vegas.RunningWAvg.chi2">
<tt class="descname">chi2</tt><a class="headerlink" href="#vegas.RunningWAvg.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p><em>chi**2</em> of weighted average.</p>
</dd></dl>

<dl class="attribute">
<dt id="vegas.RunningWAvg.dof">
<tt class="descname">dof</tt><a class="headerlink" href="#vegas.RunningWAvg.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of degrees of freedom in weighted average.</p>
</dd></dl>

<dl class="attribute">
<dt id="vegas.RunningWAvg.Q">
<tt class="descname">Q</tt><a class="headerlink" href="#vegas.RunningWAvg.Q" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Q</em> or <em>p-value</em> of weighted average&#8217;s <em>chi**2</em>.</p>
</dd></dl>

<dl class="attribute">
<dt id="vegas.RunningWAvg.itn_results">
<tt class="descname">itn_results</tt><a class="headerlink" href="#vegas.RunningWAvg.itn_results" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A list of the results from each iteration.</p>
<dl class="method">
<dt id="vegas.RunningWAvg.add">
<tt class="descname">add</tt><big>(</big><em>g</em><big>)</big><a class="headerlink" href="#vegas.RunningWAvg.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add estimate <tt class="docutils literal"><span class="pre">g</span></tt> to the running average.</p>
</dd></dl>

<dl class="method">
<dt id="vegas.RunningWAvg.summary">
<tt class="descname">summary</tt><big>(</big><big>)</big><a class="headerlink" href="#vegas.RunningWAvg.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble summary of independent results into a string.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vegas.VecIntegrand">
<em class="property">class </em><tt class="descclassname">vegas.</tt><tt class="descname">VecIntegrand</tt><a class="headerlink" href="#vegas.VecIntegrand" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for classes providing vectorized integrands.</p>
<p>A class derived from <tt class="xref py py-class docutils literal"><span class="pre">vegas.VecInterand</span></tt> will normally
provide a <tt class="docutils literal"><span class="pre">__call__(self,</span> <span class="pre">x,</span> <span class="pre">f,</span> <span class="pre">nx)</span></tt> method where:</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt> is a contiguous array where <tt class="docutils literal"><span class="pre">i=0...nx-1</span></tt>
labels different integrtion points and <tt class="docutils literal"><span class="pre">d=0...</span></tt> labels
different directions in the integration space.</p>
<p><tt class="docutils literal"><span class="pre">f[i]</span></tt> is a buffer that is filled with the 
integrand values for points <tt class="docutils literal"><span class="pre">i=0...nx-1</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">nx</span></tt> is the number of integration points.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt> and <tt class="docutils literal"><span class="pre">f[i]</span></tt> are <tt class="docutils literal"><span class="pre">memoryview</span></tt> objects. They 
can be repackaged inside <tt class="docutils literal"><span class="pre">__call__(x,</span> <span class="pre">f,</span> <span class="pre">nx)</span></tt> 
as <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> arrays, if needed, using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)[:</span><span class="n">nx</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">)[:</span><span class="n">nx</span><span class="p">]</span>
</pre></div>
</div>
<p>This causes the <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> arrays to use the storage allocated
internally by <a class="reference internal" href="#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><tt class="xref py py-mod docutils literal"><span class="pre">vegas</span></tt></a> for <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">f</span></tt>, which is what is 
wanted for efficiency.</p>
<p><a class="reference internal" href="#vegas.VecIntegrand" title="vegas.VecIntegrand"><tt class="xref py py-class docutils literal"><span class="pre">vegas.VecIntegrand</span></tt></a> is also used for vectorized integrands
used in <a class="reference internal" href="#vegas.Integrator.multi" title="vegas.Integrator.multi"><tt class="xref py py-meth docutils literal"><span class="pre">vegas.Integrator.multi()</span></tt></a>. The derived class should
then provice a <tt class="docutils literal"><span class="pre">__call__(self,</span> <span class="pre">x)</span></tt> method where again 
<tt class="docutils literal"><span class="pre">x[i,</span> <span class="pre">d]</span></tt> is a contiguous array containing multiple integration 
points, but which now returns an array <tt class="docutils literal"><span class="pre">f[i,</span> <span class="pre">s1,</span> <span class="pre">s2,</span> <span class="pre">...]</span></tt> of 
integrand values where <tt class="docutils literal"><span class="pre">s1,</span> <span class="pre">s2,</span> <span class="pre">...</span></tt> label the different 
integrands (the shape is arbitrary).</p>
<p>Deriving from <a class="reference internal" href="#vegas.VecIntegrand" title="vegas.VecIntegrand"><tt class="xref py py-class docutils literal"><span class="pre">vegas.VecIntegrand</span></tt></a> is the 
easiest way to construct integrands in Cython, and
gives the fastest results.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">vegas</span></tt> Module</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#integrator-objects">Integrator Objects</a></li>
<li><a class="reference internal" href="#adaptivemap-objects">AdaptiveMap Objects</a></li>
<li><a class="reference internal" href="#other-objects">Other Objects</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="background.html"
                        title="previous chapter">How <tt class="docutils literal"><span class="pre">vegas</span></tt> Works</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="background.html" title="How vegas Works"
             >previous</a> |</li>
        <li><a href="index.html">vegas 1.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, G.P. Lepage.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>