<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.core.util &mdash; MDAnalysis 0.8.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.8.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.8.1 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.8.1 documentation" href="../../../index.html" />
    <link rel="up" title="MDAnalysis" href="../../MDAnalysis.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.8.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" accesskey="U">MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for MDAnalysis.core.util</h1><div class="highlight"><pre>
<span class="c"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; encoding: utf-8 -*-</span>
<span class="c"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c">#</span>
<span class="c"># MDAnalysis --- http://mdanalysis.googlecode.com</span>
<span class="c"># Copyright (c) 2006-2011 Naveen Michaud-Agrawal,</span>
<span class="c">#               Elizabeth J. Denning, Oliver Beckstein,</span>
<span class="c">#               and contributors (see website for details)</span>
<span class="c"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c">#</span>
<span class="c"># Please cite your use of MDAnalysis in published work:</span>
<span class="c">#</span>
<span class="c">#     N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and</span>
<span class="c">#     O. Beckstein. MDAnalysis: A Toolkit for the Analysis of</span>
<span class="c">#     Molecular Dynamics Simulations. J. Comput. Chem. 32 (2011), 2319--2327,</span>
<span class="c">#     doi:10.1002/jcc.21787</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Helper functions --- :mod:`MDAnalysis.core.util`</span>
<span class="sd">====================================================</span>

<span class="sd">Small helper functions that don&#39;t fit anywhere else.</span>

<span class="sd">Files and directories</span>
<span class="sd">---------------------</span>

<span class="sd">.. autofunction:: filename</span>
<span class="sd">.. function:: openany(directory[,mode=&#39;r&#39;])</span>

<span class="sd">   Context manager to open a compressed (bzip2, gzip) or plain file</span>
<span class="sd">   (uses :func:`anyopen`).</span>

<span class="sd">.. autofunction:: anyopen</span>

<span class="sd">.. autofunction:: greedy_splitext</span>

<span class="sd">.. autofunction:: which</span>

<span class="sd">.. autofunction:: realpath</span>

<span class="sd">Containers and lists</span>
<span class="sd">--------------------</span>

<span class="sd">.. autofunction:: iterable</span>
<span class="sd">.. autofunction:: asiterable</span>


<span class="sd">File parsing</span>
<span class="sd">------------</span>

<span class="sd">.. autoclass:: FORTRANReader</span>
<span class="sd">   :members:</span>
<span class="sd">.. autodata:: FORTRAN_format_regex</span>


<span class="sd">Data manipulation and handling</span>
<span class="sd">------------------------------</span>

<span class="sd">.. autofunction:: fixedwidth_bins</span>


<span class="sd">Strings</span>
<span class="sd">-------</span>

<span class="sd">.. autofunction:: convert_aa_code</span>
<span class="sd">.. autofunction:: parse_residue</span>
<span class="sd">.. autofunction:: conv_float</span>


<span class="sd">Mathematics and Geometry</span>
<span class="sd">------------------------</span>

<span class="sd">.. autofunction:: normal</span>
<span class="sd">.. autofunction:: norm</span>
<span class="sd">.. autofunction:: angle</span>
<span class="sd">.. autofunction:: dihedral</span>
<span class="sd">.. autofunction:: stp</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s">&quot;restructuredtext en&quot;</span>

<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">bz2</span><span class="o">,</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<div class="viewcode-block" id="filename"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.filename">[docs]</a><span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">keep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a new name that has suffix attached; replaces other extensions.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      *name*</span>
<span class="sd">           filename; extension is replaced unless keep=True</span>
<span class="sd">      *ext*</span>
<span class="sd">           extension</span>
<span class="sd">      *keep*</span>
<span class="sd">           ``False``: replace existing extension; ``True``: keep if exists</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extsep</span><span class="p">):</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">extsep</span> <span class="o">+</span> <span class="n">ext</span>
    <span class="c">#if name.find(ext) &gt; 0:    # normally &gt;= 0 but if we start with &#39;.&#39; then we keep it</span>
    <span class="c">#    return name</span>
    <span class="n">root</span><span class="p">,</span> <span class="n">origext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">origext</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">keep</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span> <span class="o">+</span> <span class="n">ext</span>
    <span class="k">return</span> <span class="n">name</span>
</div>
<span class="nd">@contextmanager</span>
<div class="viewcode-block" id="openany"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.openany">[docs]</a><span class="k">def</span> <span class="nf">openany</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Open the datasource and close it when the context exits.&quot;&quot;&quot;</span>
    <span class="n">stream</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">anyopen</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">stream</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="anyopen"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.anyopen">[docs]</a><span class="k">def</span> <span class="nf">anyopen</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Open datasource (gzipped, bzipped, uncompressed) and return a stream.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">     *datasource*</span>
<span class="sd">        a file or a stream</span>
<span class="sd">     *mode*</span>
<span class="sd">        &#39;r&#39; or &#39;w&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: - make this act as ContextManager (and not return filename)</span>
    <span class="c">#       - need to add binary &#39;b&#39; to mode for compressed files?</span>

    <span class="n">handlers</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;bz2&#39;</span><span class="p">:</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">,</span> <span class="s">&#39;gz&#39;</span><span class="p">:</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">:</span> <span class="nb">file</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;r&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span><span class="s">&#39;next&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span><span class="s">&#39;readline&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">stream</span><span class="o">.</span><span class="n">name</span>  <span class="c"># maybe that does not always work?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;bz2&#39;</span><span class="p">,</span> <span class="s">&#39;gz&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">):</span>   <span class="c"># file == &#39;&#39; should be last</span>
                <span class="n">openfunc</span> <span class="o">=</span> <span class="n">handlers</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">_get_stream</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">openfunc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stream</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;Cannot open </span><span class="si">%(filename)r</span><span class="s"> in mode=</span><span class="si">%(mode)r</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;w&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="s">&#39;write&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">stream</span><span class="o">.</span><span class="n">name</span>  <span class="c"># maybe that does not always work?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">datasource</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">):</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;bz2&#39;</span><span class="p">,</span> <span class="s">&#39;gz&#39;</span><span class="p">):</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>   <span class="c"># anything else but bz2 or gz is just a normal file</span>
            <span class="n">openfunc</span> <span class="o">=</span> <span class="n">handlers</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunc</span><span class="p">(</span><span class="n">datasource</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stream</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;Cannot open </span><span class="si">%(filename)r</span><span class="s"> in mode=</span><span class="si">%(mode)r</span><span class="s"> with type </span><span class="si">%(ext)r</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Sorry, mode=</span><span class="si">%(mode)r</span><span class="s"> is not implemented for </span><span class="si">%(datasource)r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">stream</span><span class="p">,</span> <span class="n">filename</span>
</div>
<span class="k">def</span> <span class="nf">_get_stream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">openfunction</span><span class="o">=</span><span class="nb">file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunction</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">openfunction</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">stream</span>

<div class="viewcode-block" id="greedy_splitext"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.greedy_splitext">[docs]</a><span class="k">def</span> <span class="nf">greedy_splitext</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Split extension in path *p* at the left-most separator.&quot;&quot;&quot;</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">extension</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="n">ext</span> <span class="o">+</span> <span class="n">extension</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">,</span> <span class="n">extension</span>
</div>
<div class="viewcode-block" id="which"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.which">[docs]</a><span class="k">def</span> <span class="nf">which</span><span class="p">(</span><span class="n">program</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine full path of executable *program* on :envvar:`PATH`.</span>

<span class="sd">    (Jay at http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">is_exe</span><span class="p">(</span><span class="n">fpath</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">X_OK</span><span class="p">)</span>
    <span class="n">fpath</span><span class="p">,</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fpath</span><span class="p">:</span>
        <span class="n">real_program</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_exe</span><span class="p">(</span><span class="n">real_program</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">real_program</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&quot;PATH&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pathsep</span><span class="p">):</span>
            <span class="n">exe_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">program</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_exe</span><span class="p">(</span><span class="n">exe_file</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exe_file</span>
    <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="realpath"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.realpath">[docs]</a><span class="k">def</span> <span class="nf">realpath</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Join all args and return the real path, rooted at /.</span>

<span class="sd">    Expands &#39;~&#39;, &#39;~user&#39;, and environment variables such as :envvar`$HOME`.</span>

<span class="sd">    Returns ``None`` if any of the args is ``None``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))))</span>

</div>
<div class="viewcode-block" id="iterable"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.iterable">[docs]</a><span class="k">def</span> <span class="nf">iterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns ``True`` if *obj* can be iterated over and is *not* a  string.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>    <span class="c"># avoid iterating over characters of a string</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;next&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>    <span class="c"># any iterator will do</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>       <span class="c"># anything else that might work</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="asiterable"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.asiterable">[docs]</a><span class="k">def</span> <span class="nf">asiterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns obj so that it can be iterated over; a string is *not* treated as iterable&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">obj</span>

<span class="c">#: Regular expresssion (see :mod:`re`) to parse a simple `FORTRAN edit descriptor`_.</span>
<span class="c">#: ``(?P&lt;repeat&gt;\d?)(?P&lt;format&gt;[IFELAX])(?P&lt;numfmt&gt;(?P&lt;length&gt;\d+)(\.(?P&lt;decimals&gt;\d+))?)?``</span>
<span class="c">#:</span>
<span class="c">#: .. _FORTRAN edit descriptor: http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html</span></div>
<span class="n">FORTRAN_format_regex</span> <span class="o">=</span> <span class="s">&quot;(?P&lt;repeat&gt;\d+?)(?P&lt;format&gt;[IFEAX])(?P&lt;numfmt&gt;(?P&lt;length&gt;\d+)(\.(?P&lt;decimals&gt;\d+))?)?&quot;</span>
<span class="n">_FORTRAN_format_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">FORTRAN_format_regex</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert *s* to a string and return it white-space stripped.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">FixedcolumnEntry</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent an entry at specific fixed columns.</span>

<span class="sd">    Reads from line[start:stop] and converts according to</span>
<span class="sd">    typespecifier.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">convertors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;I&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s">&#39;F&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s">&#39;E&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">strip</span><span class="p">}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">typespecifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :Arguments:</span>
<span class="sd">         *start*</span>
<span class="sd">            first column</span>
<span class="sd">         *stop*</span>
<span class="sd">            last column + 1</span>
<span class="sd">         *typespecifier*</span>
<span class="sd">            &#39;I&#39;: int, &#39;F&#39;: float, &#39;E&#39;: float, &#39;A&#39;: stripped string</span>

<span class="sd">        The start/stop arguments follow standard Python convention in that</span>
<span class="sd">        they are 0-based and that the *stop* argument is not included.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typespecifier</span> <span class="o">=</span> <span class="n">typespecifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertors</span><span class="p">[</span><span class="n">typespecifier</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the entry from *line* and convert to appropriate type.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertor</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%r</span><span class="s">: Failed to read&amp;convert </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">]))</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the field in columns (stop - start)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;FixedcolumnEntry(</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">,</span><span class="si">%r</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typespecifier</span><span class="p">)</span>

<div class="viewcode-block" id="FORTRANReader"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.FORTRANReader">[docs]</a><span class="k">class</span> <span class="nc">FORTRANReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;FORTRANReader provides a method to parse FORTRAN formatted lines in a file.</span>

<span class="sd">    Usage::</span>

<span class="sd">       atomformat = FORTRANReader(&#39;2I10,2X,A8,2X,A8,3F20.10,2X,A8,2X,A8,F20.10&#39;)</span>
<span class="sd">       for line in open(&#39;coordinates.crd&#39;):</span>
<span class="sd">           serial,TotRes,resName,name,x,y,z,chainID,resSeq,tempFactor = atomformat.read(line)</span>

<span class="sd">    Fortran format edit descriptors; see `Fortran Formats`_ for the syntax.</span>

<span class="sd">    Only simple one-character specifiers supported here: *I F E A X* (see</span>
<span class="sd">    :data:`FORTRAN_format_regex`).</span>

<span class="sd">    Strings are stripped of leading and trailing white space.</span>

<span class="sd">    .. _`Fortran Formats`: http://www.webcitation.org/5xbaWMV2x</span>
<span class="sd">    .. _`Fortran Formats (URL)`:</span>
<span class="sd">       http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up the reader with the FORTRAN format string.</span>

<span class="sd">        The string *fmt* should look like &#39;2I10,2X,A8,2X,A8,3F20.10,2X,A8,2X,A8,F20.10&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_FORTRAN_format</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span> <span class="k">for</span> <span class="n">descriptor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;format&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;X&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;repeat&#39;</span><span class="p">]):</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FixedcolumnEntry</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">stop</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;format&#39;</span><span class="p">]))</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;totallength&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="FORTRANReader.read"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.FORTRANReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse *line* according to the format string and return list of values.</span>

<span class="sd">        Values are converted to Python types according to the format specifier.</span>

<span class="sd">        :Returns: list of entries with appropriate types</span>
<span class="sd">        :Raises: :exc:`ValueError` if any of the conversions cannot be made</span>
<span class="sd">                 (e.g. space for an int)</span>

<span class="sd">        .. SeeAlso:: :meth:`FORTRANReader.number_of_matches`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="FORTRANReader.number_of_matches"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.FORTRANReader.number_of_matches">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return how many format entries could be populated with legal values.&quot;&quot;&quot;</span>
        <span class="c"># not optimal, I suppose...</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">matches</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">matches</span>
</div>
<div class="viewcode-block" id="FORTRANReader.parse_FORTRAN_format"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.FORTRANReader.parse_FORTRAN_format">[docs]</a>    <span class="k">def</span> <span class="nf">parse_FORTRAN_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edit_descriptor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the descriptor.</span>

<span class="sd">          parse_FORTRAN_format(edit_descriptor) --&gt; dict</span>

<span class="sd">        :Returns: dict with totallength (in chars), repeat, length,</span>
<span class="sd">                  format, decimals</span>
<span class="sd">        :Raises: :exc:`ValueError` if the *edit_descriptor* is not recognized</span>
<span class="sd">                 and cannot be parsed</span>

<span class="sd">        .. Note::</span>

<span class="sd">           Specifiers: *L ES EN T TL TR / r S SP SS BN BZ* are *not*</span>
<span class="sd">           supported, and neither are the scientific notation *Ew.dEe*</span>
<span class="sd">           forms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">_FORTRAN_format_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">edit_descriptor</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">_FORTRAN_format_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="o">+</span><span class="n">edit_descriptor</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>  <span class="c"># really no idea what the descriptor is supposed to mean</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unrecognized FORTRAN format </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">edit_descriptor</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;format&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;repeat&#39;</span><span class="p">,</span><span class="s">&#39;length&#39;</span><span class="p">,</span><span class="s">&#39;decimals&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>   <span class="c"># catches &#39;&#39;</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>    <span class="c"># keep None</span>
                <span class="k">pass</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&#39;totallength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;length&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns number of entries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&quot;(&quot;</span><span class="o">+</span><span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;)&quot;</span>
</div>
<div class="viewcode-block" id="fixedwidth_bins"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.fixedwidth_bins">[docs]</a><span class="k">def</span> <span class="nf">fixedwidth_bins</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return bins of width delta that cover xmin,xmax (or a larger range).</span>

<span class="sd">    dict = fixedwidth_bins(delta,xmin,xmax)</span>

<span class="sd">    The dict contains &#39;Nbins&#39;, &#39;delta&#39;, &#39;min&#39;, and &#39;max&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xmin</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Boundaries are not sane: should be xmin &lt; xmax.&#39;</span><span class="p">)</span>
    <span class="n">_delta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">_xmin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">_xmax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">_length</span> <span class="o">=</span> <span class="n">_xmax</span> <span class="o">-</span> <span class="n">_xmin</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">_length</span><span class="o">/</span><span class="n">_delta</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>      <span class="c"># number of bins</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">_delta</span> <span class="o">-</span> <span class="n">_length</span><span class="p">)</span>   <span class="c"># add half of the excess to each end</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&#39;Nbins&#39;</span><span class="p">:</span><span class="n">N</span><span class="p">,</span> <span class="s">&#39;delta&#39;</span><span class="p">:</span><span class="n">_delta</span><span class="p">,</span><span class="s">&#39;min&#39;</span><span class="p">:</span><span class="n">_xmin</span><span class="o">-</span><span class="n">dx</span><span class="p">,</span> <span class="s">&#39;max&#39;</span><span class="p">:</span><span class="n">_xmax</span><span class="o">+</span><span class="n">dx</span><span class="p">}</span>


<span class="c"># geometric functions</span></div>
<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.norm">[docs]</a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Returns the length of a vector, ``sqrt(v.v)``.</span>

<span class="sd">    .. math::</span>

<span class="sd">       v = \sqrt{\mathbf{v}\cdot\mathbf{v}}</span>

<span class="sd">    Faster than :func:`numpy.linalg.norm` because no frills.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="normal"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.normal">[docs]</a><span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Returns the unit vector normal to two vectors.</span>

<span class="sd">    .. math::</span>

<span class="sd">       \hat{\mathbf{n}} = \frac{\mathbf{v}_1 \times \mathbf{v}_2}{|\mathbf{v}_1 \times \mathbf{v}_2|}</span>

<span class="sd">    If the two vectors are collinear, the vector :math:`\mathbf{0}` is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">normal</span>  <span class="c"># returns [0,0,0] instead of [nan,nan,nan]</span>
    <span class="k">return</span> <span class="n">normal</span><span class="o">/</span><span class="n">n</span>    <span class="c"># ... could also use numpy.nan_to_num(normal/norm(normal))</span>
</div>
<div class="viewcode-block" id="angle"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.angle">[docs]</a><span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the angle between two vectors in radians&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="c"># catch roundoffs that lead to nan otherwise</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="stp"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.stp">[docs]</a><span class="k">def</span> <span class="nf">stp</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">vec3</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Takes the scalar triple product of three vectors.</span>

<span class="sd">    Returns the volume *V* of the parallel epiped spanned by the three</span>
<span class="sd">    vectors</span>

<span class="sd">    .. math::</span>

<span class="sd">        V = \mathbf{v}_3 \cdot (\mathbf{v}_1 \times \mathbf{v}_2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec3</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="dihedral"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.dihedral">[docs]</a><span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Returns the dihedral angle in radians between vectors connecting A,B,C,D.</span>

<span class="sd">    The dihedral measures the rotation around bc::</span>

<span class="sd">         ab</span>
<span class="sd">       A----&gt;B</span>
<span class="sd">              \ bc</span>
<span class="sd">              _\&#39;</span>
<span class="sd">                C----&gt;D</span>
<span class="sd">                  cd</span>

<span class="sd">    The dihedral angle is restricted to the range -π &lt;= x &lt;= π.</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">normal</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="k">if</span> <span class="n">stp</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>


<span class="c"># String functions</span>
<span class="c"># ----------------</span>

<span class="c">#: translation table for 3-letter codes --&gt; 1-letter codes</span>
<span class="c">#: .. SeeAlso:: :data:`alternative_inverse_aa_codes`</span></div>
<span class="n">canonical_inverse_aa_codes</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;ALA&#39;</span><span class="p">:</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;CYS&#39;</span><span class="p">:</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;ASP&#39;</span><span class="p">:</span><span class="s">&#39;D&#39;</span><span class="p">,</span> <span class="s">&#39;GLU&#39;</span><span class="p">:</span><span class="s">&#39;E&#39;</span><span class="p">,</span>
                              <span class="s">&#39;PHE&#39;</span><span class="p">:</span><span class="s">&#39;F&#39;</span><span class="p">,</span> <span class="s">&#39;GLY&#39;</span><span class="p">:</span><span class="s">&#39;G&#39;</span><span class="p">,</span> <span class="s">&#39;HIS&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;ILE&#39;</span><span class="p">:</span><span class="s">&#39;I&#39;</span><span class="p">,</span>
                              <span class="s">&#39;LYS&#39;</span><span class="p">:</span><span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="s">&#39;LEU&#39;</span><span class="p">:</span><span class="s">&#39;L&#39;</span><span class="p">,</span> <span class="s">&#39;MET&#39;</span><span class="p">:</span><span class="s">&#39;M&#39;</span><span class="p">,</span> <span class="s">&#39;ASN&#39;</span><span class="p">:</span><span class="s">&#39;N&#39;</span><span class="p">,</span>
                              <span class="s">&#39;PRO&#39;</span><span class="p">:</span><span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;GLN&#39;</span><span class="p">:</span><span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="s">&#39;ARG&#39;</span><span class="p">:</span><span class="s">&#39;R&#39;</span><span class="p">,</span> <span class="s">&#39;SER&#39;</span><span class="p">:</span><span class="s">&#39;S&#39;</span><span class="p">,</span>
                              <span class="s">&#39;THR&#39;</span><span class="p">:</span><span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="s">&#39;VAL&#39;</span><span class="p">:</span><span class="s">&#39;V&#39;</span><span class="p">,</span> <span class="s">&#39;TRP&#39;</span><span class="p">:</span><span class="s">&#39;W&#39;</span><span class="p">,</span> <span class="s">&#39;TYR&#39;</span><span class="p">:</span><span class="s">&#39;Y&#39;</span><span class="p">}</span>
<span class="c">#: translation table for 1-letter codes --&gt; *canonical* 3-letter codes.</span>
<span class="c">#: The table is used for :func:`convert_aa_code`.</span>
<span class="n">amino_acid_codes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">one</span><span class="p">,</span> <span class="n">three</span><span class="p">)</span> <span class="k">for</span> <span class="n">three</span><span class="p">,</span><span class="n">one</span> <span class="ow">in</span> <span class="n">canonical_inverse_aa_codes</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
<span class="c">#: non-default charge state amino acids or special charge state descriptions</span>
<span class="c">#: (Not fully synchronized with :class:`MDAnalysis.core.Selection.ProteinSelection`.)</span>
<span class="n">alternative_inverse_aa_codes</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;HISA&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HISB&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HSE&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HSD&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HID&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HIE&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HIS1&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;HIS2&#39;</span><span class="p">:</span><span class="s">&#39;H&#39;</span><span class="p">,</span>
                                <span class="s">&#39;ASPH&#39;</span><span class="p">:</span> <span class="s">&#39;D&#39;</span><span class="p">,</span> <span class="s">&#39;ASH&#39;</span><span class="p">:</span> <span class="s">&#39;D&#39;</span><span class="p">,</span>
                                <span class="s">&#39;GLUH&#39;</span><span class="p">:</span> <span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="s">&#39;GLH&#39;</span><span class="p">:</span> <span class="s">&#39;E&#39;</span><span class="p">,</span>
                                <span class="s">&#39;LYSH&#39;</span><span class="p">:</span> <span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="s">&#39;LYN&#39;</span><span class="p">:</span> <span class="s">&#39;K&#39;</span><span class="p">,</span>
                                <span class="s">&#39;ARGN&#39;</span><span class="p">:</span> <span class="s">&#39;R&#39;</span><span class="p">,</span>
                                <span class="s">&#39;CYSH&#39;</span><span class="p">:</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;CYS1&#39;</span><span class="p">:</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;CYS2&#39;</span><span class="p">:</span><span class="s">&#39;C&#39;</span><span class="p">}</span>
<span class="c">#: lookup table from 3/4 letter resnames to 1-letter codes. Note that non-standard residue names</span>
<span class="c">#: for tautomers or different protonation states such as HSE are converted to canonical 1-letter codes (&quot;H&quot;).</span>
<span class="c">#: The table is used for :func:`convert_aa_code`.</span>
<span class="c">#: .. SeeAlso:: :data:`canonical_inverse_aa_codes` and :data:`alternative_inverse_aa_codes`</span>
<span class="n">inverse_aa_codes</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">inverse_aa_codes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">canonical_inverse_aa_codes</span><span class="p">)</span>
<span class="n">inverse_aa_codes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">alternative_inverse_aa_codes</span><span class="p">)</span>

<div class="viewcode-block" id="convert_aa_code"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.convert_aa_code">[docs]</a><span class="k">def</span> <span class="nf">convert_aa_code</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts between 3-letter and 1-letter amino acid codes.</span>

<span class="sd">    .. SeeAlso:: Data are defined in :data:`amino_acid_codes` and :data:`inverse_aa_codes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">amino_acid_codes</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">inverse_aa_codes</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No conversion for {0} found (1 letter -&gt; 3 letter or 3/4 letter -&gt; 1 letter)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="c">#: Regular expression to match and parse a residue-atom selection; will match</span>
<span class="c">#: &quot;LYS300:HZ1&quot; or &quot;K300:HZ1&quot; or &quot;K300&quot; or &quot;4GB300:H6O&quot; or &quot;4GB300&quot; or &quot;YaA300&quot;.</span></div>
<span class="n">RESIDUE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                 (?P&lt;aa&gt;([ACDEFGHIKLMNPQRSTVWY])   # 1-letter amino acid</span>
<span class="s">                        |                          #   or</span>
<span class="s">                        ([0-9A-Z][a-zA-Z][A-Z][A-Z]?)    # 3-letter or 4-letter residue name</span>
<span class="s">                 )</span>
<span class="s">                 \s*                               # white space allowed</span>
<span class="s">                 (?P&lt;resid&gt;\d+)                    # resid</span>
<span class="s">                 \s*</span>
<span class="s">                 (:                                # separator &#39;:&#39;</span>
<span class="s">                   \s*</span>
<span class="s">                   (?P&lt;atom&gt;\w+)                   # atom name</span>
<span class="s">                 )?                                # possibly one</span>
<span class="s">            &quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>

<span class="c"># from GromacsWrapper cbook.IndexBuilder</span>
<div class="viewcode-block" id="parse_residue"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.parse_residue">[docs]</a><span class="k">def</span> <span class="nf">parse_residue</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Process residue string.</span>

<span class="sd">    Examples:</span>
<span class="sd">     - &quot;LYS300:HZ1&quot; --&gt; (&quot;LYS&quot;, 300, &quot;HZ1&quot;)</span>
<span class="sd">     - &quot;K300:HZ1&quot; --&gt; (&quot;LYS&quot;, 300, &quot;HZ1&quot;)</span>
<span class="sd">     - &quot;K300&quot; --&gt; (&quot;LYS&quot;, 300, None)</span>
<span class="sd">     - &quot;4GB300:H6O&quot; --&gt; (&quot;4GB&quot;, 300, &quot;H6O&quot;)</span>
<span class="sd">     - &quot;4GB300&quot; --&gt; (&quot;4GB&quot;, 300, None)</span>

<span class="sd">    :Argument: The *residue* must contain a 1-letter or 3-letter or</span>
<span class="sd">               4-letter residue string, a number (the resid) and</span>
<span class="sd">               optionally an atom identifier, which must be separate</span>
<span class="sd">               from the residue with a colon (&quot;:&quot;). White space is</span>
<span class="sd">               allowed in between.</span>

<span class="sd">    :Returns: `(3-letter aa string, resid, atomname)`; known 1-letter</span>
<span class="sd">              aa codes are converted to 3-letter codes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># XXX: use _translate_residue() ....</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">RESIDUE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Selection </span><span class="si">%(residue)r</span><span class="s"> is not valid (only 1/3/4 letter resnames, resid required).&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>
    <span class="n">resid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;resid&#39;</span><span class="p">))</span>
    <span class="n">residue</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;aa&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">convert_aa_code</span><span class="p">(</span><span class="n">residue</span><span class="p">)</span> <span class="c"># only works for AA</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">residue</span>                            <span class="c"># use 3-letter for any resname</span>
    <span class="n">atomname</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;atom&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">resname</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">atomname</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="conv_float"><a class="viewcode-back" href="../../../documentation_pages/core/util.html#MDAnalysis.core.util.conv_float">[docs]</a><span class="k">def</span> <span class="nf">conv_float</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an object *s* to float if possible.</span>

<span class="sd">    Function to be passed into :func:`map` or a list comprehension. If</span>
<span class="sd">    the argument can be interpreted as a float it is converted,</span>
<span class="sd">    otherwise the original object is passed back.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">MDAnalysis 0.8.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../MDAnalysis.html" >MDAnalysis</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2013, Naveen Michaud-Agrawal, Elizabeth J. Denning, Joshua Adelman,
    Christian Beckstein (logo), Alejandro Bernardin, Sébastien Buchoux,
    David Caplan, Jan Domański, Xavier Deupi,
    Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar,
    Benjamin Hall, Jinju Lu, Robert McGibbon,
    Manuel Nuno Melo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Andy Somogyi,
    Lukas Stelzl, Zhuyi Xue, Matthieu Chavent and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>