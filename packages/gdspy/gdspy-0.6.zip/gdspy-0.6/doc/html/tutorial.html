

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Sample File &mdash; Gdspy 0.6 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Gdspy 0.6 documentation" href="index.html" />
    <link rel="next" title="Main API" href="main.html" />
    <link rel="prev" title="GDSII for Python" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="main.html" title="Main API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="GDSII for Python"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Gdspy 0.6 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="sample-file">
<h1>Sample File<a class="headerlink" href="#sample-file" title="Permalink to this headline">Â¶</a></h1>
<p>The following code is a sample to quickly demonstrate some features of
<a class="reference internal" href="main.html#module-gdspy" title="gdspy"><tt class="xref py py-mod docutils literal"><span class="pre">gdspy</span></tt></a>.
Please take a look at the full documentation for further information.</p>
<p><a class="reference download internal" href="_downloads/gdspy-sample.py"><tt class="xref download docutils literal"><span class="pre">Download</span> <span class="pre">sample</span> <span class="pre">file</span></tt></a></p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">#!/usr/bin/python</span>

<span class="c">########################################################################</span>
<span class="c">##																	  ##</span>
<span class="c">##	Copyright 2009-2014 Lucas Heitzmann Gabrielli					  ##</span>
<span class="c">##																	  ##</span>
<span class="c">##	This file is part of gdspy.										  ##</span>
<span class="c">##																	  ##</span>
<span class="c">##	gdspy is free software: you can redistribute it and/or modify it  ##</span>
<span class="c">##	under the terms of the GNU General Public License as published	  ##</span>
<span class="c">##	by the Free Software Foundation, either version 3 of the		  ##</span>
<span class="c">##	License, or any later version.									  ##</span>
<span class="c">##																	  ##</span>
<span class="c">##	gdspy is distributed in the hope that it will be useful, but	  ##</span>
<span class="c">##	WITHOUT ANY WARRANTY; without even the implied warranty of		  ##</span>
<span class="c">##	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	  ##</span>
<span class="c">##	GNU General Public License for more details.					  ##</span>
<span class="c">##																	  ##</span>
<span class="c">##	You should have received a copy of the GNU General Public		  ##</span>
<span class="c">##	License along with gdspy.  If not, see							  ##</span>
<span class="c">##	&lt;http://www.gnu.org/licenses/&gt;.									  ##</span>
<span class="c">##																	  ##</span>
<span class="c">########################################################################</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">gdspy</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;Using gdspy module version &#39;</span> <span class="o">+</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>


<span class="c">## ------------------------------------------------------------------ ##</span>
<span class="c">##	POLYGONS														  ##</span>
<span class="c">## ------------------------------------------------------------------ ##</span>


<span class="c">## First we need a cell to add the polygons to.</span>
<span class="n">poly_cell</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s">&#39;POLYGONS&#39;</span><span class="p">)</span>

<span class="c">## We define the polygon through its vertices.</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>

<span class="c">## Create the polygon on layer 1.</span>
<span class="n">poly1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c">## Add the new polygon to the cell.</span>
<span class="n">poly_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">poly1</span><span class="p">)</span>

<span class="c">## Create another polygon from the same set of points, but rotate it</span>
<span class="c">## 180 degrees and add it to the cell.</span>
<span class="n">poly2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">poly_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">poly2</span><span class="p">)</span>

<span class="c">## To create rectangles we don&#39;t need to give the 4 corners, only 2.</span>
<span class="c">## Note that we don&#39;t need to create a variable if we are not going to</span>
<span class="c">## use it, just add the rectangle directly to the cell.  Create a </span>
<span class="c">## rectangle in layer 2.</span>
<span class="n">poly_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="mi">18</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

<span class="c">## There are no circles in the GDSII specification, so rounded shapes</span>
<span class="c">## are actually many-sided polygons.  Create a circle in layer 2,</span>
<span class="c">## centered at (27, 2), and with radius 2.</span>
<span class="n">poly_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mi">27</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

<span class="c">## The Round class is quite versatile: it provides circles, pie slices,</span>
<span class="c">## rings and ring sections, like this one in layer 2.</span>
<span class="n">poly_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mf">23.5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="mi">15</span><span class="p">,</span> <span class="n">inner_radius</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
	<span class="n">initial_angle</span><span class="o">=-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">final_angle</span><span class="o">=-</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span>
	<span class="n">layer</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>


<span class="c">## ------------------------------------------------------------------ ##</span>
<span class="c">##	PATHS															  ##</span>
<span class="c">## ------------------------------------------------------------------ ##</span>


<span class="n">path_cell</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s">&#39;PATHS&#39;</span><span class="p">)</span>

<span class="c">## Start a path from the origin with width 1.</span>
<span class="n">path1</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c">## Add a straight segment to the path in layer 1, datatype 1, with length</span>
<span class="c">## 3, going in the &#39;+x&#39; direction.	Since we&#39;ll use this layer/datatype</span>
<span class="c">## configuration again, we can setup a dict containing this info.</span>
<span class="n">spec</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;layer&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;datatype&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">path1</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;+x&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span>

<span class="c">## Add a curve to the path by specifying its radius as 2 and its initial</span>
<span class="c">## and final angles.</span>
<span class="n">path1</span><span class="o">.</span><span class="n">arc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span>

<span class="c">## Add another segment to the path in layer 1, with length 4 and</span>
<span class="c">## pointing in the direction defined by the last piece we added above.</span>
<span class="n">path1</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span>

<span class="c">## Add a curve using the turn command.	We specify the radius 2 and</span>
<span class="c">## turning angle. The agnle can also be specified with &#39;l&#39; and &#39;r&#39; for</span>
<span class="c">## left and right turns of 90 degrees, or &#39;ll&#39; and &#39;rr&#39; for 180 degrees.</span>
<span class="n">path1</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span>

<span class="c">## Final piece of the path.  Add a straight segment and tapper the path</span>
<span class="c">## width from the original 1 to 0.5.</span>
<span class="n">path1</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">final_width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span>
<span class="n">path_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">path1</span><span class="p">)</span>

<span class="c">## We can also create parallel paths simultaneously.  Start 2 paths with</span>
<span class="c">## width 0.5 each,nd pitch 1, originating where our last path ended.</span>
<span class="n">path2</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="n">path1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">path1</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="n">number_of_paths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
		<span class="n">distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c">## Add a straight segment to the paths gradually increasing their</span>
<span class="c">## distance to 1.5, in the direction in which the last path ended.</span>
<span class="n">spec</span><span class="p">[</span><span class="s">&#39;layer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">path2</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">path1</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">final_distance</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span>

<span class="c">## Path commands can be concatenated.  Add a turn and a tapper segment</span>
<span class="c">## in one expression, followed by a final turn.</span>
<span class="n">path2</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>
		<span class="n">final_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span>
<span class="n">path2</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">,</span> <span class="o">**</span><span class="n">spec</span><span class="p">)</span>
<span class="n">path_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">path2</span><span class="p">)</span>

<span class="c">## Create another single path 0.5 wide, starting where the path above</span>
<span class="c">## ended, and add to it a line segment in the 3rd layer in the &#39;-y&#39;</span>
<span class="c">## direction.</span>
<span class="n">path3</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="n">path2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">path2</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
<span class="n">path3</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;-y&#39;</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c">## We can create paths based on parametric curves.	First we need to</span>
<span class="c">## define the curve function, with 1 argument.	This argument will vary</span>
<span class="c">## from 0 to 1 and the return value should be the (x, y) coordinates of</span>
<span class="c">## the path.  This could be a lambda-expression if the function is</span>
<span class="c">## simple enough.  We will create a spiral path.  Note that the function</span>
<span class="c">## returns (0, 0) when t=0, so that our path is connected.</span>
<span class="k">def</span> <span class="nf">spiral</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
	<span class="n">r</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">t</span>
	<span class="n">theta</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
	<span class="n">x</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">r</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
	<span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">r</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c">## We can also create the derivative of the curve to pass to out path</span>
<span class="c">## path member, otherwise it will be numerically calculated.  In the</span>
<span class="c">## spiral case we don&#39;t want the exact derivative, but the derivative of</span>
<span class="c">## the spiral as if its radius was constant.  This will ensure that our</span>
<span class="c">## path is connected at the start (geometric problem of this kind of</span>
<span class="c">## spiral).</span>
<span class="k">def</span> <span class="nf">dspiral_dt</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
	<span class="n">theta</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
	<span class="n">dx_dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
	<span class="n">dy_dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dx_dt</span><span class="p">,</span> <span class="n">dy_dt</span><span class="p">)</span>

<span class="c">## Add the parametric spiral to the path in layer 3.  Note that we can</span>
<span class="c">## still tapper the width (linearly or with a taper function).  To make</span>
<span class="c">## the curve smoother, we increase the number of evaluations of the</span>
<span class="c">## function (fracture will be performed automatically to ensure polygons</span>
<span class="c">## with less than 200 points).</span>
<span class="n">path3</span><span class="o">.</span><span class="n">parametric</span><span class="p">(</span><span class="n">spiral</span><span class="p">,</span> <span class="n">dspiral_dt</span><span class="p">,</span>
		<span class="n">final_width</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">),</span>
		<span class="n">number_of_evaluations</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">path_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">path3</span><span class="p">)</span>

<span class="c">## Polygonal paths are defined by the points they pass through.  The</span>
<span class="c">## width of the path can be given as a number, representing the path </span>
<span class="c">## width along is whole extension, or as a list, where each element is</span>
<span class="c">## the width of the path at one point.	Our path will have width 0.5 in</span>
<span class="c">## all points, except the last, where it will tapper up to 1.5.  More</span>
<span class="c">## than 1 path can be defined in parallel as well (useful for buses).</span>
<span class="c">## The distance between the paths work the same way as the width: it&#39;s</span>
<span class="c">## either a constant number, or a list.  We create 5 parallel paths that</span>
<span class="c">## are larger and further apart on the last point.	The paths are put in</span>
<span class="c">## layers 4 and 5.	Since we have 5 paths, the list of layers will be</span>
<span class="c">## run more than once, so the 5 paths will actually be in layers 4, 5, 4,</span>
<span class="c">## 5, and 4.</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">]</span>
<span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">2.4</span><span class="p">]</span>
<span class="n">polypath</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">PolyPath</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">number_of_paths</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
		<span class="n">distance</span><span class="o">=</span><span class="n">distances</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="c">## We can round the corners of any Polygon or PolygonSet with the fillet</span>
<span class="c">## method.	Here we use a radius of 0.2.</span>
<span class="c">#polypath.fillet(0.2)</span>
<span class="n">path_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">polypath</span><span class="p">)</span>

<span class="c">## L1Paths use only segments in &#39;x&#39; and &#39;y&#39; directions, useful for some</span>
<span class="c">## lithography mask writers.  We specify a path composed of 16 segments</span>
<span class="c">## of length 4.  The turns after each segment can be either 90 degrees</span>
<span class="c">## CCW (positive) or CW (negative).  The absolute value of the turns</span>
<span class="c">## produces a scaling of the path width and distance between paths in</span>
<span class="c">## segments immediately after the turn.</span>
<span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span>
<span class="n">turns</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
<span class="n">l1path</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">L1Path</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span><span class="p">),</span> <span class="s">&#39;+y&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">turns</span><span class="p">,</span>
		<span class="n">number_of_paths</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">path_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">l1path</span><span class="p">)</span>


<span class="c">## ------------------------------------------------------------------ ##</span>
<span class="c">##	BOOLEAN OPERATIONS												  ##</span>
<span class="c">## ------------------------------------------------------------------ ##</span>


<span class="c">## Boolean operations can be executed with polygons (either gdspy</span>
<span class="c">## objects or point lists).  The operands are given as a list.	In this</span>
<span class="c">## example we will have 2 operands which will be 2 PolygonSet objects.</span>
<span class="n">bool_cell</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s">&#39;BOOLEAN&#39;</span><span class="p">)</span>
<span class="n">primitives</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c">## Both operands are a path with a ring inside, but with different</span>
<span class="c">## widths.	This is how we create them.</span>
<span class="k">for</span> <span class="n">width</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]:</span>

	<span class="c">## Closed path in a square shape with rounded corners.	Boolean</span>
	<span class="c">## operations become slower with the number of points involved, so</span>
	<span class="c">## it&#39;s important to keep these to a minimum.</span>
	<span class="n">bool_path</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
	<span class="n">bool_path</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">&#39;+y&#39;</span><span class="p">)</span>
	<span class="n">bool_path</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">number_of_points</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
	<span class="n">bool_path</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">&#39;+x&#39;</span><span class="p">)</span>
	<span class="n">bool_path</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">number_of_points</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
	<span class="n">bool_path</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">&#39;-y&#39;</span><span class="p">)</span>
	<span class="n">bool_path</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">number_of_points</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
	<span class="n">bool_path</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">&#39;-x&#39;</span><span class="p">)</span>
	<span class="n">bool_path</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">number_of_points</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>

	<span class="c">## Ring inside the square path.</span>
	<span class="n">ring</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="mi">25</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>
			<span class="n">inner_radius</span><span class="o">=</span><span class="mi">25</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>
			<span class="n">number_of_points</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>

	<span class="c">## We create a PolygonSet that contains both our path segments and</span>
	<span class="c">## ring, and then append it to our list of operands.</span>
	<span class="n">primitives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">PolygonSet</span><span class="p">(</span><span class="n">bool_path</span><span class="o">.</span><span class="n">polygons</span> <span class="o">+</span>
		<span class="n">ring</span><span class="o">.</span><span class="n">polygons</span><span class="p">))</span>

<span class="c">## The list of operands contains 2 polygon sets.  We will subtract the</span>
<span class="c">## 1st (narrower) from the 2nd (wider).  For that we need to define a</span>
<span class="c">## function that receives 2 integers (each representing an operand) and</span>
<span class="c">## returns the operation we want executed.	Here we use a lambda </span>
<span class="c">## expression to do so.</span>
<span class="n">subtraction</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="n">p2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p1</span>

<span class="c">## We perform the operation, put the resulting polygons in layer 1, and</span>
<span class="c">## add to our boolean cell.</span>
<span class="n">bool_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span><span class="n">primitives</span><span class="p">,</span> <span class="n">subtraction</span><span class="p">,</span> <span class="n">max_points</span><span class="o">=</span><span class="mi">199</span><span class="p">,</span>
	<span class="n">layer</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>


<span class="c">## ------------------------------------------------------------------ ##</span>
<span class="c">##	SLICING POLYGONS												  ##</span>
<span class="c">## ------------------------------------------------------------------ ##</span>


<span class="c">## If there is the need to cut a polygon or set of polygons, it&#39;s better</span>
<span class="c">## to use the slice function than set up a boolean operation, since it</span>
<span class="c">## runs much faster.  Slices are multiple cuts perpendicular to an axis.</span>
<span class="n">slice_cell</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s">&#39;SLICE&#39;</span><span class="p">)</span>
<span class="n">original</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Round</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="n">inner_radius</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c">## Slice the original ring along x = -7 and x = 7.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c">## The result is a tuple of polygon sets, one for each slice.  To keep</span>
<span class="c">## add the region betwen our 2 cuts, we chose result[1].</span>
<span class="n">slice_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c">## If the cut needs to be at an angle we can rotate the geometry, slice</span>
<span class="c">## it, and rotate back.</span>
<span class="n">original</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">PolyPath</span><span class="p">([(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">),</span>
	<span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">original</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">slice_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="c">## ------------------------------------------------------------------ ##</span>
<span class="c">##	REFERENCES AND TEXT												  ##</span>
<span class="c">## ------------------------------------------------------------------ ##</span>


<span class="c">## Cells can contain references to other cells.</span>
<span class="n">ref_cell</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="s">&#39;REFS&#39;</span><span class="p">)</span>
<span class="n">ref_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">CellReference</span><span class="p">(</span><span class="n">poly_cell</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">x_reflection</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="n">ref_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">CellReference</span><span class="p">(</span><span class="n">poly_cell</span><span class="p">,</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">180</span><span class="p">))</span>

<span class="c">## References can be whole arrays.	Add an array of the boolean cell</span>
<span class="c">## with 2 lines and 3 columns and 1st element at (50, -15).</span>
<span class="n">ref_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">CellArray</span><span class="p">(</span><span class="s">&#39;BOOLEAN&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span> <span class="p">,(</span><span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">),</span>
	<span class="n">magnification</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>

<span class="c">## Text are also sets of polygons.	They have edges parallel to &#39;x&#39; and</span>
<span class="c">## &#39;y&#39; only.</span>
<span class="n">ref_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="s">&#39;Created with gsdpy &#39;</span> <span class="o">+</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span>
	<span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">35</span><span class="p">),</span> <span class="n">layer</span><span class="o">=</span><span class="mi">6</span><span class="p">))</span>

<span class="c">## Labels are special text objects which don&#39;t define any actual</span>
<span class="c">## geometry, but can be used to annotate the drawing.  Rotation,</span>
<span class="c">## magnification and reflection of the text are not supported by the</span>
<span class="c">## included GUI, but they are included in the resulting GDSII file.</span>
<span class="n">ref_cell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gdspy</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s">&#39;Created with gdspy &#39;</span> <span class="o">+</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span>
	<span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">36</span><span class="p">),</span> <span class="s">&#39;nw&#39;</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">6</span><span class="p">))</span>


<span class="c">## ------------------------------------------------------------------ ##</span>
<span class="c">##	OUTPUT															  ##</span>
<span class="c">## ------------------------------------------------------------------ ##</span>


<span class="c">## Output the layout to a GDSII file (default to all created cells).</span>
<span class="c">## Set the units we used to micrometers and the precision to nanometers.</span>
<span class="n">gdspy</span><span class="o">.</span><span class="n">gds_print</span><span class="p">(</span><span class="s">&#39;gdspy-sample.gds&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="mf">1.0e-6</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">1.0e-9</span><span class="p">)</span>


<span class="c">## ------------------------------------------------------------------ ##</span>
<span class="c">##	IMPORT															  ##</span>
<span class="c">## ------------------------------------------------------------------ ##</span>


<span class="c">## Import the file we just created, and extract the cell &#39;POLYGONS&#39;. To</span>
<span class="c">## avoid naming conflict, we will rename all cells.</span>
<span class="n">gdsii</span> <span class="o">=</span> <span class="n">gdspy</span><span class="o">.</span><span class="n">GdsImport</span><span class="p">(</span><span class="s">&#39;gdspy-sample.gds&#39;</span><span class="p">,</span>
						<span class="n">rename</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;POLYGONS&#39;</span><span class="p">:</span><span class="s">&#39;IMPORT_POLY&#39;</span><span class="p">,</span>
								<span class="s">&#39;PATHS&#39;</span><span class="p">:</span> <span class="s">&#39;IMPORT_PATHS&#39;</span><span class="p">,</span>
								<span class="s">&#39;BOOLEAN&#39;</span><span class="p">:</span> <span class="s">&#39;IMPORT_BOOL&#39;</span><span class="p">,</span>
								<span class="s">&#39;SLICE&#39;</span><span class="p">:</span> <span class="s">&#39;IMPORT_SLICE&#39;</span><span class="p">,</span>
								<span class="s">&#39;REFS&#39;</span><span class="p">:</span> <span class="s">&#39;IMPORT_REFS&#39;</span><span class="p">},</span>
						<span class="n">layers</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">})</span>

<span class="c">## Now we extract the cells we want to actually include in our current</span>
<span class="c">## structure. Note that the referenced cells will be automatically</span>
<span class="c">## extracted as well.</span>
<span class="n">gdsii</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s">&#39;IMPORT_REFS&#39;</span><span class="p">)</span>


<span class="c">## ------------------------------------------------------------------ ##</span>
<span class="c">##	VIEWER															  ##</span>
<span class="c">## ------------------------------------------------------------------ ##</span>


<span class="c">## View the layout using a GUI.  Full description of the controls can</span>
<span class="c">## be found in the online help at http://gdspy.sourceforge.net/</span>
<span class="n">gdspy</span><span class="o">.</span><span class="n">LayoutViewer</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">GDSII for Python</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="main.html"
                        title="next chapter">Main API</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tutorial.txt"
           rel="nofollow">Show Source</a></li>
  </ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<form class="donate" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
">
<input class="donate" type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img class="donate" alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="main.html" title="Main API"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="GDSII for Python"
             >previous</a> |</li>
        <li><a href="index.html">Gdspy 0.6 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009-2014, Lucas H. Gabrielli.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>