
Initialisation du programme
***************************


Initialisation de l'écran LCD
=============================

Il faut créer une variable pour contrôler l'affichage LCD:

Adafruit_CharLCDPlate.Adafruit_CharLCDPlate()

   Retourne:
      objet

   Type retourné:
      Adafruit_CharLCDPlate()

Ici la variable créée est lcd


Initialisation de l'Arduino
===========================

Avec Firmata sur l'Arduino. Comme avec l'écran, Création de la
variable :

pyfirmata.Arduino(id)

   Paramètres:
      **id** (*string*) -- identifiant de l'Arduino dans le répertoire
      /dev

   Retourne:
      objet Arduino

   Type retourné:
      Arduino

Ici, la variable est appelée board.

Il faut ensuite commencer l'écoute sur les entrées :

board.analog[i].enable_reporting()

   Paramètres:
      **i** (*integer*) -- numéro de l'entrée analogique

   Retourne:
      None

Lorsque la Raspberry Pi commence à écouter, l'Arduino renvoit comme
valeur None au début, il faut donc attendre que l'Arduino envoit une
valeur valide avant de commencer.


Initialisation des fichiers de sauvegarde
=========================================

On désire avoir un fichier par capteur et un fichier d'horodatage. La
création des fichiers se fait en 3 étapes :

   1. définition du répertoire de stockage des fichiers

   2. création des fichiers et d'une liste

   3. ouverture des fichiers et remplissage de la liste

La liste permet de stocker le nom des fichiers.

Pour toutes ces opérations, on utilisera le module os.


Chemin des fichiers
-------------------

On lit dans quel dossier on se trouve actuellement avec

os.getcwd()

   getcwd() -> path

   Return a unicode string representing the current working directory.

Puis on définit le dossier de sortie par la chaîne de caractères
"data" et on crée le chemin avec

os.path.join(currentDir, newDir)

   Join two or more pathname components, inserting '/' as needed. If
   any component is an absolute path, all previous path components
   will be discarded.  An empty last part will result in a path that
   ends with a separator.

   Paramètres:
      * **currentDir** (*string*) -- chemin initial

      * **newDir** (*string*) -- chemin à ajouter au currentDir

   Retourne:
      nouveau chemin

   Type retourné:
      string

On obtient alors le chemin du dossier dans lequel seront stockés les
fichiers

Si le dossier n'existait pas, il est créé avec

os.makedirs(newpath)

   makedirs(path [, mode=0o777][, exist_ok=False])

   Super-mkdir; create a leaf directory and all intermediate ones.
   Works like mkdir, except that any intermediate path segment (not
   just the rightmost) will be created if it does not exist. If the
   target directory with the same mode as we specified already exists,
   raises an OSError if exist_ok is False, otherwise no exception is
   raised.  This is recursive.

   Paramètres:
      **newpath** -- chemin du dossier à créer

   Retourne:
      None

L'existence du dossier est testée avec :

os.path.exists(newpath)

   Test whether a path exists.  Returns False for broken symbolic
   links

   Paramètres:
      **newpath** (*string*) -- chemin dont on regarde l'existence

   Retourne:
      booléen indiquant l'existence ou non du dossier

   Type retourné:
      boolean


Création des fichiers
---------------------

On crée la liste contenant les fichiers nommée fileList. On crée les
noms de fichiers :

'data_%s'%str(i)

   Paramètres:
      **i** (*integer*) -- numéro de l'entrée analogique correspondant
      à ce fichier

   Retourne:
      le nom de fichier sous la forme data_i avec i le numéro d'entrée
      analogique

   Type retourné:
      string

On crée le chemin du fichier avec

os.path.join(path, filename)

   Retourne:
      le chemin complet du fichier

Enfin, on ouvre le fichier avec

io.open(filepath, mode)

   open(file, mode='r', buffering=-1, encoding=None,
      errors=None, newline=None, closefd=True, opener=None) -> file
      object

   Open file and return a stream.  Raise IOError upon failure.

   file is either a text or byte string giving the name (and the path
   if the file isn't in the current working directory) of the file to
   be opened or an integer file descriptor of the file to be wrapped.
   (If a file descriptor is given, it is closed when the returned I/O
   object is closed, unless closefd is set to False.)

   mode is an optional string that specifies the mode in which the
   file is opened. It defaults to 'r' which means open for reading in
   text mode.  Other common values are 'w' for writing (truncating the
   file if it already exists), 'x' for creating and writing to a new
   file, and 'a' for appending (which on some Unix systems, means that
   all writes append to the end of the file regardless of the current
   seek position). In text mode, if encoding is not specified the
   encoding used is platform dependent:
   locale.getpreferredencoding(False) is called to get the current
   locale encoding. (For reading and writing raw bytes use binary mode
   and leave encoding unspecified.) The available modes are:

   +-----------+-----------------------------------------------------------------+
   | Character | Meaning                                                         |
   +-----------+-----------------------------------------------------------------+
   | 'r'       | open for reading (default)                                      |
   +-----------+-----------------------------------------------------------------+
   | 'w'       | open for writing, truncating the file first                     |
   +-----------+-----------------------------------------------------------------+
   | 'x'       | create a new file and open it for writing                       |
   +-----------+-----------------------------------------------------------------+
   | 'a'       | open for writing, appending to the end of the file if it exists |
   +-----------+-----------------------------------------------------------------+
   | 'b'       | binary mode                                                     |
   +-----------+-----------------------------------------------------------------+
   | 't'       | text mode (default)                                             |
   +-----------+-----------------------------------------------------------------+
   | '+'       | open a disk file for updating (reading and writing)             |
   +-----------+-----------------------------------------------------------------+
   | 'U'       | universal newline mode (deprecated)                             |
   +-----------+-----------------------------------------------------------------+

   The default mode is 'rt' (open for reading text). For binary random
   access, the mode 'w+b' opens and truncates the file to 0 bytes,
   while 'r+b' opens the file without truncation. The 'x' mode implies
   'w' and raises an *FileExistsError* if the file already exists.

   Python distinguishes between files opened in binary and text modes,
   even when the underlying operating system doesn't. Files opened in
   binary mode (appending 'b' to the mode argument) return contents as
   bytes objects without any decoding. In text mode (the default, or
   when 't' is appended to the mode argument), the contents of the
   file are returned as strings, the bytes having been first decoded
   using a platform-dependent encoding or using the specified encoding
   if given.

   'U' mode is deprecated and will raise an exception in future
   versions of Python.  It has no effect in Python 3.  Use newline to
   control universal newlines mode.

   buffering is an optional integer used to set the buffering policy.
   Pass 0 to switch buffering off (only allowed in binary mode), 1 to
   select line buffering (only usable in text mode), and an integer >
   1 to indicate the size of a fixed-size chunk buffer.  When no
   buffering argument is given, the default buffering policy works as
   follows:

   * Binary files are buffered in fixed-size chunks; the size of the
     buffer is chosen using a heuristic trying to determine the
     underlying device's "block size" and falling back on
     *io.DEFAULT_BUFFER_SIZE*. On many systems, the buffer will
     typically be 4096 or 8192 bytes long.

   * "Interactive" text files (files for which isatty() returns
     True) use line buffering.  Other text files use the policy
     described above for binary files.

   encoding is the name of the encoding used to decode or encode the
   file. This should only be used in text mode. The default encoding
   is platform dependent, but any encoding supported by Python can be
   passed.  See the codecs module for the list of supported encodings.

   errors is an optional string that specifies how encoding errors are
   to be handled---this argument should not be used in binary mode.
   Pass 'strict' to raise a ValueError exception if there is an
   encoding error (the default of None has the same effect), or pass
   'ignore' to ignore errors. (Note that ignoring encoding errors can
   lead to data loss.) See the documentation for codecs.register or
   run 'help(codecs.Codec)' for a list of the permitted encoding error
   strings.

   newline controls how universal newlines works (it only applies to
   text mode). It can be None, '', 'n', 'r', and 'rn'.  It works as
   follows:

   * On input, if newline is None, universal newlines mode is
     enabled. Lines in the input can end in 'n', 'r', or 'rn', and
     these are translated into 'n' before being returned to the
     caller. If it is '', universal newline mode is enabled, but line
     endings are returned to the caller untranslated. If it has any of
     the other legal values, input lines are only terminated by the
     given string, and the line ending is returned to the caller
     untranslated.

   * On output, if newline is None, any 'n' characters written are
     translated to the system default line separator, os.linesep. If
     newline is '' or 'n', no translation takes place. If newline is
     any of the other legal values, any 'n' characters written are
     translated to the given string.

   If closefd is False, the underlying file descriptor will be kept
   open when the file is closed. This does not work when a file name
   is given and must be True in that case.

   A custom opener can be used by passing a callable as *opener*. The
   underlying file descriptor for the file object is then obtained by
   calling *opener* with (*file*, *flags*). *opener* must return an
   open file descriptor (passing os.open as *opener* results in
   functionality similar to passing None).

   open() returns a file object whose type depends on the mode, and
   through which the standard file operations such as reading and
   writing are performed. When open() is used to open a file in a text
   mode ('w', 'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When
   used to open a file in a binary mode, the returned class varies: in
   read binary mode, it returns a BufferedReader; in write binary and
   append binary modes, it returns a BufferedWriter, and in read/write
   mode, it returns a BufferedRandom.

   It is also possible to use a string or bytearray as a file for both
   reading and writing. For strings StringIO can be used like a file
   opened in a text mode, and for bytes a BytesIO can be used like a
   file opened in a binary mode.

On procède de même avec le fichier d'horodatage, sauf que le nom ne
sera pas data_i mais timestamp.


Initialisation de l'horodatage
==============================

L'initialisation de l'horodatage est faite dans la boucle principale
pour avoir le moins d'écart entre l'initialisation du temps et la
première mesure, i.e pour que la première mesure ait pour abscisse 0.

Pour cela on crée un booléen timestampInitDone qu'on met à False au
début. On va donc faire l'initialisation du timestamp  si et seulement
si timestampInitDone est à False :

               #### CREATION DU TIMESTAMP ####

On utilise la fonction time.time pour initialiser l'horodatage :

time.time()

   time() -> floating point number

   Return the current time in seconds since the Epoch. Fractions of a
   second may be present if the system clock provides them.

On met ensuite le booléen timestampInitDone à True pour indiquer que
l'initialisation de l'horodatage a été effectuée.
