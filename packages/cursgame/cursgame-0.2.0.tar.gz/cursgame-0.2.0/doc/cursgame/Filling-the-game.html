<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is a manual to the Cursgame library. It should get you an idea
how to start.

Copyright (C) 2013 Sven Bartscher.

Licensed under the EUPL, Version 1.1 or - as soon they
will be approved by the European Commission - subsequent
versions of the EUPL (the "Licence");
You may not use this work except in compliance with the
Licence.
You may obtain a copy of the Licence at:
http://ec.europa.eu/idabc/eupl -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Cursgame Manual 0.2.0: Filling the game</title>

<meta name="description" content="Cursgame Manual 0.2.0: Filling the game">
<meta name="keywords" content="Cursgame Manual 0.2.0: Filling the game">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Index.html#Index" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Getting-started.html#Getting-started" rel="up" title="Getting started">
<link href="AIs.html#AIs" rel="next" title="AIs">
<link href="Starting-a-game.html#Starting-a-game" rel="prev" title="Starting a game">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Filling-the-game"></a>
<div class="header">
<p>
Next: <a href="AIs.html#AIs" accesskey="n" rel="next">AIs</a>, Previous: <a href="Starting-a-game.html#Starting-a-game" accesskey="p" rel="prev">Starting a game</a>, Up: <a href="Getting-started.html#Getting-started" accesskey="u" rel="up">Getting started</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Filling-the-game-1"></a>
<h3 class="section">1.2 Filling the game</h3>
<p>Once you started the game you will see that nothing&rsquo;s going on.  In
this section i will describe what to do to make stuff happen. In this
section we will expand the code from the last chapter.  So i assume
that you did read it.  To follow this section to a working program you
need to insert the code, showed in this section, after the
instanciation of the game and before game.start() is called.
</p>
<a name="A-player"></a>
<h4 class="subsection">1.2.1 A player</h4>
<p>The first thing we might want to have is a player.  A player is a
subclass of an Obj.  Everything that can be placed in the game and can
act in the game is an Obj.  That&rsquo;s all you need to know about Objs for
now. For creating our player we need to import
<code>cursgame.character</code>.  What we want from there is the class
Human.  Later you can make your own Obj subclasses, for more on that
see <a href="#Objs">Objs</a>.  But for now we will only use the Human.  We create and
place the player like this: 
</p><div class="example">
<pre class="example">player = cursgame.character.Human()
mp.place(player, 0, 0)
mp.lookon = player
</pre></div>
<p>Let&rsquo;s go through this line by line:<br>
The first line creates an instance of the Human class. This object
instance represents our player.<br>
The second line places the player on the map, at the position 0, 0.
This is marked with the last two aguments.  See <a href="Module-map.html#Map_002eplace">Map.place</a>, for more
information on the place function.<br>
The third line assigns our player to the lookon variable.  This tells
the game that the screen should be centered at our
player. See <a href="Module-map.html#Map_002elookon">Map.lookon</a>, for more information on this variable.
</p>
<a name="index-InputHandler_002dinstructions-introduction"></a>
<a name="index-Instructing-the-InputHandler-in-brief"></a>
<a name="index-InputHandler-callbacks-introduction"></a>
<a name="index-Using-the-InputHandler-in-brief"></a>
<a name="Control"></a>
<h4 class="subsection">1.2.2 Control</h4>
<p>Now we want to be able to control our player.  To do that we need to
give instructions to the InputHandler. See <a href="Module-inp.html#InputHandler">InputHandler</a>, for more on InputHandlers.  The
InputHandler holds an dictionary called callbacks (so it is accessable
through inp.callbacks).  Every time an input event is encountered the
InputHandler looks in the dictionary for the event and executes the
result.  So the result should be a callable.  Otherwise an error will
occur.  <code>cursgame.inp</code> holds a bunch of constants related to
keys.  See <a href="Module-inp.html#key_002dconstants">key-constants</a>, for the meaning of the constants.  For
letter-keys it&rsquo;s enough to assign the the function to the unicode of
the letter.
So let&rsquo;s set up basic control for our player:
</p><div class="example">
<pre class="example">inp.callbacks[ord('q')] = game.set_end
inp.callbacks[cursgame.inp.KEY_DOWN] = lambda _: player.move(0, 1)
inp.callbacks[cursgame.inp.KEY_LEFT] = lambda _: player.move(-1, 0)
inp.callbacks[cursgame.inp.KEY_UP] = lambda _: player.move(0, -1)
inp.callbacks[cursgame.inp.KEY_RIGHT] = lambda _: player.move(1, 0)
</pre></div>
<p>The first line instructs the InputHandler to end the game if Q is
pressed.  See <a href="Module-game.html#Ending-the-game">Ending the game</a>, for more on <code>game.set_end</code>.
The other lines are a bit more complicated, but they all follow the
same pattern.  Let&rsquo;s first take a look at the part left of the equal
sign.  <code>inp.callbacks[cursgame.inp.KEY_DOWN]</code> means that we want
to assign a function that is called when the key related to KEY_DOWN
is pressed.  As you might thought, KEY_DOWN refers to the down-key.
The right side of the equal sign is the place where the real work is
done.  The values of the dictionary must be functions taking exactly
one argument.  When we want to move an Obj (remember our player is an
Obj) we call it&rsquo;s move method. But move takes two arguments, telling
where to move.  So we need to make another function that takes exactly
one function.  That&rsquo;s what the lambda is for.  The one argument we get
isn&rsquo;t in our interest since it contains the key event that was caught
by the InputHandler.  Most of the time we don&rsquo;t need this but it
becomes handy of we assign one function to multiple key-events.  So
basically the right part of the equal sign is a function moving the
player by by (0, 1), which is one field down.  The last three lines
follow the same pattern. See <a href="Module-character.html#Obj_002emove">Obj.move</a>, for more information at
moving player.move.
</p>
<a name="index-Obj-metaclass-introduction"></a>
<a name="Objs-1"></a>
<h4 class="subsection">1.2.3 Objs</h4>
<a name="Objs"></a><p>Now we can move our player. But that&rsquo;s a bit stupid and boring if
there&rsquo;s nothing to see when walking.  In fact there&rsquo;s nothing except
our player, the border of the map and empty fields.  So let&rsquo;s place
some walls.  How do we do that?  First we need to subclass the Obj
class, which is located at <code>cursgame.character</code>.  So we already
imported it along with the Human.  Allow me to first show you how we
subclass it and then describe what we did:
</p><div class="example">
<pre class="example">class Wall(cursgame.character.Obj):
    def __str__(self):
        return &quot;#&quot;

    def activate(self, activater, x, y):
        return False
</pre></div>
<p>And that&rsquo;s all you need for a wall.  It inherits from Obj.  It&rsquo;s
__str__ says how it should be presented on the map.  In this case a
Wall has the # sign as a representation.  Just like Humans have
the @ sign.  The activate function is called when another Objs wants
to enter the field where this Obj is already.  The return value is
used to determine wether the step on this Obj succedes and the moving
Obj should be moved to the new position.  In this case we simply
return False because it&rsquo;s not allowed to step on walls.
See <a href="Module-character.html#Obj_002eactivate">Obj.activate</a>, for more on this topic.
</p>
<a name="Placing-the-wall"></a>
<h4 class="subsubsection">1.2.3.1 Placing the wall</h4>
<p>Now we have to place the wall so it has an effect in the game.  This
is simply done by first instanciating it and then placing it. Just
like the player. Here&rsquo;s the code:
</p><div class="example">
<pre class="example">wall = Wall()
mp.place(wall, 10, 10)
</pre></div>
<p>This places the wall at 10;10.
</p>
<a name="index-Colors-introduction"></a>
<a name="index-Painting-Objs"></a>
<a name="index-Painting-objects-on-the-screen"></a>
<a name="Color"></a>
<h4 class="subsubsection">1.2.3.2 Color</h4>
<p>Now we can paint our wall.  For that take a brush and a little bit
paint of your favorite color.  Then start the game and paint the wall
on the screen using your brush...  Sounds stupid?  It is!  I prefer
the cursgame-way to paint Objs.  Just like __str__ is used to
determine the textual representation of an Obj the color method is
used to determine the color of an Obj.  For that purpose
<code>cursgame.color</code> holds a set of color-constants you can
return. Let&rsquo;s take a green wall.  So we add this method to our Wall
class:
</p><div class="example">
<pre class="example">    def color(self):
        return cursgame.color.GREEN
</pre></div>
<p>Don&rsquo;t forget to add <code>import cursgame.color</code> to your imports!  Now
your wall should be green, without making you screen permanently
green!  See <a href="Module-color.html#colors">colors</a>, for more on colors.
</p>
<hr>
<div class="header">
<p>
Next: <a href="AIs.html#AIs" accesskey="n" rel="next">AIs</a>, Previous: <a href="Starting-a-game.html#Starting-a-game" accesskey="p" rel="prev">Starting a game</a>, Up: <a href="Getting-started.html#Getting-started" accesskey="u" rel="up">Getting started</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html#Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
