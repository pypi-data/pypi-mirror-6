<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Sparse Linear Equations &mdash; CVXOPT User&#39;s Guide</title>
    
    <link rel="stylesheet" href="_static/cvxopt.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="CVXOPT User&#39;s Guide" href="index.html" />
    <link rel="next" title="Cone Programming" href="coneprog.html" />
    <link rel="prev" title="Discrete Transforms" href="fftw.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="coneprog.html" title="Cone Programming"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="fftw.html" title="Discrete Transforms"
             accesskey="P">previous</a> |</li>
    <li><a href="http://cvxopt.org">CVXOPT home</a> |</li>
    
        <li><a href="index.html">user&#39;s guide</a> </li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="sparse-linear-equations">
<span id="c-spsolvers"></span><h1>Sparse Linear Equations<a class="headerlink" href="#sparse-linear-equations" title="Permalink to this headline">¶</a></h1>
<p>In this section we describe routines for solving sparse sets of linear
equations.</p>
<p>A real symmetric or complex Hermitian sparse matrix is stored as an
<a class="reference internal" href="matrices.html#cvxopt.spmatrix" title="cvxopt.spmatrix"><tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt></a> object <tt class="docutils literal"><span class="pre">X</span></tt>  of size
(<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>) and an
additional character argument <tt class="docutils literal"><span class="pre">uplo</span></tt> with possible values <tt class="xref py py-const docutils literal"><span class="pre">'L'</span></tt>
and <tt class="xref py py-const docutils literal"><span class="pre">'U'</span></tt>.  If <tt class="docutils literal"><span class="pre">uplo</span></tt> is <tt class="xref py py-const docutils literal"><span class="pre">'L'</span></tt>, the lower triangular part
of <tt class="docutils literal"><span class="pre">X</span></tt> contains the lower triangular part of the symmetric or Hermitian
matrix, and the upper triangular matrix of <tt class="docutils literal"><span class="pre">X</span></tt> is ignored.  If <tt class="docutils literal"><span class="pre">uplo</span></tt>
is <tt class="xref py py-const docutils literal"><span class="pre">'U'</span></tt>, the upper triangular part of <tt class="docutils literal"><span class="pre">X</span></tt> contains the upper
triangular part of the matrix, and the lower triangular matrix of <tt class="docutils literal"><span class="pre">X</span></tt> is
ignored.</p>
<p>A general sparse square matrix of order <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> is represented by an
<tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt> object of size (<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>, <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>).</p>
<p>Dense matrices, which appear as right-hand sides of equations, are
stored using the same conventions as in the BLAS and LAPACK modules.</p>
<div class="section" id="matrix-orderings">
<span id="s-orderings"></span><h2>Matrix Orderings<a class="headerlink" href="#matrix-orderings" title="Permalink to this headline">¶</a></h2>
<p>CVXOPT includes an interface to the AMD library for computing approximate
minimum degree orderings of sparse matrices.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="http://www.cise.ufl.edu/research/sparse/amd">AMD code, documentation, copyright, and license</a></li>
<li>P. R. Amestoy, T. A. Davis, I. S. Duff,  Algorithm 837: AMD, An
Approximate Minimum Degree Ordering Algorithm, ACM Transactions on
Mathematical Software, 30(3), 381-388, 2004.</li>
</ul>
</div>
<dl class="function">
<dt id="cvxopt.amd.order">
<tt class="descclassname">cvxopt.amd.</tt><tt class="descname">order</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.amd.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the approximate mimimum degree ordering of a symmetric  sparse
matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.  The ordering is returned as an integer dense matrix
with length equal to the order of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>.  Its entries specify a
permutation that reduces fill-in during the Cholesky factorization.
More precisely, if <tt class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">order(A)</span></tt> , then <tt class="docutils literal"><span class="pre">A[p,</span> <span class="pre">p]</span></tt> has
sparser Cholesky factors than <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
</dd></dl>

<p>As an example we consider the matrix</p>
<div class="math">
<p><img src="_images/math/87c716e048b6466c0459d609f9ca1d12c92df084.png" alt="\left[ \begin{array}{rrrr}
 10 &amp;  0 &amp; 3 &amp;  0 \\
  0 &amp;  5 &amp; 0 &amp; -2 \\
  3 &amp;  0 &amp; 5 &amp;  0 \\
  0 &amp; -2 &amp; 0 &amp;  2
\end{array}\right]."/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">amd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">amd</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[ 1]</span>
<span class="go">[ 0]</span>
<span class="go">[ 2]</span>
<span class="go">[ 3]</span>
</pre></div>
</div>
</div>
<div class="section" id="general-linear-equations">
<span id="s-umfpack"></span><h2>General Linear Equations<a class="headerlink" href="#general-linear-equations" title="Permalink to this headline">¶</a></h2>
<p>The module <tt class="xref py py-mod docutils literal"><span class="pre">cvxopt.umfpack</span></tt> includes four functions for solving
sparse non-symmetric sets of linear equations.  They call routines from
the UMFPACK library, with all control options set to the default values
described in the UMFPACK user guide.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="http://www.cise.ufl.edu/research/sparse/umfpack">UMFPACK code, documentation, copyright, and license</a></li>
<li>T. A. Davis, Algorithm 832: UMFPACK &#8211; an unsymmetric-pattern
multifrontal method with a column pre-ordering strategy, ACM
Transactions on Mathematical Software, 30(2), 196-199, 2004.</li>
</ul>
</div>
<dl class="function">
<dt id="cvxopt.umfpack.linsolve">
<tt class="descclassname">cvxopt.umfpack.</tt><tt class="descname">linsolve</tt><big>(</big><em>A</em>, <em>B</em><span class="optional">[</span>, <em>trans = 'N'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.umfpack.linsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a sparse set of linear equations</p>
<div class="math">
<p><img src="_images/math/321775dc9a96e932341dc2b5efc498827c162856.png" alt="AX &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is a sparse matrix and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> is a dense matrix.
The arguments <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> must have the same type
(<tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt>) as <tt class="docutils literal"><span class="pre">A</span></tt>.  On exit <tt class="docutils literal"><span class="pre">B</span></tt> contains
the solution.  Raises an <tt class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></tt> if the coefficient
matrix is singular.</p>
</dd></dl>

<p>In the following example we solve an equation with coefficient matrix</p>
<div class="math" id="equation-e-sp-Adef">
<p><span class="eqno">(1)</span><img src="_images/math/48cec103218010fa067eea0252f644c77d7dcffd.png" alt="A = \left[\begin{array}{rrrrr}
    2 &amp; 3 &amp; 0 &amp; 0 &amp; 0 \\
    3 &amp; 0 &amp; 4 &amp; 0 &amp; 6 \\
    0 &amp;-1 &amp;-3 &amp; 2 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 4 &amp; 2 &amp; 0 &amp; 1
    \end{array}\right]."/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">umfpack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">umfpack</span><span class="o">.</span><span class="n">linsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 5.79e-01]</span>
<span class="go">[-5.26e-02]</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 1.97e+00]</span>
<span class="go">[-7.89e-01]</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="#cvxopt.umfpack.linsolve" title="cvxopt.umfpack.linsolve"><tt class="xref py py-func docutils literal"><span class="pre">linsolve</span></tt></a>  is
equivalent to the following three functions called in sequence.</p>
<dl class="function">
<dt id="cvxopt.umfpack.symbolic">
<tt class="descclassname">cvxopt.umfpack.</tt><tt class="descname">symbolic</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#cvxopt.umfpack.symbolic" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorders the columns of <tt class="docutils literal"><span class="pre">A</span></tt> to reduce fill-in and performs a symbolic
LU factorization.  <tt class="docutils literal"><span class="pre">A</span></tt> is a sparse, possibly rectangular, matrix.
Returns the symbolic factorization as an opaque C object that can be
passed on to <a class="reference internal" href="#cvxopt.umfpack.numeric" title="cvxopt.umfpack.numeric"><tt class="xref py py-func docutils literal"><span class="pre">numeric</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.umfpack.numeric">
<tt class="descclassname">cvxopt.umfpack.</tt><tt class="descname">numeric</tt><big>(</big><em>A</em>, <em>F</em><big>)</big><a class="headerlink" href="#cvxopt.umfpack.numeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a numeric LU factorization of a sparse, possibly rectangular,
matrix <tt class="docutils literal"><span class="pre">A</span></tt>.   The argument <tt class="docutils literal"><span class="pre">F</span></tt> is the symbolic factorization
computed by <a class="reference internal" href="#cvxopt.umfpack.symbolic" title="cvxopt.umfpack.symbolic"><tt class="xref py py-func docutils literal"><span class="pre">symbolic</span></tt></a>
applied to the matrix <tt class="docutils literal"><span class="pre">A</span></tt>,
or another sparse matrix with the same sparsity pattern, dimensions,
and type.  The numeric factorization is returned as an opaque C object
that that can be passed on to
<a class="reference internal" href="#cvxopt.umfpack.solve" title="cvxopt.umfpack.solve"><tt class="xref py py-func docutils literal"><span class="pre">solve</span></tt></a>.  Raises an
<tt class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></tt> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.umfpack.solve">
<tt class="descclassname">cvxopt.umfpack.</tt><tt class="descname">solve</tt><big>(</big><em>A</em>, <em>F</em>, <em>B</em><span class="optional">[</span>, <em>trans = 'N'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.umfpack.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/321775dc9a96e932341dc2b5efc498827c162856.png" alt="AX &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is a sparse matrix and <img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> is a dense matrix.
The arguments <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> must have the same type.  The argument
<tt class="docutils literal"><span class="pre">F</span></tt> is a numeric factorization computed
by <a class="reference internal" href="#cvxopt.umfpack.numeric" title="cvxopt.umfpack.numeric"><tt class="xref py py-func docutils literal"><span class="pre">numeric</span></tt></a>.
On exit <tt class="docutils literal"><span class="pre">B</span></tt> is overwritten by the
solution.</p>
</dd></dl>

<p>These separate functions are useful for solving several sets of linear
equations with the same coefficient matrix and different right-hand sides,
or with coefficient matrices that share the same sparsity pattern.
The symbolic factorization depends only on the sparsity pattern of
the matrix, and not on the numerical values of the nonzero coefficients.
The numerical factorization on the other hand depends on the sparsity
pattern of the matrix and on its the numerical values.</p>
<p>As an example, suppose <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> is the matrix <a href="#equation-e-sp-Adef">(1)</a> and</p>
<div class="math">
<p><img src="_images/math/93876b6d08a3f850d1f4aba28cd41ca97d66880a.png" alt="B = \left[\begin{array}{rrrrr}
    4 &amp; 3 &amp; 0 &amp; 0 &amp; 0 \\
    3 &amp; 0 &amp; 4 &amp; 0 &amp; 6 \\
    0 &amp;-1 &amp;-3 &amp; 2 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 4 &amp; 2 &amp; 0 &amp; 2
    \end{array}\right],"/></p>
</div><p>which differs from <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> in its first and last entries.  The following
code computes</p>
<div class="math">
<p><img src="_images/math/1babc743714fba131456bbe2234d595634fb5812.png" alt="\newcommand{\ones}{\mathbf 1}
x = A^{-T}B^{-1}A^{-1}\ones."/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">umfpack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">VA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">VB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">VA</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">VB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Fs</span> <span class="o">=</span> <span class="n">umfpack</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FA</span> <span class="o">=</span> <span class="n">umfpack</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FB</span> <span class="o">=</span> <span class="n">umfpack</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">umfpack</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">FA</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">umfpack</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">FB</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">umfpack</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">FA</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 5.81e-01]</span>
<span class="go">[-2.37e-01]</span>
<span class="go">[ 1.63e+00]</span>
<span class="go">[ 8.07e+00]</span>
<span class="go">[-1.31e-01]</span>
</pre></div>
</div>
</div>
<div class="section" id="positive-definite-linear-equations">
<span id="s-cholmod"></span><h2>Positive Definite Linear Equations<a class="headerlink" href="#positive-definite-linear-equations" title="Permalink to this headline">¶</a></h2>
<p><tt class="xref py py-mod docutils literal"><span class="pre">cvxopt.cholmod</span></tt> is an interface to the Cholesky factorization routines
of the CHOLMOD package.  It includes functions for Cholesky factorization
of sparse positive definite matrices, and for solving sparse sets of linear
equations with positive definite matrices.
The routines can also be used for computing
<span class="raw-html">LDL<sup><small>T</small></sup></span>
(or
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorizations
of symmetric indefinite matrices (with <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> unit lower-triangular and
<img class="math" src="_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/> diagonal and nonsingular) if such a factorization exists.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://www.cise.ufl.edu/research/sparse/cholmod">CHOLMOD code, documentation, copyright, and license</a></p>
</div>
<dl class="function">
<dt id="cvxopt.cholmod.linsolve">
<tt class="descclassname">cvxopt.cholmod.</tt><tt class="descname">linsolve</tt><big>(</big><em>A</em>, <em>B</em><span class="optional">[</span>, <em>p = None</em>, <em>uplo = 'L'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.cholmod.linsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/1beb2d429fd60d4494135aa7af1b4fe324dc8d3d.png" alt="AX = B"/></p>
</div><p>with <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> sparse and real symmetric or complex Hermitian.</p>
<p><tt class="docutils literal"><span class="pre">B</span></tt> is a dense matrix of the same type as <tt class="docutils literal"><span class="pre">A</span></tt>.  On exit it
is overwritten with the solution.  The argument <tt class="docutils literal"><span class="pre">p</span></tt> is an integer
matrix with length equal to the order of <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/>, and specifies an
optional reordering.  If <tt class="docutils literal"><span class="pre">p</span></tt> is not specified, CHOLMOD uses a
reordering from the AMD library.</p>
<p>Raises an <tt class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></tt> if the factorization does not exist.</p>
</dd></dl>

<p>As an  example, we solve</p>
<div class="math" id="equation-e-A-pd">
<p><span class="eqno">(2)</span><img src="_images/math/26f49cfedfe23893d865d6299ceca29dc390c53b.png" alt="\left[ \begin{array}{rrrr}
        10 &amp;  0 &amp; 3 &amp;  0 \\
         0 &amp;  5 &amp; 0 &amp; -2 \\
         3 &amp;  0 &amp; 5 &amp;  0 \\
         0 &amp; -2 &amp; 0 &amp;  2
    \end{array}\right] X =
    \left[ \begin{array}{cc}
         0 &amp; 4 \\ 1 &amp; 5 \\ 2 &amp; 6 \\ 3 &amp; 7
    \end{array} \right]."/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">cholmod</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">linsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">[-1.46e-01  4.88e-02]</span>
<span class="go">[ 1.33e+00  4.00e+00]</span>
<span class="go">[ 4.88e-01  1.17e+00]</span>
<span class="go">[ 2.83e+00  7.50e+00]</span>
</pre></div>
</div>
<dl class="function">
<dt id="cvxopt.cholmod.splinsolve">
<tt class="descclassname">cvxopt.cholmod.</tt><tt class="descname">splinsolve</tt><big>(</big><em>A</em>, <em>B</em><span class="optional">[</span>, <em>p = None</em>, <em>uplo = 'L'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.cholmod.splinsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#cvxopt.cholmod.linsolve" title="cvxopt.cholmod.linsolve"><tt class="xref py py-func docutils literal"><span class="pre">linsolve</span></tt></a> except that
<tt class="docutils literal"><span class="pre">B</span></tt> is an <a class="reference internal" href="matrices.html#cvxopt.spmatrix" title="cvxopt.spmatrix"><tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt></a> and
that the solution is returned as an output argument (as a new
<tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt>).  <tt class="docutils literal"><span class="pre">B</span></tt> is not modified.</p>
</dd></dl>

<p>The following code computes the inverse of the coefficient matrix
in <a href="#equation-e-A-pd">(2)</a> as a sparse matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">splinsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">[ 1.22e-01     0     -7.32e-02     0    ]</span>
<span class="go">[    0      3.33e-01     0      3.33e-01]</span>
<span class="go">[-7.32e-02     0      2.44e-01     0    ]</span>
<span class="go">[    0      3.33e-01     0      8.33e-01]</span>
</pre></div>
</div>
<p>The functions <a class="reference internal" href="#cvxopt.cholmod.linsolve" title="cvxopt.cholmod.linsolve"><tt class="xref py py-func docutils literal"><span class="pre">linsolve</span></tt></a> and
<a class="reference internal" href="#cvxopt.cholmod.splinsolve" title="cvxopt.cholmod.splinsolve"><tt class="xref py py-func docutils literal"><span class="pre">splinsolve</span></tt></a> are equivalent to
<a class="reference internal" href="#cvxopt.cholmod.symbolic" title="cvxopt.cholmod.symbolic"><tt class="xref py py-func docutils literal"><span class="pre">symbolic</span></tt></a> and
<a class="reference internal" href="#cvxopt.cholmod.numeric" title="cvxopt.cholmod.numeric"><tt class="xref py py-func docutils literal"><span class="pre">numeric</span></tt></a> called in sequence, followed by
<a class="reference internal" href="#cvxopt.cholmod.solve" title="cvxopt.cholmod.solve"><tt class="xref py py-func docutils literal"><span class="pre">solve</span></tt></a>, respectively,
<a class="reference internal" href="#cvxopt.cholmod.spsolve" title="cvxopt.cholmod.spsolve"><tt class="xref py py-func docutils literal"><span class="pre">spsolve</span></tt></a>.</p>
<dl class="function">
<dt id="cvxopt.cholmod.symbolic">
<tt class="descclassname">cvxopt.cholmod.</tt><tt class="descname">symbolic</tt><big>(</big><em>A</em><span class="optional">[</span>, <em>p = None</em>, <em>uplo = 'L'</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.cholmod.symbolic" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a symbolic analysis of a sparse real symmetric or
complex Hermitian matrix <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> for one of the two factorizations:</p>
<div class="math" id="equation-e-chol-ll">
<p><span class="eqno">(3)</span><img src="_images/math/15cc63ee73ef52c69c9de3b3349cd0c5e7b7fd49.png" alt="PAP^T = LL^T, \qquad PAP^T = LL^H,"/></p>
</div><p>and</p>
<div class="math" id="equation-e-chol-ldl">
<p><span class="eqno">(4)</span><img src="_images/math/e19bbf7b0589a31564d0f2b5183804851cb8846e.png" alt="PAP^T = LDL^T, \qquad PAP^T = LDL^H,"/></p>
</div><p>where <img class="math" src="_images/math/f48b617185733d8dd6712643f1ab17c736661a06.png" alt="P"/> is a permutation matrix, <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> is lower triangular
(unit lower triangular in the second factorization), and <img class="math" src="_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/> is
nonsingular diagonal.  The type of factorization depends on the value
of <tt class="xref py py-attr docutils literal"><span class="pre">options['supernodal']</span></tt> (see below).</p>
<p>If <tt class="docutils literal"><span class="pre">uplo</span></tt> is <tt class="xref py py-const docutils literal"><span class="pre">'L'</span></tt>, only the lower triangular part of <tt class="docutils literal"><span class="pre">A</span></tt>
is accessed and the upper triangular part is ignored.
If <tt class="docutils literal"><span class="pre">uplo</span></tt> is <tt class="xref py py-const docutils literal"><span class="pre">'U'</span></tt>, only the upper triangular part of <tt class="docutils literal"><span class="pre">A</span></tt>
is accessed and the lower triangular part is ignored.</p>
<p>If <tt class="docutils literal"><span class="pre">p</span></tt> is not provided, a reordering from the AMD library is used.</p>
<p>The symbolic factorization is returned as an opaque C object that
can be passed to <a class="reference internal" href="#cvxopt.cholmod.numeric" title="cvxopt.cholmod.numeric"><tt class="xref py py-func docutils literal"><span class="pre">numeric</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.cholmod.numeric">
<tt class="descclassname">cvxopt.cholmod.</tt><tt class="descname">numeric</tt><big>(</big><em>A</em>, <em>F</em><big>)</big><a class="headerlink" href="#cvxopt.cholmod.numeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a numeric factorization of a sparse symmetric matrix
as <a href="#equation-e-chol-ll">(3)</a> or <a href="#equation-e-chol-ldl">(4)</a>.  The argument <tt class="docutils literal"><span class="pre">F</span></tt> is the
symbolic factorization computed by
<a class="reference internal" href="#cvxopt.cholmod.symbolic" title="cvxopt.cholmod.symbolic"><tt class="xref py py-func docutils literal"><span class="pre">symbolic</span></tt></a> applied to
the matrix <tt class="docutils literal"><span class="pre">A</span></tt>, or to another sparse  matrix with the same sparsity
pattern and typecode, or by
<a class="reference internal" href="#cvxopt.cholmod.numeric" title="cvxopt.cholmod.numeric"><tt class="xref py py-func docutils literal"><span class="pre">numeric</span></tt></a> applied to a matrix
with the same sparsity pattern and typecode as <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">F</span></tt> was created by a
<a class="reference internal" href="#cvxopt.cholmod.symbolic" title="cvxopt.cholmod.symbolic"><tt class="xref py py-func docutils literal"><span class="pre">symbolic</span></tt></a> with <tt class="docutils literal"><span class="pre">uplo</span></tt>
equal
to <tt class="xref py py-const docutils literal"><span class="pre">'L'</span></tt>, then only the lower triangular part of <tt class="docutils literal"><span class="pre">A</span></tt> is
accessed and the upper triangular part is ignored.  If it was created
with <tt class="docutils literal"><span class="pre">uplo</span></tt> equal to <tt class="xref py py-const docutils literal"><span class="pre">'U'</span></tt>, then only the upper triangular
part of <tt class="docutils literal"><span class="pre">A</span></tt> is accessed and the lower triangular part is ignored.</p>
<p>On successful exit, the factorization is stored in <tt class="docutils literal"><span class="pre">F</span></tt>.
Raises an <tt class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></tt> if the factorization does not exist.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.cholmod.solve">
<tt class="descclassname">cvxopt.cholmod.</tt><tt class="descname">solve</tt><big>(</big><em>F</em>, <em>B</em><span class="optional">[</span>, <em>sys = 0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.cholmod.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves one of the following linear equations where <tt class="docutils literal"><span class="pre">B</span></tt> is a dense
matrix and <tt class="docutils literal"><span class="pre">F</span></tt> is the numeric factorization <a href="#equation-e-chol-ll">(3)</a>
or <a href="#equation-e-chol-ldl">(4)</a> computed by
<a class="reference internal" href="#cvxopt.cholmod.numeric" title="cvxopt.cholmod.numeric"><tt class="xref py py-func docutils literal"><span class="pre">numeric</span></tt></a>.
<tt class="docutils literal"><span class="pre">sys</span></tt> is an integer with values between 0 and 8.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">sys</span></tt></td>
<td>equation</td>
</tr>
<tr class="row-even"><td>0</td>
<td><img class="math" src="_images/math/6e98fc286854081ea2b9adf373df551256afff7c.png" alt="AX = B"/></td>
</tr>
<tr class="row-odd"><td>1</td>
<td><img class="math" src="_images/math/9933c894ca1816b4c192bb1e05f3ca0235b700cc.png" alt="LDL^TX = B"/></td>
</tr>
<tr class="row-even"><td>2</td>
<td><img class="math" src="_images/math/e72a184be24a21b39b31cc95d26e6608c73484b0.png" alt="LDX = B"/></td>
</tr>
<tr class="row-odd"><td>3</td>
<td><img class="math" src="_images/math/fd4a8900a7d32aa765cff143ac4c964935bc071d.png" alt="DL^TX=B"/></td>
</tr>
<tr class="row-even"><td>4</td>
<td><img class="math" src="_images/math/47b3ae0420c52db79daf3c6b84a01b2bcc5de5a3.png" alt="LX=B"/></td>
</tr>
<tr class="row-odd"><td>5</td>
<td><img class="math" src="_images/math/0999de156f97ffbe09679a57d21b84dd9f9b35e4.png" alt="L^TX=B"/></td>
</tr>
<tr class="row-even"><td>6</td>
<td><img class="math" src="_images/math/c13187825263b2dc8bae4e30d0d15cf8670b6956.png" alt="DX=B"/></td>
</tr>
<tr class="row-odd"><td>7</td>
<td><img class="math" src="_images/math/cd01aaaa1674ff77afb5f645d5eacd0f2ec1b573.png" alt="P^TX=B"/></td>
</tr>
<tr class="row-even"><td>8</td>
<td><img class="math" src="_images/math/80f8ee73e5a62640aeb2442e3f5c66a1de7a5518.png" alt="PX=B"/></td>
</tr>
</tbody>
</table>
<p>(If <tt class="docutils literal"><span class="pre">F</span></tt> is a Cholesky factorization of the form <a href="#equation-e-chol-ll">(3)</a>,
<img class="math" src="_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/> is an identity matrix in this table.  If <tt class="docutils literal"><span class="pre">A</span></tt> is complex,
<img class="math" src="_images/math/21e56698fba40d0ef90a50ff5eac3239f56c6dc6.png" alt="L^T"/> should be replaced by <img class="math" src="_images/math/3fe72eac326113d25ef1eb961213c508f763c92a.png" alt="L^H"/>.)</p>
<p>The matrix <tt class="docutils literal"><span class="pre">B</span></tt> is a dense <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt> matrix, with
the same type as <tt class="docutils literal"><span class="pre">A</span></tt>.  On exit it is overwritten by the solution.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.cholmod.spsolve">
<tt class="descclassname">cvxopt.cholmod.</tt><tt class="descname">spsolve</tt><big>(</big><em>F</em>, <em>B</em><span class="optional">[</span>, <em>sys = 0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.cholmod.spsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#cvxopt.cholmod.solve" title="cvxopt.cholmod.solve"><tt class="xref py py-func docutils literal"><span class="pre">solve</span></tt></a>, except that <tt class="docutils literal"><span class="pre">B</span></tt> is
a class:<cite>spmatrix</cite>, and the solution is returned as an output argument
(as an <tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt>).  <tt class="docutils literal"><span class="pre">B</span></tt> must have the same typecode as <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
</dd></dl>

<p>For the same example as above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">[-1.46e-01  4.88e-02]</span>
<span class="go">[ 1.33e+00  4.00e+00]</span>
<span class="go">[ 4.88e-01  1.17e+00]</span>
<span class="go">[ 2.83e+00  7.50e+00]</span>
</pre></div>
</div>
<dl class="function">
<dt id="cvxopt.cholmod.diag">
<tt class="descclassname">cvxopt.cholmod.</tt><tt class="descname">diag</tt><big>(</big><em>F</em><big>)</big><a class="headerlink" href="#cvxopt.cholmod.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the diagonal elements of the Cholesky factor <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/>
in <a href="#equation-e-chol-ll">(3)</a>, as a dense matrix of the same type as <tt class="docutils literal"><span class="pre">A</span></tt>.
Note that this only applies to Cholesky factorizations.  The matrix
<img class="math" src="_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/> in an <span class="raw-html">LDL<sup><small>T</small></sup></span>
factorization can be retrieved via <a class="reference internal" href="#cvxopt.cholmod.solve" title="cvxopt.cholmod.solve"><tt class="xref py py-func docutils literal"><span class="pre">solve</span></tt></a>
with <tt class="docutils literal"><span class="pre">sys</span></tt> equal to 6.</p>
</dd></dl>

<p>In the functions listed above, the default values of the control
parameters described in the CHOLMOD user guide are used, except for
<tt class="xref c c-data docutils literal"><span class="pre">Common-&gt;print</span></tt> which is set to 0 instead of 3 and
<tt class="xref c c-data docutils literal"><span class="pre">Common-&gt;supernodal</span></tt> which is set to 2 instead of 1.
These parameters (and a few others) can be modified by making an
entry in the dictionary <tt class="xref py py-attr docutils literal"><span class="pre">cholmod.options</span></tt>.
The meaning of these parameters is as follows.</p>
<dl class="docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">options['supernodal']</span></tt></dt>
<dd>If equal to 0, a factorization <a href="#equation-e-chol-ldl">(4)</a> is computed using a
simplicial algorithm.  If equal to 2, a factorization <a href="#equation-e-chol-ll">(3)</a>
is computed using a supernodal algorithm.  If equal to 1, the most
efficient of the two factorizations is selected, based on the sparsity
pattern.  Default: 2.</dd>
<dt><tt class="xref py py-attr docutils literal"><span class="pre">options['print']</span></tt></dt>
<dd>A nonnegative integer that controls the amount of output printed to
the screen.  Default: 0 (no output).</dd>
</dl>
<p>As an example that illustrates <a class="reference internal" href="#cvxopt.cholmod.diag" title="cvxopt.cholmod.diag"><tt class="xref py py-func docutils literal"><span class="pre">diag</span></tt></a> and the
use of <tt class="xref py py-attr docutils literal"><span class="pre">cholmod.options</span></tt>, we compute the logarithm of the determinant
of the coefficient matrix in <a href="#equation-e-A-pd">(2)</a> by two methods.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.cholmod</span> <span class="kn">import</span> <span class="n">options</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">cholmod</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">F</span><span class="p">))))</span>
<span class="go">5.50533153593</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">options</span><span class="p">[</span><span class="s">&#39;supernodal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Di</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Di</span><span class="p">,</span> <span class="n">sys</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">Di</span><span class="p">)))</span>
<span class="go">5.50533153593</span>
</pre></div>
</div>
</div>
<div class="section" id="example-covariance-selection">
<h2>Example: Covariance Selection<a class="headerlink" href="#example-covariance-selection" title="Permalink to this headline">¶</a></h2>
<p>This example illustrates the use of the routines for sparse Cholesky
factorization.  We consider the problem</p>
<div class="math" id="equation-e-covsel">
<p><span class="eqno">(5)</span><img src="_images/math/0f86ac5d8da289ce93680172fb5d39fba1f78a77.png" alt="\newcommand{\Tr}{\mathop{\bf tr}}
\begin{array}{ll}
    \mbox{minimize} &amp; -\log\det K + \Tr(KY) \\
    \mbox{subject to} &amp; K_{ij}=0,\quad (i,j) \not \in S.
\end{array}"/></p>
</div><p>The optimization variable is a symmetric matrix <img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/> of order
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and the domain of the problem is the set of positive definite
matrices.  The matrix <img class="math" src="_images/math/b018f9153661cd702305aecc28713fd9705e7cb3.png" alt="Y"/> and the index set <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/> are given.
We assume that all the diagonal positions are included in <img class="math" src="_images/math/11a85f3c69ae6702cb1d99d3de451913b8f84c04.png" alt="S"/>.
This problem arises in maximum likelihood estimation of the covariance
matrix of a zero-mean normal distribution, with constraints
that specify that pairs of variables are conditionally independent.</p>
<p>We can express <img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/> as</p>
<div class="math">
<p><img src="_images/math/8c805be7cd7c66579717675a5f59630263eb7b0e.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
K(x) = E_1\diag(x)E_2^T+E_2\diag(x)E_1^T"/></p>
</div><p>where <img class="math" src="_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> are the nonzero elements in the lower triangular part of
<img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/>, with the diagonal elements scaled by 1/2, and</p>
<div class="math">
<p><img src="_images/math/c86b80d3cf8c7319c3652e5a4453e29840e97a9c.png" alt="E_1 = \left[ \begin{array}{cccc}
    e_{i_1} &amp; e_{i_2} &amp; \cdots &amp; e_{i_q} \end{array}\right], \qquad
E_2 = \left[ \begin{array}{cccc}
    e_{j_1} &amp; e_{j_2} &amp; \cdots &amp; e_{j_q} \end{array}\right],"/></p>
</div><p>where (<img class="math" src="_images/math/4bcc5345587505a3531e55592670a69b99256846.png" alt="i_k"/>, <img class="math" src="_images/math/3544933a920a8ff595213b8ce5a7c34454e8c95b.png" alt="j_k"/>) are the positions of the nonzero entries
in the lower-triangular part of <img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/>.  With this notation, we can
solve problem <a href="#equation-e-covsel">(5)</a> by solving the unconstrained problem</p>
<div class="math">
<p><img src="_images/math/b810258d7f5a5470ef5ee8adda6b7a3957875e70.png" alt="\newcommand{\Tr}{\mathop{\bf tr}}
\begin{array}{ll}
\mbox{minimize} &amp; f(x) = -\log\det K(x) + \Tr(K(x)Y).
\end{array}"/></p>
</div><p>The code below implements Newton&#8217;s method with a backtracking line search.
The gradient and Hessian of the objective function are given by</p>
<div class="math">
<p><img src="_images/math/073f6167ac0531843edee20f5f81d9a0c7cf4671.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\begin{split}
\nabla f(x)
    &amp; = 2 \diag( E_1^T (Y - K(x)^{-1}) E_2)) \\
    &amp; = 2\diag(Y_{IJ} - \left(K(x)^{-1}\right)_{IJ}) \\
\nabla^2 f(x)
    &amp; = 2 (E_1^T K(x)^{-1} E_1) \circ (E_2^T K(x)^{-1} E_2)
        + 2 (E_1^T K(x)^{-1} E_2) \circ (E_2^T K(x)^{-1} E_1) \\
    &amp; = 2 \left(K(x)^{-1}\right)_{II} \circ \left(K(x)^{-1}\right)_{JJ}
        + 2 \left(K(x)^{-1}\right)_{IJ} \circ
        \left(K(x)^{-1}\right)_{JI},
\end{split}"/></p>
</div><p>where <img class="math" src="_images/math/e3e1b8a98590631e4c5dc9df782ebe2cd9822722.png" alt="\circ"/> denotes Hadamard product.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">blas</span><span class="p">,</span> <span class="n">lapack</span><span class="p">,</span> <span class="n">amd</span><span class="p">,</span> <span class="n">cholmod</span>

<span class="k">def</span> <span class="nf">covsel</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the solution of</span>

<span class="sd">         minimize    -log det K + Tr(KY)</span>
<span class="sd">         subject to  K_{ij}=0,  (i,j) not in indices listed in I,J.</span>

<span class="sd">    Y is a symmetric sparse matrix with nonzero diagonal elements.</span>
<span class="sd">    I = Y.I,  J = Y.J.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">I</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">J</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="n">J</span><span class="o">*</span><span class="n">n</span>         <span class="c"># non-zero positions for one-argument indexing</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>  <span class="c"># position of diagonal elements</span>

    <span class="c"># starting point: symmetric identity with nonzero pattern I,J</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
    <span class="n">K</span><span class="p">[::</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c"># Kn is used in the line search</span>
    <span class="n">Kn</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>

    <span class="c"># symbolic factorization of K</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

    <span class="c"># Kinv will be the inverse of K</span>
    <span class="n">Kinv</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">iters</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>

        <span class="c"># numeric factorization of K</span>
        <span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

        <span class="c"># compute Kinv by solving K*X = I</span>
        <span class="n">Kinv</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">Kinv</span><span class="p">[::</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">cholmod</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Kinv</span><span class="p">)</span>

        <span class="c"># solve Newton system</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">V</span> <span class="o">-</span> <span class="n">Kinv</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">Kinv</span><span class="p">[</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">],</span><span class="n">Kinv</span><span class="p">[</span><span class="n">J</span><span class="p">,</span><span class="n">I</span><span class="p">])</span> <span class="o">+</span> <span class="n">mul</span><span class="p">(</span><span class="n">Kinv</span><span class="p">[</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">],</span><span class="n">Kinv</span><span class="p">[</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">]))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">grad</span>
        <span class="n">lapack</span><span class="o">.</span><span class="n">posv</span><span class="p">(</span><span class="n">hess</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

        <span class="c"># stopping criterion</span>
        <span class="n">sqntdecr</span> <span class="o">=</span> <span class="o">-</span><span class="n">blas</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Newton decrement squared:</span><span class="si">%- 7.5e</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">sqntdecr</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sqntdecr</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;number of iterations: &quot;</span><span class="p">,</span> <span class="n">iters</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c"># line search</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="o">+</span><span class="n">v</span>
        <span class="n">dx</span><span class="p">[</span><span class="n">D</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>      <span class="c"># scale the diagonal elems</span>
        <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>    <span class="c"># f = -log det K</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">lsiter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
            <span class="n">Kn</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">V</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">dx</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">Kn</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ArithmeticError</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">blas</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">Y</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fn</span> <span class="o">&lt;</span> <span class="n">f</span> <span class="o">-</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">sqntdecr</span><span class="p">):</span>
                     <span class="k">break</span>
                <span class="n">s</span> <span class="o">*=</span> <span class="mf">0.5</span>

        <span class="n">K</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">Kn</span><span class="o">.</span><span class="n">V</span>

    <span class="k">return</span> <span class="n">K</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Sparse Linear Equations</a><ul>
<li><a class="reference internal" href="#matrix-orderings">Matrix Orderings</a></li>
<li><a class="reference internal" href="#general-linear-equations">General Linear Equations</a></li>
<li><a class="reference internal" href="#positive-definite-linear-equations">Positive Definite Linear Equations</a></li>
<li><a class="reference internal" href="#example-covariance-selection">Example: Covariance Selection</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="fftw.html"
                        title="previous chapter">Discrete Transforms</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="coneprog.html"
                        title="next chapter">Cone Programming</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="coneprog.html" title="Cone Programming"
             >next</a></li>
        <li class="right" >
          <a href="fftw.html" title="Discrete Transforms"
             >previous</a> |</li>
    <li><a href="http://cvxopt.org">CVXOPT home</a> |</li>
    
        <li><a href="index.html">user&#39;s guide</a> </li>
 
      </ul>
    </div>
    <div class="footer">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>