


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>File manipulation class &mdash; PyTables 3.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '3.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../_static/toggle_sections.js"></script>
    <script type="text/javascript" src="../../_static/toggle_sidebar.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="top" title="PyTables 3.1.0 documentation" href="../../index.html" />
    <link rel="up" title="Library Reference" href="../libref.html" />
    <link rel="next" title="Hierarchy definition classes" href="hierarchy_classes.html" />
    <link rel="prev" title="Top-level variables and functions" href="top_level.html" /> 
  </head>
  <body>
    <div class="relbar-top">
        
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="hierarchy_classes.html" title="Hierarchy definition classes"
             accesskey="N">next</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="top_level.html" title="Top-level variables and functions"
             accesskey="P">previous</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">PyTables 3.1.0 documentation</a> &raquo;</li>

          <li><a href="../index.html" >PyTables User&#8217;s Guide</a> &raquo;</li>
          <li><a href="../libref.html" accesskey="U">Library Reference</a> &raquo;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="file-manipulation-class">
<h1>File manipulation class<a class="headerlink" href="#file-manipulation-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-file-class">
<span id="fileclassdescr"></span><h2>The File Class<a class="headerlink" href="#the-file-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tables.File">
<em class="property">class </em><tt class="descclassname">tables.</tt><tt class="descname">File</tt><big>(</big><em>filename</em>, <em>mode='r'</em>, <em>title=''</em>, <em>root_uep='/'</em>, <em>filters=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File" title="Permalink to this definition">¶</a></dt>
<dd><p>The in-memory representation of a PyTables file.</p>
<p>An instance of this class is returned when a PyTables file is
opened with the <a class="reference internal" href="top_level.html#tables.open_file" title="tables.open_file"><tt class="xref py py-func docutils literal"><span class="pre">tables.open_file()</span></tt></a> function. It offers methods
to manipulate (create, rename, delete...) nodes and handle their
attributes, as well as methods to traverse the object tree.
The <em>user entry point</em> to the object tree attached to the HDF5 file
is represented in the root_uep attribute.
Other attributes are available.</p>
<p>File objects support an <em>Undo/Redo mechanism</em> which can be enabled
with the <a class="reference internal" href="#tables.File.enable_undo" title="tables.File.enable_undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.enable_undo()</span></tt></a> method. Once the Undo/Redo
mechanism is enabled, explicit <em>marks</em> (with an optional unique
name) can be set on the state of the database using the
<a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>
method. There are two implicit marks which are always available:
the initial mark (0) and the final mark (-1).  Both the identifier
of a mark and its name can be used in <em>undo</em> and <em>redo</em> operations.</p>
<p>Hierarchy manipulation operations (node creation, movement and
removal) and attribute handling operations (setting and deleting)
made after a mark can be undone by using the <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a>
method, which returns the database to the state of a past mark.
If undo() is not followed by operations that modify the hierarchy
or attributes, the <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> method can be used to return
the database to the state of a future mark. Else, future states of
the database are forgotten.</p>
<p>Note that data handling operations can not be undone nor redone by
now. Also, hierarchy manipulation operations on nodes that do not
support the Undo/Redo mechanism issue an UndoRedoWarning <em>before</em>
changing the database.</p>
<p>The Undo/Redo mechanism is persistent between sessions and can
only be disabled by calling the <a class="reference internal" href="#tables.File.disable_undo" title="tables.File.disable_undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.disable_undo()</span></tt></a> method.</p>
<p>File objects can also act as context managers when using the with
statement introduced in Python 2.5.  When exiting a context, the
file is automatically closed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>The name of the file (supports environment variable expansion).
It is suggested that file names have any of the .h5, .hdf or
.hdf5 extensions, although this is not mandatory.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>The mode to open the file. It can be one of the
following:</p>
<blockquote>
<div><ul class="simple">
<li><em>&#8216;r&#8217;</em>: Read-only; no data can be modified.</li>
<li><em>&#8216;w&#8217;</em>: Write; a new file is created (an existing file
with the same name would be deleted).</li>
<li><em>&#8216;a&#8217;</em>: Append; an existing file is opened for reading
and writing, and if the file does not exist it is created.</li>
<li><em>&#8216;r+&#8217;</em>: It is similar to &#8216;a&#8217;, but the file must already
exist.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>If the file is to be created, a TITLE string attribute will be
set on the root group with the given value. Otherwise, the
title will be read from disk, and this will not have any effect.</p>
</div></blockquote>
<p><strong>root_uep</strong> : str</p>
<blockquote>
<div><p>The root User Entry Point. This is a group in the HDF5 hierarchy
which will be taken as the starting point to create the object
tree. It can be whatever existing group in the file, named by
its HDF5 path. If it does not exist, an HDF5ExtError is issued.
Use this if you do not want to build the <em>entire</em> object tree,
but rather only a <em>subtree</em> of it.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>rootUEP</em> parameter has been renamed into <em>root_uep</em>.</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote class="last">
<div><p>An instance of the Filters (see <a class="reference internal" href="helper_classes.html#filtersclassdescr"><em>The Filters class</em></a>) class that
provides information about the desired I/O filters applicable to the
leaves that hang directly from the <em>root group</em>, unless other filter
properties are specified for these leaves. Besides, if you do not
specify filter properties for child groups, they will inherit these
ones, which will in turn propagate to child nodes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In addition, it recognizes the (lowercase) names of parameters
present in <tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt> as additional keyword
arguments.
See <a class="reference internal" href="../parameter_files.html#parameter-files"><em>PyTables parameter files</em></a> for a detailed info on the supported
parameters.</p>
<p class="rubric">File attributes</p>
<dl class="attribute">
<dt id="tables.File.filename">
<tt class="descname">filename</tt><a class="headerlink" href="#tables.File.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the opened file.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.format_version">
<tt class="descname">format_version</tt><a class="headerlink" href="#tables.File.format_version" title="Permalink to this definition">¶</a></dt>
<dd><p>The PyTables version number of this file.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.isopen">
<tt class="descname">isopen</tt><a class="headerlink" href="#tables.File.isopen" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the underlying file is open, false otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.mode">
<tt class="descname">mode</tt><a class="headerlink" href="#tables.File.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The mode in which the file was opened.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.root">
<tt class="descname">root</tt><a class="headerlink" href="#tables.File.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>root</em> of the object tree hierarchy (a Group instance).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.root_uep">
<tt class="descname">root_uep</tt><a class="headerlink" href="#tables.File.root_uep" title="Permalink to this definition">¶</a></dt>
<dd><p>The UEP (user entry point) group name in the file (see
the <a class="reference internal" href="top_level.html#tables.open_file" title="tables.open_file"><tt class="xref py py-func docutils literal"><span class="pre">open_file()</span></tt></a> function).</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>rootUEP</em> attribute has been renamed into <em>root_uep</em>.</p>
</dd></dl>

</dd></dl>

<div class="section" id="file-properties">
<h3>File properties<a class="headerlink" href="#file-properties" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="tables.File.title">
<tt class="descclassname">File.</tt><tt class="descname">title</tt><a class="headerlink" href="#tables.File.title" title="Permalink to this definition">¶</a></dt>
<dd><p>The title of the root group in the file.</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.filters">
<tt class="descclassname">File.</tt><tt class="descname">filters</tt><a class="headerlink" href="#tables.File.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Default filter properties for the root group (see <a class="reference internal" href="helper_classes.html#filtersclassdescr"><em>The Filters class</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="tables.File.open_count">
<tt class="descclassname">File.</tt><tt class="descname">open_count</tt><a class="headerlink" href="#tables.File.open_count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of times this file handle has been opened.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.1: </span>The mechanism for caching and sharing file handles has been
removed in PyTables 3.1.  Now this property should always
be 1 (or 0 for closed files).</p>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 3.1.</span></p>
</dd></dl>

</div>
<div class="section" id="file-methods-file-handling">
<h3>File methods - file handling<a class="headerlink" href="#file-methods-file-handling" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.close">
<tt class="descclassname">File.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all the alive leaves in object tree and close the file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.copy_file">
<tt class="descclassname">File.</tt><tt class="descname">copy_file</tt><big>(</big><em>dstfilename</em>, <em>overwrite=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copy_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the contents of this file to dstfilename.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>dstfilename</strong> : str</p>
<blockquote>
<div><p>A path string indicating the name of the destination file. If
it already exists, the copy will fail with an IOError, unless
the overwrite argument is true.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool, optional</p>
<blockquote>
<div><p>If true, the destination file will be overwritten if it already
exists.  In this case, the destination file must be closed, or
errors will occur.  Defaults to False.</p>
</div></blockquote>
<p><strong>kwargs</strong> :</p>
<blockquote class="last">
<div><p>Additional keyword arguments discussed below.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Additional keyword arguments may be passed to customize the
copying process. For instance, title and filters may be changed,
user attributes may be or may not be copied, data may be
sub-sampled, stats may be collected, etc. Arguments unknown to
nodes are simply ignored. Check the documentation for copying
operations of nodes to see which options they support.</p>
<p>In addition, it recognizes the names of parameters present in
<tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt> as additional keyword arguments.
See <a class="reference internal" href="../parameter_files.html#parameter-files"><em>PyTables parameter files</em></a> for a detailed info on the supported
parameters.</p>
<p>Copying a file usually has the beneficial side effect of
creating a more compact and cleaner version of the original
file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.flush">
<tt class="descclassname">File.</tt><tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all the alive leaves in the object tree.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.fileno">
<tt class="descclassname">File.</tt><tt class="descname">fileno</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.fileno" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying OS integer file descriptor.</p>
<p>This is needed for lower-level file interfaces, such as the <tt class="docutils literal"><span class="pre">fcntl</span></tt>
module.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__enter__">
<tt class="descclassname">File.</tt><tt class="descname">__enter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter a context and return the same file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__exit__">
<tt class="descclassname">File.</tt><tt class="descname">__exit__</tt><big>(</big><em>*exc_info</em><big>)</big><a class="headerlink" href="#tables.File.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a context and close the file.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__str__">
<tt class="descclassname">File.</tt><tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short string representation of the object tree.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="s">&#39;data/test.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">data/test.h5 (File) &#39;Table Benchmark&#39;</span>
<span class="go">Last modif.: &#39;Mon Sep 20 12:40:47 2004&#39;</span>
<span class="go">Object Tree:</span>
<span class="go">/ (Group) &#39;Table Benchmark&#39;</span>
<span class="go">/tuple0 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0 (Group) &#39;&#39;</span>
<span class="go">/group0/tuple1 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0/group1 (Group) &#39;&#39;</span>
<span class="go">/group0/group1/tuple2 (Table(100,)) &#39;This is the table title&#39;</span>
<span class="go">/group0/group1/group2 (Group) &#39;&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.__repr__">
<tt class="descclassname">File.</tt><tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a detailed string representation of the object tree.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.get_file_image">
<tt class="descclassname">File.</tt><tt class="descname">get_file_image</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.get_file_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an in-memory image of an existing, open HDF5 file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this method requires HDF5 &gt;= 1.8.9.</p>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</dd></dl>

<dl class="method">
<dt id="tables.File.get_filesize">
<tt class="descclassname">File.</tt><tt class="descname">get_filesize</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.get_filesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of an HDF5 file.</p>
<p>The returned size is that of the entire file, as opposed to only
the HDF5 portion of the file. I.e., size includes the user block,
if any, the HDF5 portion of the file, and any data that may have
been appended beyond the data written through the HDF5 Library.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</dd></dl>

<dl class="method">
<dt id="tables.File.get_userblock_size">
<tt class="descclassname">File.</tt><tt class="descname">get_userblock_size</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.get_userblock_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the size of a user block.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</dd></dl>

</div>
<div class="section" id="file-methods-hierarchy-manipulation">
<h3>File methods - hierarchy manipulation<a class="headerlink" href="#file-methods-hierarchy-manipulation" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.copy_children">
<tt class="descclassname">File.</tt><tt class="descname">copy_children</tt><big>(</big><em>srcgroup</em>, <em>dstgroup</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copy_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the children of a group into another group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>srcgroup</strong> : str</p>
<blockquote>
<div><p>The group to copy from.</p>
</div></blockquote>
<p><strong>dstgroup</strong> : str</p>
<blockquote>
<div><p>The destination group.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the destination group will be overwritten if it already
exists.  Defaults to False.</p>
</div></blockquote>
<p><strong>recursive</strong> : bool, optional</p>
<blockquote>
<div><p>If True, all descendant nodes of srcgroup are recursively copied.
Defaults to False.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>If True, any necessary parents of dstgroup will be created.
Defaults to False.</p>
</div></blockquote>
<p><strong>kwargs</strong> : dict</p>
<blockquote class="last">
<div><p>Additional keyword arguments can be used to customize the copying
process.  See the documentation of <a class="reference internal" href="hierarchy_classes.html#tables.Group._f_copy_children" title="tables.Group._f_copy_children"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_copy_children()</span></tt></a>
for a description of those arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.copy_node">
<tt class="descclassname">File.</tt><tt class="descname">copy_node</tt><big>(</big><em>where</em>, <em>newparent=None</em>, <em>newname=None</em>, <em>name=None</em>, <em>overwrite=False</em>, <em>recursive=False</em>, <em>createparents=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tables.File.copy_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the node specified by where and name to newparent/newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the node to be acted
upon.</p>
</div></blockquote>
<p><strong>newparent</strong> : str or Group</p>
<blockquote>
<div><p>The destination group that the node will be copied
into (a path name or a Group
instance). If not specified or None, the
current parent group is chosen as the new parent.</p>
</div></blockquote>
<p><strong>newname</strong> : str</p>
<blockquote>
<div><p>The name to be assigned to the new copy in its
destination (a string).  If it is not specified or
None, the current name is chosen as the
new name.</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the node to be acted
upon.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the destination group will be overwritten if it already
exists.  Defaults to False.</p>
</div></blockquote>
<p><strong>recursive</strong> : bool, optional</p>
<blockquote>
<div><p>If True, all descendant nodes of srcgroup are recursively copied.
Defaults to False.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>If True, any necessary parents of dstgroup will be created.
Defaults to False.</p>
</div></blockquote>
<p><strong>kwargs</strong> :</p>
<blockquote>
<div><p>Additional keyword arguments can be used to customize the copying
process.  See the documentation of <a class="reference internal" href="hierarchy_classes.html#tables.Group._f_copy" title="tables.Group._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Group._f_copy()</span></tt></a>
for a description of those arguments.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>node</strong> : Node</p>
<blockquote class="last">
<div><p>The newly created copy of the source node (i.e. the destination
node).  See <a class="reference internal" href="hierarchy_classes.html#tables.Node._f_copy" title="tables.Node._f_copy"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_copy()</span></tt></a> for further details on the
semantics of copying nodes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_array">
<tt class="descclassname">File.</tt><tt class="descname">create_array</tt><big>(</big><em>where</em>, <em>name</em>, <em>obj=None</em>, <em>title=''</em>, <em>byteorder=None</em>, <em>createparents=False</em>, <em>atom=None</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#tables.File.create_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new array will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new array</p>
</div></blockquote>
<p><strong>obj</strong> : python object</p>
<blockquote>
<div><p>The array or scalar to be saved.  Accepted types are NumPy
arrays and scalars, as well as native Python sequences and
scalars, provided that values are regular (i.e. they are
not like <tt class="docutils literal"><span class="pre">[[1,2],2]</span></tt>) and homogeneous (i.e. all the
elements are of the same type).</p>
<p>Also, objects that have some of their dimensions equal to 0
are not supported (use an EArray node (see
<a class="reference internal" href="homogenous_storage.html#earrayclassdescr"><em>The EArray class</em></a>) if you want to store an array with
one of its dimensions equal to 0).</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>Object parameter has been renamed into *obj</em>.*</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str</p>
<blockquote>
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;.  If this is not specified, the byteorder is that of the
given object.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to exist
(not done by default).</p>
</div></blockquote>
<p><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="declarative_classes.html#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing
the <em>type</em> and <em>shape</em> of the atomic objects to be saved.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</div></blockquote>
<p><strong>shape</strong> : tuple of ints</p>
<blockquote class="last">
<div><p>The shape of the stored array.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="homogenous_storage.html#tables.Array" title="tables.Array"><tt class="xref py py-obj docutils literal"><span class="pre">Array</span></tt></a></dt>
<dd>for more information on arrays</dd>
<dt><a class="reference internal" href="#tables.File.create_table" title="tables.File.create_table"><tt class="xref py py-obj docutils literal"><span class="pre">create_table</span></tt></a></dt>
<dd>for more information on the rest of parameters</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_carray">
<tt class="descclassname">File.</tt><tt class="descname">create_carray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom=None</em>, <em>shape=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em>, <em>obj=None</em><big>)</big><a class="headerlink" href="#tables.File.create_carray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new chunked array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new array will hang. It can
be a path string (for example &#8216;/level1/leaf5&#8217;), or a Group
instance (see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new array</p>
</div></blockquote>
<p><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="declarative_classes.html#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing
the <em>type</em> and <em>shape</em> of the atomic objects to be saved.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>atom</em> parameter can be None (default) if <em>obj</em> is
provided.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>The shape of the new array.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>shape</em> parameter can be None (default) if <em>obj</em> is
provided.</p>
</div></blockquote>
<p><strong>title</strong> : str, optional</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute
on disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters, optional</p>
<blockquote>
<div><p>An instance of the Filters class (see <a class="reference internal" href="helper_classes.html#filtersclassdescr"><em>The Filters class</em></a>)
that provides information about the desired I/O filters to
be applied during the life of this object.</p>
</div></blockquote>
<p><strong>chunkshape</strong> : tuple or number or None, optional</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a
single HDF5 I/O operation.  Filters are applied to those
chunks of data.  The dimensionality of chunkshape must be
the same as that of shape.  If None, a sensible value is
calculated (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str, optional</p>
<blockquote>
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217;
or &#8216;big&#8217;.  If this is not specified, the byteorder is that
of the given object.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to
exist (not done by default).</p>
</div></blockquote>
<p><strong>obj</strong> : python object</p>
<blockquote class="last">
<div><p>The array or scalar to be saved.  Accepted types are NumPy
arrays and scalars, as well as native Python sequences and
scalars, provided that values are regular (i.e. they are
not like <tt class="docutils literal"><span class="pre">[[1,2],2]</span></tt>) and homogeneous (i.e. all the
elements are of the same type).</p>
<p>Also, objects that have some of their dimensions equal to 0
are not supported. Please use an EArray node (see
<a class="reference internal" href="homogenous_storage.html#earrayclassdescr"><em>The EArray class</em></a>) if you want to store an array with
one of its dimensions equal to 0.</p>
<p>The <em>obj</em> parameter is optional and it can be provided in
alternative to the <em>atom</em> and <em>shape</em> parameters.
If both <em>obj</em> and <em>atom</em> and/or <em>shape</em> are provided they must
be consistent with each other.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="homogenous_storage.html#tables.CArray" title="tables.CArray"><tt class="xref py py-obj docutils literal"><span class="pre">CArray</span></tt></a></dt>
<dd>for more information on chunked arrays</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_earray">
<tt class="descclassname">File.</tt><tt class="descname">create_earray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom=None</em>, <em>shape=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=1000</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em>, <em>obj=None</em><big>)</big><a class="headerlink" href="#tables.File.create_earray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new enlargeable array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new array will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new array</p>
</div></blockquote>
<p><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="declarative_classes.html#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing the
<em>type</em> and <em>shape</em> of the atomic objects to be saved.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>atom</em> parameter can be None (default) if <em>obj</em> is
provided.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>The shape of the new array.  One (and only one) of the shape
dimensions <em>must</em> be 0.  The dimension being 0 means that the
resulting EArray object can be extended along it.  Multiple
enlargeable dimensions are not supported right now.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>shape</em> parameter can be None (default) if <em>obj</em> is
provided.</p>
</div></blockquote>
<p><strong>title</strong> : str, optional</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>expectedrows</strong> : int, optional</p>
<blockquote>
<div><p>A user estimate about the number of row elements that will be added
to the growable dimension in the EArray node.  If not provided, the
default value is EXPECTED_ROWS_EARRAY (see tables/parameters.py).
If you plan to create either a much smaller or a much bigger array
try providing a guess; this will optimize the HDF5 B-Tree creation
and management process time and the amount of memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> : tuple, numeric, or None, optional</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a single HDF5
I/O operation.  Filters are applied to those chunks of data.  The
dimensionality of chunkshape must be the same as that of shape
(beware: no dimension should be 0 this time!).  If None, a sensible
value is calculated based on the expectedrows parameter (which is
recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str, optional</p>
<blockquote>
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;. If this is not specified, the byteorder is that of the
platform.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to exist
(not done by default).</p>
</div></blockquote>
<p><strong>obj</strong> : python object</p>
<blockquote class="last">
<div><p>The array or scalar to be saved.  Accepted types are NumPy
arrays and scalars, as well as native Python sequences and
scalars, provided that values are regular (i.e. they are
not like <tt class="docutils literal"><span class="pre">[[1,2],2]</span></tt>) and homogeneous (i.e. all the
elements are of the same type).</p>
<p>The <em>obj</em> parameter is optional and it can be provided in
alternative to the <em>atom</em> and <em>shape</em> parameters.
If both <em>obj</em> and <em>atom</em> and/or <em>shape</em> are provided they must
be consistent with each other.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="homogenous_storage.html#tables.EArray" title="tables.EArray"><tt class="xref py py-obj docutils literal"><span class="pre">EArray</span></tt></a></dt>
<dd>for more information on enlargeable arrays</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_external_link">
<tt class="descclassname">File.</tt><tt class="descname">create_external_link</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.create_external_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an external link.</p>
<p>Create an external link to a <em>target</em> node with the given <em>name</em>
in <em>where</em> location.  <em>target</em> can be a node object in another
file or a path string in the form &#8216;<a class="reference external" href="file:/path/to/node">file:/path/to/node</a>&#8216;.  If
<em>createparents</em> is true, the intermediate groups required for
reaching <em>where</em> are created (the default is not doing so).</p>
<p>The returned node is an <tt class="xref py py-class docutils literal"><span class="pre">ExternalLink</span></tt> instance.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_group">
<tt class="descclassname">File.</tt><tt class="descname">create_group</tt><big>(</big><em>where</em>, <em>name</em>, <em>title=''</em>, <em>filters=None</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.create_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new group will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new group.</p>
</div></blockquote>
<p><strong>title</strong> : str, optional</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute on
disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class (see <a class="reference internal" href="helper_classes.html#filtersclassdescr"><em>The Filters class</em></a>)
that provides information about the desired I/O filters applicable
to the leaves that hang directly from this new group (unless other
filter properties are specified for these leaves). Besides, if you
do not specify filter properties for its child groups, they will
inherit these ones.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool</p>
<blockquote class="last">
<div><p>Whether to create the needed groups for the parent
path to exist (not done by default).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="hierarchy_classes.html#tables.Group" title="tables.Group"><tt class="xref py py-obj docutils literal"><span class="pre">Group</span></tt></a></dt>
<dd>for more information on groups</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_hard_link">
<tt class="descclassname">File.</tt><tt class="descname">create_hard_link</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.create_hard_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hard link.</p>
<p>Create a hard link to a <cite>target</cite> node with the given <cite>name</cite> in
<cite>where</cite> location.  <cite>target</cite> can be a node object or a path
string.  If <cite>createparents</cite> is true, the intermediate groups
required for reaching <cite>where</cite> are created (the default is not
doing so).</p>
<p>The returned node is a regular <cite>Group</cite> or <cite>Leaf</cite> instance.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_soft_link">
<tt class="descclassname">File.</tt><tt class="descname">create_soft_link</tt><big>(</big><em>where</em>, <em>name</em>, <em>target</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.create_soft_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a soft link (aka symbolic link) to a <cite>target</cite> node.</p>
<p>Create a soft link (aka symbolic link) to a <cite>target</cite> nodewith
the given <cite>name</cite> in <cite>where</cite> location.  <cite>target</cite> can be a node
object or a path string.  If <cite>createparents</cite> is true, the
intermediate groups required for reaching <cite>where</cite> are created.</p>
<p>(the default is not doing so).</p>
<p>The returned node is a SoftLink instance.  See the SoftLink
class (in <a class="reference internal" href="link_classes.html#softlinkclassdescr"><em>The SoftLink class</em></a>) for more information on
soft links.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_table">
<tt class="descclassname">File.</tt><tt class="descname">create_table</tt><big>(</big><em>where</em>, <em>name</em>, <em>description=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=10000</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em>, <em>obj=None</em><big>)</big><a class="headerlink" href="#tables.File.create_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new table with the given name in where location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new table will hang. It can be a
path string (for example &#8216;/level1/leaf5&#8217;), or a Group instance
(see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new table.</p>
</div></blockquote>
<p><strong>description</strong> : Description</p>
<blockquote>
<div><p>This is an object that describes the table, i.e. how
many columns it has, their names, types, shapes, etc.  It
can be any of the following:</p>
<blockquote>
<div><ul class="simple">
<li><em>A user-defined class</em>: This should inherit from the
IsDescription class (see <a class="reference internal" href="declarative_classes.html#isdescriptionclassdescr"><em>The IsDescription class</em></a>)
where table fields are specified.</li>
<li><em>A dictionary</em>: For example, when you do not know
beforehand which structure your table will have).</li>
<li><em>A Description instance</em>: You can use the description
attribute of another table to create a new one with the
same structure.</li>
<li><em>A NumPy dtype</em>: A completely general structured NumPy
dtype.</li>
<li><em>A NumPy (structured) array instance</em>: The dtype of
this structured array will be used as the description.
Also, in case the array has actual data, it will be
injected into the newly created table.</li>
</ul>
</div></blockquote>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>description</em> parameter can be None (default) if <em>obj</em> is
provided.  In that case the structure of the table is deduced
by <em>obj</em>.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute
on disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class (see <a class="reference internal" href="helper_classes.html#filtersclassdescr"><em>The Filters class</em></a>)
that provides information about the desired I/O filters to be
applied during the life of this object.</p>
</div></blockquote>
<p><strong>expectedrows</strong> : int</p>
<blockquote>
<div><p>A user estimate of the number of records that will be in the table.
If not provided, the default value is EXPECTED_ROWS_TABLE (see
<tt class="file docutils literal"><span class="pre">tables/parameters.py</span></tt>). If you plan to create a bigger
table try providing a guess; this will optimize the HDF5 B-Tree
creation and management process time and memory used.</p>
</div></blockquote>
<p><strong>chunkshape</strong> :</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a
single HDF5 I/O operation. Filters are applied to those
chunks of data. The rank of the chunkshape for tables must
be 1. If None, a sensible value is calculated based on the
expectedrows parameter (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str</p>
<blockquote>
<div><p>The byteorder of data <em>on disk</em>, specified as &#8216;little&#8217; or &#8216;big&#8217;.
If this is not specified, the byteorder is that of the platform,
unless you passed an array as the description, in which case
its byteorder will be used.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to exist
(not done by default).</p>
</div></blockquote>
<p><strong>obj</strong> : python object</p>
<blockquote class="last">
<div><p>The recarray to be saved.  Accepted types are NumPy record
arrays, as well as native Python sequences convertible to numpy
record arrays.</p>
<p>The <em>obj</em> parameter is optional and it can be provided in
alternative to the <em>description</em> parameter.
If both <em>obj</em> and <em>description</em> are provided they must
be consistent with each other.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="structured_storage.html#tables.Table" title="tables.Table"><tt class="xref py py-obj docutils literal"><span class="pre">Table</span></tt></a></dt>
<dd>for more information on tables</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.create_vlarray">
<tt class="descclassname">File.</tt><tt class="descname">create_vlarray</tt><big>(</big><em>where</em>, <em>name</em>, <em>atom=None</em>, <em>title=''</em>, <em>filters=None</em>, <em>expectedrows=None</em>, <em>chunkshape=None</em>, <em>byteorder=None</em>, <em>createparents=False</em>, <em>obj=None</em><big>)</big><a class="headerlink" href="#tables.File.create_vlarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable-length array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group</p>
<blockquote>
<div><p>The parent group from which the new array will hang. It can
be a path string (for example &#8216;/level1/leaf5&#8217;), or a Group
instance (see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the new array</p>
</div></blockquote>
<p><strong>atom</strong> : Atom</p>
<blockquote>
<div><p>An Atom (see <a class="reference internal" href="declarative_classes.html#atomclassdescr"><em>The Atom class and its descendants</em></a>) instance representing
the <em>type</em> and <em>shape</em> of the atomic objects to be saved.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 3.0: </span>The <em>atom</em> parameter can be None (default) if <em>obj</em> is
provided.</p>
</div></blockquote>
<p><strong>title</strong> : str, optional</p>
<blockquote>
<div><p>A description for this node (it sets the TITLE HDF5 attribute
on disk).</p>
</div></blockquote>
<p><strong>filters</strong> : Filters</p>
<blockquote>
<div><p>An instance of the Filters class (see <a class="reference internal" href="helper_classes.html#filtersclassdescr"><em>The Filters class</em></a>)
that provides information about the desired I/O filters to
be applied during the life of this object.</p>
</div></blockquote>
<p><strong>expectedrows</strong> : int, optional</p>
<blockquote>
<div><p>A user estimate about the number of row elements that will
be added to the growable dimension in the <cite>VLArray</cite> node.
If not provided, the default value is <tt class="docutils literal"><span class="pre">EXPECTED_ROWS_VLARRAY</span></tt>
(see <tt class="docutils literal"><span class="pre">tables/parameters.py</span></tt>).  If you plan to create either
a much smaller or a much bigger <cite>VLArray</cite> try providing a guess;
this will optimize the HDF5 B-Tree creation and management
process time and the amount of memory used.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</div></blockquote>
<p><strong>chunkshape</strong> : int or tuple of int, optional</p>
<blockquote>
<div><p>The shape of the data chunk to be read or written in a
single HDF5 I/O operation. Filters are applied to those
chunks of data. The dimensionality of chunkshape must be 1.
If None, a sensible value is calculated (which is recommended).</p>
</div></blockquote>
<p><strong>byteorder</strong> : str, optional</p>
<blockquote>
<div><p>The byteorder of the data <em>on disk</em>, specified as &#8216;little&#8217; or
&#8216;big&#8217;. If this is not specified, the byteorder is that of the
platform.</p>
</div></blockquote>
<p><strong>createparents</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to create the needed groups for the parent path to
exist (not done by default).</p>
</div></blockquote>
<p><strong>obj</strong> : python object</p>
<blockquote class="last">
<div><p>The array or scalar to be saved.  Accepted types are NumPy
arrays and scalars, as well as native Python sequences and
scalars, provided that values are regular (i.e. they are
not like <tt class="docutils literal"><span class="pre">[[1,2],2]</span></tt>) and homogeneous (i.e. all the
elements are of the same type).</p>
<p>The <em>obj</em> parameter is optional and it can be provided in
alternative to the <em>atom</em> parameter.
If both <em>obj</em> and <em>atom</em> and are provided they must
be consistent with each other.</p>
<p class="versionadded">
<span class="versionmodified">New in version 3.0.</span></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="homogenous_storage.html#tables.VLArray" title="tables.VLArray"><tt class="xref py py-obj docutils literal"><span class="pre">VLArray</span></tt></a></dt>
<dd>for more informationon variable-length arrays</dd>
<dt><tt class="xref py py-obj docutils literal"></tt></dt>
<dd>The <em>expectedsizeinMB</em> parameter has been replaced by <em>expectedrows</em>.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.move_node">
<tt class="descclassname">File.</tt><tt class="descname">move_node</tt><big>(</big><em>where</em>, <em>newparent=None</em>, <em>newname=None</em>, <em>name=None</em>, <em>overwrite=False</em>, <em>createparents=False</em><big>)</big><a class="headerlink" href="#tables.File.move_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the node specified by where and name to newparent/newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> : path</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>newparent</strong> :</p>
<blockquote>
<div><p>The destination group the node will be moved into (a
path name or a Group instance). If it is
not specified or None, the current parent
group is chosen as the new parent.</p>
</div></blockquote>
<p><strong>newname</strong> :</p>
<blockquote class="last">
<div><p>The new name to be assigned to the node in its
destination (a string). If it is not specified or
None, the current name is chosen as the
new name.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The other arguments work as in <a class="reference internal" href="hierarchy_classes.html#tables.Node._f_move" title="tables.Node._f_move"><tt class="xref py py-meth docutils literal"><span class="pre">Node._f_move()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.remove_node">
<tt class="descclassname">File.</tt><tt class="descname">remove_node</tt><big>(</big><em>where</em>, <em>name=None</em>, <em>recursive=False</em><big>)</big><a class="headerlink" href="#tables.File.remove_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the object node <em>name</em> under <em>where</em> location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>recursive</strong> : bool</p>
<blockquote class="last">
<div><p>If not supplied or false, the node will be removed
only if it has no children; if it does, a
NodeError will be raised. If supplied
with a true value, the node and all its descendants will be
completely removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.rename_node">
<tt class="descclassname">File.</tt><tt class="descname">rename_node</tt><big>(</big><em>where</em>, <em>newname</em>, <em>name=None</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#tables.File.rename_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the name of the node specified by where and name to newname.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>newname</strong> : str</p>
<blockquote>
<div><p>The new name to be assigned to the node (a string).</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool</p>
<blockquote class="last">
<div><p>Whether to recursively remove a node with the same
newname if it already exists (not done by default).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="file-methods-tree-traversal">
<h3>File methods - tree traversal<a class="headerlink" href="#file-methods-tree-traversal" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.get_node">
<tt class="descclassname">File.</tt><tt class="descname">get_node</tt><big>(</big><em>where</em>, <em>name=None</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.get_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the node under where with the given name.</p>
<p>where can be a Node instance (see <a class="reference internal" href="hierarchy_classes.html#nodeclassdescr"><em>The Node class</em></a>) or a
path string leading to a node. If no name is specified, that
node is returned.</p>
<p>If a name is specified, this must be a string with the name of
a node under where.  In this case the where argument can only
lead to a Group (see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>) instance (else a
TypeError is raised). The node called name under the group
where is returned.</p>
<p>In both cases, if the node to be returned does not exist, a
NoSuchNodeError is raised. Please note that hidden nodes are
also considered.</p>
<p>If the classname argument is specified, it must be the name of
a class derived from Node. If the node is found but it is not
an instance of that class, a NoSuchNodeError is also raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.is_visible_node">
<tt class="descclassname">File.</tt><tt class="descname">is_visible_node</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#tables.File.is_visible_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the node under <cite>path</cite> visible?</p>
<p>If the node does not exist, a NoSuchNodeError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.iter_nodes">
<tt class="descclassname">File.</tt><tt class="descname">iter_nodes</tt><big>(</big><em>where</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.iter_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over children nodes hanging from where.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> :</p>
<blockquote>
<div><p>This argument works as in <a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the
node to be acted upon.</p>
</div></blockquote>
<p><strong>classname</strong> :</p>
<blockquote class="last">
<div><p>If the name of a class derived from
Node (see <a class="reference internal" href="hierarchy_classes.html#nodeclassdescr"><em>The Node class</em></a>) is supplied, only instances of
that class (or subclasses of it) will be returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The returned nodes are alphanumerically sorted by their name.
This is an iterator version of <a class="reference internal" href="#tables.File.list_nodes" title="tables.File.list_nodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.list_nodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.list_nodes">
<tt class="descclassname">File.</tt><tt class="descname">list_nodes</tt><big>(</big><em>where</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.list_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <em>list</em> with children nodes hanging from where.</p>
<p>This is a list-returning version of <a class="reference internal" href="#tables.File.iter_nodes" title="tables.File.iter_nodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.iter_nodes()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.walk_groups">
<tt class="descclassname">File.</tt><tt class="descname">walk_groups</tt><big>(</big><em>where='/'</em><big>)</big><a class="headerlink" href="#tables.File.walk_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over groups (not leaves) hanging from where.</p>
<p>The where group itself is listed first (preorder), then each of its
child groups (following an alphanumerical order) is also traversed,
following the same procedure.  If where is not supplied, the root
group is used.</p>
<p>The where argument can be a path string
or a Group instance (see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>).</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.walk_nodes">
<tt class="descclassname">File.</tt><tt class="descname">walk_nodes</tt><big>(</big><em>where='/'</em>, <em>classname=None</em><big>)</big><a class="headerlink" href="#tables.File.walk_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over nodes hanging from where.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where</strong> : str or Group, optional</p>
<blockquote>
<div><p>If supplied, the iteration starts from (and includes)
this group. It can be a path string or a
Group instance (see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>).</p>
</div></blockquote>
<p><strong>classname</strong> :</p>
<blockquote class="last">
<div><p>If the name of a class derived from
Node (see <a class="reference internal" href="hierarchy_classes.html#groupclassdescr"><em>The Group class</em></a>) is supplied, only instances of
that class (or subclasses of it) will be returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This version iterates over the leaves in the same group in order
to avoid having a list referencing to them and thus, preventing
the LRU cache to remove them after their use.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Recursively print all the nodes hanging from &#39;/detector&#39;.</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;Nodes hanging from group &#39;/detector&#39;:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">h5file</span><span class="o">.</span><span class="n">walk_nodes</span><span class="p">(</span><span class="s">&#39;/detector&#39;</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="s">&#39;EArray&#39;</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tables.File.__contains__">
<tt class="descclassname">File.</tt><tt class="descname">__contains__</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#tables.File.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Is there a node with that path?</p>
<p>Returns True if the file has a node with the given path (a
string), False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.__iter__">
<tt class="descclassname">File.</tt><tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively iterate over the nodes in the tree.</p>
<p>This is equivalent to calling <a class="reference internal" href="#tables.File.walk_nodes" title="tables.File.walk_nodes"><tt class="xref py py-meth docutils literal"><span class="pre">File.walk_nodes()</span></tt></a> with no
arguments.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Recursively list all the nodes in the object tree.</span>
<span class="n">h5file</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="s">&#39;vlarray1.h5&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;All nodes in the object tree:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">h5file</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="file-methods-undo-redo-support">
<h3>File methods - Undo/Redo support<a class="headerlink" href="#file-methods-undo-redo-support" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.disable_undo">
<tt class="descclassname">File.</tt><tt class="descname">disable_undo</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.disable_undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the Undo/Redo mechanism.</p>
<p>Disabling the Undo/Redo mechanism leaves the database in the
current state and forgets past and future database states. This
makes <a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>, <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a>, <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> and other
methods fail with an UndoRedoError.</p>
<p>Calling this method when the Undo/Redo mechanism is already
disabled raises an UndoRedoError.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.enable_undo">
<tt class="descclassname">File.</tt><tt class="descname">enable_undo</tt><big>(</big><em>filters=Filters(complevel=1</em>, <em>complib='zlib'</em>, <em>shuffle=True</em>, <em>fletcher32=False</em>, <em>least_significant_digit=None)</em><big>)</big><a class="headerlink" href="#tables.File.enable_undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the Undo/Redo mechanism.</p>
<p>This operation prepares the database for undoing and redoing
modifications in the node hierarchy. This
allows <a class="reference internal" href="#tables.File.mark" title="tables.File.mark"><tt class="xref py py-meth docutils literal"><span class="pre">File.mark()</span></tt></a>, <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a>, <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a> and
other methods to be called.</p>
<p>The filters argument, when specified,
must be an instance of class Filters (see <a class="reference internal" href="helper_classes.html#filtersclassdescr"><em>The Filters class</em></a>) and
is meant for setting the compression values for the action log. The
default is having compression enabled, as the gains in terms of
space can be considerable. You may want to disable compression if
you want maximum speed for Undo/Redo operations.</p>
<p>Calling this method when the Undo/Redo mechanism is already
enabled raises an UndoRedoError.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.get_current_mark">
<tt class="descclassname">File.</tt><tt class="descname">get_current_mark</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.get_current_mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the identifier of the current mark.</p>
<p>Returns the identifier of the current mark. This can be used
to know the state of a database after an application crash, or to
get the identifier of the initial implicit mark after a call
to <a class="reference internal" href="#tables.File.enable_undo" title="tables.File.enable_undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.enable_undo()</span></tt></a>.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.goto">
<tt class="descclassname">File.</tt><tt class="descname">goto</tt><big>(</big><em>mark</em><big>)</big><a class="headerlink" href="#tables.File.goto" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a specific mark of the database.</p>
<p>Returns the database to the state associated with the specified mark.
Both the identifier of a mark and its name can be used.</p>
<p>This method can only be called when the Undo/Redo mechanism has been
enabled. Otherwise, an UndoRedoError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.is_undo_enabled">
<tt class="descclassname">File.</tt><tt class="descname">is_undo_enabled</tt><big>(</big><big>)</big><a class="headerlink" href="#tables.File.is_undo_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the Undo/Redo mechanism enabled?</p>
<p>Returns True if the Undo/Redo mechanism has been enabled for
this file, False otherwise. Please note that this mechanism is
persistent, so a newly opened PyTables file may already have
Undo/Redo support enabled.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.mark">
<tt class="descclassname">File.</tt><tt class="descname">mark</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.mark" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark the state of the database.</p>
<p>Creates a mark for the current state of the database. A unique (and
immutable) identifier for the mark is returned. An optional name (a
string) can be assigned to the mark. Both the identifier of a mark and
its name can be used in <a class="reference internal" href="#tables.File.undo" title="tables.File.undo"><tt class="xref py py-meth docutils literal"><span class="pre">File.undo()</span></tt></a> and <a class="reference internal" href="#tables.File.redo" title="tables.File.redo"><tt class="xref py py-meth docutils literal"><span class="pre">File.redo()</span></tt></a>
operations. When the name has already been used for another mark,
an UndoRedoError is raised.</p>
<p>This method can only be called when the Undo/Redo mechanism has been
enabled. Otherwise, an UndoRedoError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.redo">
<tt class="descclassname">File.</tt><tt class="descname">redo</tt><big>(</big><em>mark=None</em><big>)</big><a class="headerlink" href="#tables.File.redo" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a future state of the database.</p>
<p>Returns the database to the state associated with the specified
mark.  Both the identifier of a mark and its name can be used.
If the <cite>mark</cite> is omitted, the next created mark is used.  If
there are no future marks, or the specified mark is not newer
than the current one, an UndoRedoError is raised.</p>
<p>This method can only be called when the Undo/Redo mechanism has
been enabled.  Otherwise, an UndoRedoError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="tables.File.undo">
<tt class="descclassname">File.</tt><tt class="descname">undo</tt><big>(</big><em>mark=None</em><big>)</big><a class="headerlink" href="#tables.File.undo" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to a past state of the database.</p>
<p>Returns the database to the state associated with the specified mark.
Both the identifier of a mark and its name can be used. If the mark is
omitted, the last created mark is used. If there are no past
marks, or the specified mark is not older than the current one, an
UndoRedoError is raised.</p>
<p>This method can only be called when the Undo/Redo mechanism
has been enabled. Otherwise, an UndoRedoError
is raised.</p>
</dd></dl>

</div>
<div class="section" id="file-methods-attribute-handling">
<h3>File methods - attribute handling<a class="headerlink" href="#file-methods-attribute-handling" title="Permalink to this headline">¶</a></h3>
<dl class="method">
<dt id="tables.File.copy_node_attrs">
<tt class="descclassname">File.</tt><tt class="descname">copy_node_attrs</tt><big>(</big><em>where</em>, <em>dstnode</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.copy_node_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy PyTables attributes from one node to another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in <a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the
node to be acted upon.</p>
</div></blockquote>
<p><strong>dstnode</strong> :</p>
<blockquote class="last">
<div><p>The destination node where the attributes will be copied to. It can
be a path string or a Node instance (see <a class="reference internal" href="hierarchy_classes.html#nodeclassdescr"><em>The Node class</em></a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.del_node_attr">
<tt class="descclassname">File.</tt><tt class="descname">del_node_attr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.del_node_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a PyTables attribute from the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in <a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the
node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote class="last">
<div><p>The name of the attribute to delete.  If the named
attribute does not exist, an AttributeError is raised.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.get_node_attr">
<tt class="descclassname">File.</tt><tt class="descname">get_node_attr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.get_node_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PyTables attribute from the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in <a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the
node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote class="last">
<div><p>The name of the attribute to retrieve.  If the named
attribute does not exist, an AttributeError is raised.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tables.File.set_node_attr">
<tt class="descclassname">File.</tt><tt class="descname">set_node_attr</tt><big>(</big><em>where</em>, <em>attrname</em>, <em>attrvalue</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#tables.File.set_node_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a PyTables attribute for the given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>where, name</strong> :</p>
<blockquote>
<div><p>These arguments work as in
<a class="reference internal" href="#tables.File.get_node" title="tables.File.get_node"><tt class="xref py py-meth docutils literal"><span class="pre">File.get_node()</span></tt></a>, referencing the node to be acted upon.</p>
</div></blockquote>
<p><strong>attrname</strong> :</p>
<blockquote>
<div><p>The name of the attribute to set.</p>
</div></blockquote>
<p><strong>attrvalue</strong> :</p>
<blockquote class="last">
<div><p>The value of the attribute to set. Any kind of Python
object (like strings, ints, floats, lists, tuples, dicts,
small NumPy objects ...) can be stored as an attribute.
However, if necessary, pickle is automatically used so as
to serialize objects that you might want to save.
See the <tt class="xref py py-class docutils literal"><span class="pre">AttributeSet</span></tt> class for details.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If the node already has a large number of attributes, a
PerformanceWarning is issued.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="../../index.html">
          <img class="logo" src="../../_static/logo-pytables-small.png" alt="Logo"/>
        </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">File manipulation class</a><ul>
<li><a class="reference internal" href="#the-file-class">The File Class</a><ul>
<li><a class="reference internal" href="#file-properties">File properties</a></li>
<li><a class="reference internal" href="#file-methods-file-handling">File methods - file handling</a></li>
<li><a class="reference internal" href="#file-methods-hierarchy-manipulation">File methods - hierarchy manipulation</a></li>
<li><a class="reference internal" href="#file-methods-tree-traversal">File methods - tree traversal</a></li>
<li><a class="reference internal" href="#file-methods-undo-redo-support">File methods - Undo/Redo support</a></li>
<li><a class="reference internal" href="#file-methods-attribute-handling">File methods - attribute handling</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="top_level.html"
                        title="previous chapter">Top-level variables and functions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hierarchy_classes.html"
                        title="next chapter">Hierarchy definition classes</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/usersguide/libref/file_class.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="hierarchy_classes.html" title="Hierarchy definition classes"
             >next</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="top_level.html" title="Top-level variables and functions"
             >previous</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">PyTables 3.1.0 documentation</a> &raquo;</li>

          <li><a href="../index.html" >PyTables User&#8217;s Guide</a> &raquo;</li>
          <li><a href="../libref.html" >Library Reference</a> &raquo;</li> 
      </ul>
    </div>
    </div>

    <div class="footer">
        &copy; Copyright 2011-2014, PyTables maintainers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
    <!-- cloud_sptheme 1.3 -->
  </body>
</html>