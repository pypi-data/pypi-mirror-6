#!/usr/bin/env python

"""
Produce a tox.ini file from a template config file.

The template config file is a standard tox.ini file with additional sections.
Theses sections will be combined to create new testenv: sections if they do
not exists yet.
"""

import itertools
import optparse

import six

from six.moves import configparser

try:
    from collections import OrderedDict
except ImportError:
    # NOTE(harlowja): python 2.6 doesn't have this, so we have to import it
    from ordereddict import OrderedDict

SKIP_VENVS = frozenset(['venv'])
HEADER = '# DO NOT EDIT THIS FILE - it is machine generated from %(filename)s'

parser = optparse.OptionParser(epilog=__doc__.strip())
parser.add_option('-i', '--input', dest='input',
                  default='tox-tmpl.ini', metavar='FILE',
                  help="input template file to process [default: %default]")
parser.add_option('-o', '--output', dest='output',
                  default='tox.ini', metavar='FILE',
                  help="output file to generate [default: %default]")
parser.add_option('-r', '--rewrite', dest='rewrite',
                  default=False, metavar='BOOL',
                  action="store_true",
                  help="rewrite [tox] envlist [default: %default]")


class AxisItem(object):
    def __init__(self, axis, name, config):
        self.axis = axis
        self.isdefault = name[-1] == '*'
        self.name = name[:-1] if self.isdefault else name
        self.load(config)

    def load(self, config):
        sectionname = 'axis:%s:%s' % (self.axis.name, self.name)
        if config.has_section(sectionname):
            self.options = OrderedDict(config.items(sectionname))
        else:
            self.options = OrderedDict()

        for name, value in self.axis.defaults.items():
            if name not in self.options:
                self.options[name] = value


class Axis(object):
    def __init__(self, name, config):
        self.name = name
        self.load(config)

    def load(self, config):
        self.items = OrderedDict()
        values = config.get('axes', self.name).split(',')
        if config.has_section('axis:%s' % self.name):
            self.defaults = OrderedDict(
                config.items('axis:%s' % self.name)
            )
        else:
            self.defaults = {}
        for value in values:
            self.items[value.strip('*')] = AxisItem(self, value, config)


def render(incfg, options):
    # Adjust the [tox] envlist options to reflect the new sections added
    try:
        envlist = incfg.get("tox", 'envlist')
        envlist = [e.strip() for e in envlist.split(",")]
        envlist = set([e for e in envlist if e])
    except (configparser.NoOptionError, configparser.NoSectionError):
        envlist = set()
    if options.rewrite or len(envlist) == 0:
        test_envs = set()
        for s in incfg.sections():
            if s.startswith("testenv:"):
                env = s[len("testenv:"):].strip()
                if env in SKIP_VENVS:
                    continue
                test_envs.add(env)
        test_envs = [s for s in test_envs if s]
    
        for e in test_envs:
            if e not in envlist:
                envlist.add(e)
        envlist = ["%s," % e for e in sorted(envlist)]
        if envlist:
            envlist[-1] = envlist[-1].rstrip(",")
            if not incfg.has_section("tox"):
                incfg.add_section("tox")
            incfg.set("tox", "envlist", "\n".join(envlist))

    buf = six.StringIO()
    incfg.write(buf)
    contents = [
        HEADER % {'filename': options.input},
        '',
        # Replace the tabs that configparser uses with spaces,
        # (why does it use these??)
        buf.getvalue().replace("\t", " " * 4),
    ]
    return "\n".join(contents)


def compile_template(incfg):
    axes = OrderedDict()

    if incfg.has_section('axes'):
        for axis in incfg.options('axes'):
            axes[axis] = Axis(axis, incfg)

    out = configparser.ConfigParser(dict_type=OrderedDict)
    for section in incfg.sections():
        if section == 'axes' or section.startswith('axis:'):
            continue
        out.add_section(section)
        for name, value in incfg.items(section):
            out.set(section, name, value)

    for combination in itertools.product(
            *[axis.items.keys() for axis in axes.values()]):
        options = OrderedDict()

        section_name = (
            'testenv:' + '-'.join([item for item in combination if item])
        )
        section_alt_name = (
            'testenv:' + '-'.join([
                itemname
                for axis, itemname in zip(axes.values(), combination)
                if itemname and not axis.items[itemname].isdefault
            ])
        )
        if section_alt_name == section_name:
            section_alt_name = None

        axes_items = [
            '%s:%s' % (axis, itemname)
            for axis, itemname in zip(axes, combination)
        ]

        for axis, itemname in zip(axes.values(), combination):
            axis_options = axis.items[itemname].options
            if 'constraints' in axis_options:
                constraints = axis_options['constraints'].split('\n')
                for c in constraints:
                    if c.startswith('!') and c[1:] in axes_items:
                        continue
            for name, value in axis_options.items():
                if name in options:
                    options[name] += value
                else:
                    options[name] = value

        constraints = options.pop('constraints', '').split('\n')
        neg_constraints = [c[1:] for c in constraints if c and c[0] == '!']
        if not set(neg_constraints).isdisjoint(axes_items):
            continue

        if not out.has_section(section_name):
            out.add_section(section_name)

        if (section_alt_name and not out.has_section(section_alt_name)):
            out.add_section(section_alt_name)

        for name, value in reversed(options.items()):
            if not out.has_option(section_name, name):
                out.set(section_name, name, value)
            if section_alt_name and not out.has_option(section_alt_name, name):
                out.set(section_alt_name, name, value)

    return out


def main():
    options, args = parser.parse_args()
    tmpl = configparser.ConfigParser()
    tmpl.read(options.input)
    with open(options.output, 'wb') as outfile:
        text = render(compile_template(tmpl), options)
        outfile.write(text)


if __name__ == '__main__':
    main()
